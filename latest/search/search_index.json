{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"Free Energy and MD Toolkit using OpenMM <p>A comprehensive toolkit for predicting free energies</p> <p> </p> <p>The <code>femto</code> framework aims to offer not only a compact and comprehensive toolkit for predicting binding free energies using methods including <code>ATM</code> and <code>SepTop</code>, but also a full suite of utilities for running advanced simulations using OpenMM, including support for HREMD and REST2.</p> <p>Warning</p> <p>From version 0.3.0 onwards, the codebase was re-written to completely remove the dependency on <code>parmed</code>, allowing easy use of any force field parameters in OpenFF, Amber, and OpenMM FFXML formats. This re-write also introduced a number of neccessary API changes. See the migration guide for more details.</p> <p>Further, the default protocols selected for the ATM and SepTop methods are still being tested and optimized, and may not be optimal. It is recommended that you run a few test calculations to ensure that the results are reasonable.</p>"},{"location":"#installation","title":"Installation","text":"<p>This package can be installed using <code>conda</code> (or <code>mamba</code>, a faster version of <code>conda</code>):</p> <pre><code>mamba install -c conda-forge femto\n</code></pre> <p>If you are running with MPI on an HPC cluster, you may need to instruct conda to use your local installation depending on your setup</p> <pre><code>mamba install -c conda-forge femto \"openmpi=4.1.5=*external*\"\n</code></pre> <p>where in this example you should change <code>4.1.5</code> to match the version of OpenMPI installed on your cluster / machine.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, see the usage guide.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This framework benefited hugely from the work of Psivant's Open Science Fellows.</p>"},{"location":"#atm","title":"ATM","text":"<p>The ATM implementation is based upon the work and advice of E. Gallicchio et al:</p> <ul> <li>Wu, Joe Z., et al. \"Alchemical transfer approach to absolute binding free energy estimation.\" Journal of Chemical Theory and Computation 17.6 (2021): 3309-3319.</li> <li>Azimi, Solmaz, et al. \"Relative binding free energy calculations for ligands with diverse scaffolds with the alchemical transfer method.\" Journal of Chemical Information and Modeling 62.2 (2022): 309-323.</li> </ul>"},{"location":"#septop","title":"SepTop","text":"<p>The SepTop implementation is based upon the work and advice of H. M. Baumann, D. L. Mobley et al:</p> <ul> <li>Rocklin, Gabriel J., David L. Mobley, and Ken A. Dill. \"Separated topologies\u2014A method for relative binding free energy calculations using orientational restraints.\" The Journal of chemical physics 138.8 (2013).</li> <li>Baumann, Hannah M., et al. \"Broadening the scope of binding free energy calculations using a Separated Topologies approach.\" Journal of Chemical Theory and Computation 19.15 (2023): 5058-5076.</li> </ul>"},{"location":"development/","title":"Development","text":"<p>To create a development environment, you must have <code>mamba</code> installed.</p> <p>A development conda environment can be created and activated with:</p> <pre><code>make env\nconda activate femto\n</code></pre> <p>To format the codebase:</p> <pre><code>make format\n</code></pre> <p>To run the unit tests:</p> <pre><code>make test\n</code></pre> <p>To serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"guide-atm/","title":"ATM","text":"<p>The Alchemical Transfer Method (ATM), unlike traditional FEP methods, does not require setting up any kind of hybrid topology, or even alchemically transforming the ligand. Instead, ligands are 'translated' along a displacement vector from the binding site to the bulk solvent and vice-versa. Not only does this greatly simplify the setup, but also easily allows for computing the binding free energy between two ligands that do not share a common core.</p> <p>It is highly recommended to read the original ABFE and RBFE ATM publications for a more detailed description of the method, as well as the fantastic documentation being put together by the Gallicchio lab</p> <p>Here the general approach and python API for running ATM calculations with <code>femto</code> is described. See the overview for instructions on running using the CLI.</p> Tip <p>This guide will walk through setting up all calculations serially, however <code>femto</code> supports parallelisation using MPI. See femto.fe.atm.run_workflow and its source for an MPI ready runner / example implementation.</p>"},{"location":"guide-atm/#procedure","title":"Procedure","text":"<p>The implementation of ATM in <code>femto</code> generally proceeds by setting up the complex in solvation from the pre-prepared receptor and ligand structures, running equilibration simulation at each lambda state, running Hamiltonian replica exchange (HREMD) between each window, and finally computing the final free energy using MBAR or UWHAM.</p> <p>The full procedure is configured using the femto.fe.atm.ATMConfig class:</p> <pre><code>import femto.fe.atm\n\nconfig = femto.fe.atm.ATMConfig()\n</code></pre>"},{"location":"guide-atm/#setup","title":"Setup","text":"<p>The setup procedure is responsible for combining the ligand(s) and receptor structures into a single complex, solvating it, selecting any reference atoms if not provided, applying restraints, and finally creating the main OpenMM system.</p> <p>It begins with the already prepared (correct binding pose, protonation, etc.) structures of the ligand(s) and receptor:</p> <pre><code>import pathlib\n\nimport femto.md.prepare\n\neralpha_dir = pathlib.Path(\"eralpha\")\n\nligand_1, ligand_2 = femto.md.prepare.load_ligands(\n    eralpha_dir / \"forcefield/2d/vacuum.mol2\",\n    eralpha_dir / \"forcefield/2e/vacuum.mol2\",\n)\nreceptor = femto.md.prepare.load_receptor(\n    eralpha_dir / \"proteins/eralpha/protein.pdb\"\n)\n</code></pre> <p>The ligands must both be in reasonable binding poses. The setup code will handle translating the ligands along the displacement vector as required.</p> <p>If the ligands / receptor has already been parameterized, the OpenMM XML or AMBER prmtop files can additionally be specified:</p> <pre><code>extra_parameters = [\n    eralpha_dir / \"forcefield/2d/vacuum.parm7\",\n    eralpha_dir / \"forcefield/2e/vacuum.parm7\",\n]\n</code></pre> <p>If unspecified, an OpenFF force field will be used to parameterize the ligands. The exact force field can be specified in the configuration.</p> Note <p>In previous versions of <code>femto</code>, the parameters were required. However in the current version, the parameters are optional and will be automatically generated if not provided.</p> <p>The vector along which the ligands will be translated must also be defined. <code>femto</code> provides an experimental utility to automatically compute this:</p> <pre><code>displacement = femto.fe.atm.select_displacement(\n    receptor, ligand_1, ligand_2, config.setup.displacement\n)\n</code></pre> <p>At present, it will attempt to place the ligands in each corner of the simulation box at a pre-specified distance from the binding site, and select the vector that maximizes the distance between the ligand and receptor atoms.</p> Warning <p>This method is still experimental and may not always select the optimal vector.</p> <p>When running RBFE calculations, the ligand 'reference' atoms (i.e. those that will be used for the alignment restraint) can be optionally specified:</p> <pre><code>ligand_1_ref_query = [\"idx. 7\",  \"idx. 11\", \"idx. 23\"]  # OR None\nligand_2_ref_query = [\"idx. 12\", \"idx. 7\",  \"idx. 21\"]  # OR None\n</code></pre> <p>If not specified, these will be automatically selected. By default (<code>ligand_method='chen'</code>), the distance between each atom in the first ligand and each atom in the second ligand is calculated. Pairs of atoms with the smallest distance will be greedily selected, ignoring pairs that would lead to all atoms being co-linear.</p> Warning <p>This method is still experimental and may not always select the optimal reference atoms.</p> <p>Similarly, the receptor atoms that define the binding site can be optionally specified:</p> <pre><code>receptor_ref_query = [\n    \"resi 36+39+40+42+43+77+80+81+84+95+97+111+113+114+117+118+214+215+217+218 and name CA\"\n]  # OR None\n</code></pre> <p>If not specified, these will be automatically selected. By default, these will include all alpha carbons within a defined cutoff from the ligand.</p> <p>The full complex topology and OpenMM system can then be created:</p> <pre><code>complex_topology, complex_system = femto.fe.atm.setup_system(\n    config.setup,\n    receptor,\n    ligand_1,\n    ligand_2,\n    [],\n    displacement,\n    receptor_ref_query,\n    ligand_1_ref_query,\n    ligand_2_ref_query,\n)\n</code></pre> <p>At this point, the system object will contain the fully parameterized system, a center-of-mass restraint on each ligand, an 'alignment' restraint between the two ligands, and a light position restraint on (by default) the alpha carbons of the receptor. When solvating, a cavity will be created where the ligands will be translated to.</p> <p>If HMR or REST2 were enabled in the config, the system will also contain the appropriate modifications enabling these.</p> Tip <p>The solvated system can be saved for easier inspection and checkpointing:</p> <pre><code>complex_topology.to_file(\"system.pdb\")\n</code></pre>"},{"location":"guide-atm/#equilibration","title":"Equilibration","text":"<p>The equilibration procedure is reasonably flexible, and is almost fully specified by the configuration. It comprises the list of 'stages' to run sequentially for each state, including minimization, temperature annealing, and either NVT or NPT MD simulation.</p> <p>The default procedure is to:</p> <ol> <li>energy minimize the system</li> <li>anneal the temperature from 50 K to 300 K over 100 ps</li> <li>run 300 ps of NPT simulation at 300 K</li> <li>set the box vectors to the maximum across all states as HREMD will be run at constant volume</li> </ol> <p>where at each stage light flat bottom position restraints are applied to any protein and ligand atoms.</p> <p>The equilibration across all states can be run using femto.fe.atm.equilibrate_states:</p> <pre><code>import femto.md.constants\n\ncoords = femto.fe.atm.equilibrate_states(\n    complex_system,\n    complex_topology,\n    config.states,\n    config.equilibrate,\n    displacement,\n    femto.md.constants.OpenMMPlatform.CUDA,\n    reporter=None\n)\n</code></pre> <p>The results are returned as a list of OpenMM <code>State</code> objects.</p>"},{"location":"guide-atm/#hremd","title":"HREMD","text":"<p>The HREMD procedure is also reasonably flexible, and is almost fully specified by the configuration. By default, each step is propagated for 600 ps as a warmup phase. All statistics collected during the warmup are discarded.</p> <p>Following this, 10ns of replica exchange is performed with a timestep of 4 fs, with exchanges attempted every 4 ps.</p> <pre><code>import femto.md.reporting\n\noutput_dir = pathlib.Path(\"eralpha/outputs-atm\")\n\nreporter = femto.md.reporting.TensorboardReporter(output_dir)  # OR None\nconfig.sample.analysis_interval = 10\n\nfemto.fe.atm.run_hremd(\n    complex_system,\n    complex_topology,\n    coords,\n    config.states,\n    config.sample,\n    displacement,\n    femto.md.constants.OpenMMPlatform.CUDA,\n    output_dir,\n    reporter\n)\n</code></pre> <p>We have passed an optional reporter to the <code>run_hremd</code> function. As the name suggests, this reporter will log statistics to a TensorBoard run file in the output directory. At present, these include online estimates of the total free energy and the free energy of each 'leg'.</p> <p>The statistics collected such as reduced potentials and acceptance rates are stored in a specified output directory as a convenient Arrow parquet file (<code>\"eralpha/outputs-atm/samples.arrow\"</code>).</p>"},{"location":"guide-atm/#analysis","title":"Analysis","text":"<p>The final step is to compute the free energy using MBAR or UWHAM. This can be easily done using the femto.fe.atm.compute_ddg convience function:</p> <pre><code>import femto.fe.ddg\n\nu_kn, n_k = femto.fe.ddg.load_u_kn(output_dir/ \"samples.arrow\")\n\nddg_df = femto.fe.atm.compute_ddg(config.sample, config.states, u_kn, n_k)\nprint(ddg_df)\n</code></pre> <p><code>femto</code> also offers lower level methods for computing the free energy, which can be useful for debugging or if you want to compute things like overlap matrices:</p> <pre><code>import femto.fe.ddg\n\nn_states_leg_1 = config.states.direction.index(-1)\nn_states_leg_2 = len(config.states.lambda_1) - n_states_leg_1\n\nstate_groups = [(n_states_leg_1, 1.0), (n_states_leg_2, 1.0)]\n\nestimated, overlap = femto.fe.ddg.estimate_ddg(\n    u_kn, n_k, config.sample.temperature, state_groups\n)\n</code></pre>"},{"location":"guide-atm/#edges","title":"Edges","text":"<p>The ATM CLI provides an option to specify a YAML file containing edge data. This file not only includes the edges that need to be computed, but can also optionally specify the 'reference' atoms for each ligand and the receptor atoms that form the binding cavity:</p> <pre><code>receptor: eralpha\nreceptor_ref_query: \":36,39,40,42,43,77,80,81,84,95,97,111,113,114,117,118,214,215,217,218 &amp; @CA\"\n\nedges:\n  - {ligand_1: 2d, ligand_2: 2e, ligand_1_ref_atoms: [\"@7\", \"@11\", \"@23\"], ligand_2_ref_atoms: [\"@12\", \"@7\", \"@21\"]}\n  - {ligand_1: 2d, ligand_2: 3a, ligand_1_ref_atoms: [\"@7\", \"@11\", \"@23\"], ligand_2_ref_atoms: [\"@15\", \"@10\", \"@5\"]}\n  - ...\n</code></pre> <p>The <code>receptor</code> field optionally specifies the name of the receptor, and should match the name of a subdirectory in your <code>proteins</code> directory. The optional <code>receptor_ref_query</code> field defines the AMBER style selection mask to use to manually select the receptor atoms that define the binding site. If unspecified, such atoms will be selected automatically as described above.</p> <p>At minimum, the <code>edges</code> field must define pairs of ligands to compute the binding free energy between:</p> <pre><code>edges:\n  - {ligand_1: 2d, ligand_2: 2e}\n  - {ligand_1: 2d, ligand_2: 3a}\n  - ...\n</code></pre> <p>where each name should match the name of a subdirectory in your <code>forcefield</code> directory. In this case where no reference atoms are specified, the reference atoms will be selected based on the configuration as defined above.</p>"},{"location":"guide-fe/","title":"Free Energy","text":"<p><code>femto</code> provides a simple interface for estimating relative and absolute binding free energies using different methods (currently ATM and SepTop). If offers a full Python API as well as a convenient command-line interface.</p>"},{"location":"guide-fe/#preparing-the-inputs","title":"Preparing the Inputs","text":"<p>In general, the same set of inputs can be used for all-methods supported by this framework; these include pre-parameterized and docked ligands, and pre-prepared protein structures.</p> <p>The easiest way to prepare the inputs for <code>femto</code>, especially when using the CLI, is to structure them in the 'standard directory structure' expected by the framework:</p> <pre><code>.\n\u251c\u2500 forcefield/\n\u2502  \u251c\u2500 &lt;ligand 1&gt;/\n\u2502  \u2502  \u251c\u2500 vacuum.mol2\n\u2502  \u2502  \u2514\u2500 vacuum.xml\n\u2502  \u2514\u2500 ...\n\u251c\u2500 proteins/\n\u2502  \u2514\u2500 &lt;target&gt;/\n\u2502     \u2514\u2500 protein.pdb\n\u251c\u2500 config.yaml\n\u2514\u2500 edges.yaml\n</code></pre> <p>In particular, it should contain:</p> Contents forcefield A subdirectory for each ligand of interest, which must include:             <ul> <li><code>vacuum.[mol2,sdf]</code>: The ligand file. The ligand should already be in the correct docked pose, with the correct protonation state and tautomeric form.</li> <li><code>vacuum.[xml,parm7]</code> (optional): The parameter file for the ligand.</li> </ul> proteins A single subdirectory named after the protein target, which must include:             <ul> <li><code>protein.[pdb,mol2,sdf]</code>: A file containing the target protein and any crystallographic waters in the correct pose.</li> <li><code>protein.[xml,parm7]</code> (optional): The parameter file for the protein.</li> </ul> config.yaml (optional) A YAML file containing configuration settings, such as the equilibration protocol, lambda states, and HREMD settings. edges.yaml or Morph.in These files define the edges (ligand pairs) for which you want to compute the binding free energies.             <ul> <li><code>edges.yaml</code>: A YAML file that specifies which edges to compute. It can include extra and per-edge settings depending on the method, such as masks for manually selecting reference atoms.</li> <li><code>Morph.in</code>: A simpler text file format where each line represents an edge in the format <code>&lt;ligand 1&gt;~&lt;ligand 2&gt;</code>.</li> </ul> Tip <p>See the <code>examples</code> directory for examples of this structure.</p> <p>Most methods define a default configuration that will be used if one isn't specified. These can be accessed using the <code>config</code> command:</p> <pre><code>femto atm    config &gt; default-atm-config.yaml\nfemto septop config &gt; default-septop-config.yaml\n</code></pre>"},{"location":"guide-fe/#running-the-calculations","title":"Running the Calculations","text":"<p>If running on a SLURM cluster (recommended), <code>femto</code> provides helpers for running all edges in parallel. Otherwise, you can run each edge individually.</p>"},{"location":"guide-fe/#all-edges","title":"All Edges","text":"<p>If running on a SLURM cluster, all the edges can be run using the <code>femto &lt;method&gt; submit-workflows</code> or <code>femto &lt;method&gt; submit-replicas</code> commands:</p> ATMSepTop <pre><code>femto atm         --config              \"eralpha/config-atm.yaml\"  \\\n                                                                   \\\n  submit-replicas  --slurm-nodes         2                         \\\n                   --slurm-tasks         8                         \\\n                   --slurm-gpus-per-task 1                         \\\n                   --slurm-cpus-per-task 4                         \\\n                   --slurm-partition     \"project-gpu\"             \\\n                   --slurm-walltime      \"48:00:00\"                \\\n                                                                   \\\n                   --root-dir            \"eralpha\"                 \\\n                   --output-dir          \"eralpha/outputs-atm\"     \\\n                   --edges               \"eralpha/edges-atm.yaml\"  \\\n                   --n-replicas          5\n</code></pre> <pre><code>femto septop      --config              \"eralpha/config-septop.yaml\"  \\\n                                                                      \\\n  submit-replicas  --slurm-nodes         5                            \\\n                   --slurm-tasks         19                           \\\n                   --slurm-gpus-per-task 1                            \\\n                   --slurm-cpus-per-task 4                            \\\n                   --slurm-partition     \"project-gpu\"                \\\n                   --slurm-walltime      \"48:00:00\"                   \\\n                                                                      \\\n                   --root-dir            \"eralpha\"                    \\\n                   --output-dir          \"eralpha/outputs-septop\"     \\\n                   --edges               \"eralpha/edges-septop.yaml\"  \\\n                   --n-replicas          5\n</code></pre> Tip <p>The <code>examples</code> directory also contains configuration files for enabling REST2 (<code>config-&lt;method&gt;-rest.yaml</code>).</p> <p>The ER\u03b1 ATM example uses 22 lambda windows (as defined in <code>\"eralpha/config-atm.yaml\"</code>). We have only requested a total of 8 GPUs here, however. <code>femto</code> will split the lambda windows across the available GPUs, and simulate each in turn until all windows have been simulated. In principle then the calculation can be run using anywhere between 1 and <code>n_lambda</code> GPUs.</p> Note <p>If more GPUs are requested than there are lambda windows, the extra GPUs will remain idle.</p> <p>As calculations finish successfully, the estimated free energies will be written to the output directory as a CSV file (<code>eralpha/outputs-&lt;method&gt;/ddg.csv</code>). If the <code>analysis_interval</code> is set in the <code>sample</code> section of the config, you should also see TensorBoard run files being created in the output directory. These can be used to monitor the progress of the simulations, especially online estimates of the free energies.</p>"},{"location":"guide-fe/#single-edges","title":"Single Edges","text":"<p>If you want to run a specific edge rather than submitting all edges defined in <code>\"eralpha/edges-&lt;method&gt;.yaml\"</code>, you can instead run:</p> ATMSepTop <pre><code>srun --mpi=pmix -n &lt;N_LAMBDAS&gt;                        \\\n                                                      \\\nfemto atm     --config     \"eralpha/config-atm.yaml\"  \\\n                                                      \\\n  run-workflow --ligand-1   \"2d\"                      \\\n               --ligand-2   \"2e\"                      \\\n               --root-dir   \"eralpha\"                 \\\n               --output-dir \"eralpha/outputs-atm\"     \\\n               --edges       \"eralpha/edges-atm.yaml\"\n</code></pre> <pre><code>srun --mpi=pmix -n &lt;N_COMLEX_LAMBDAS&gt;                       \\\n                                                            \\\nfemto septop  --config    \"eralpha/config-septop.yaml\"      \\\n                                                            \\\n  run-complex --ligand-1   \"2d\"                             \\\n              --ligand-2   \"2e\"                             \\\n              --root-dir   \"eralpha\"                        \\\n              --output-dir \"eralpha/outputs-septop/complex\" \\\n              --edges      \"eralpha/edges-septop.yaml\"\n\nsrun --mpi=pmix -n &lt;N_SOLUTION_LAMBDAS&gt;                       \\\n                                                              \\\nfemto septop  --config     \"eralpha/config-septop.yaml\"       \\\n                                                              \\\n  run-solution --ligand-1   \"2d\"                              \\\n               --ligand-2   \"2e\"                              \\\n               --root-dir   \"eralpha\"                         \\\n               --output-dir \"eralpha/outputs-septop/solution\" \\\n               --edges      \"eralpha/edges-septop.yaml\"\n\nfemto septop  --config     \"eralpha/config-septop.yaml\"                            \\\n                                                                                   \\\n  analyze --complex-system   eralpha/outputs-septop/complex/_setup/system.xml      \\\n          --complex-samples  eralpha/outputs-septop/complex/_sample/samples.arrow  \\\n          --solution-system  eralpha/outputs-septop/solution/_setup/system.xml     \\\n          --solution-samples eralpha/outputs-septop/solution/_sample/samples.arrow \\\n          --output           eralpha/outputs-septop/ddg.csv\n</code></pre> <p>or using <code>mpirun</code> if not running using SLURM.</p> Note <p>By default <code>femto</code> will try and assign each process on a node to a different GPU based on the local rank and <code>CUDA_VISIBLE_DEVICES</code>, i.e. <code>gpu_device = local_rank % len(CUDA_VISIBLE_DEVICES)</code>. Depending on your setup, you may need to create a hostfile to ensure the correct GPUs are used.</p> <p>Here we have still specified the path to the edges file (<code>edges-atm.yaml</code>) even though we are running a specific edge. This is optional, but will ensure <code>femto</code> uses the reference atoms defined within rather than trying to automatically select them.</p> <p>The <code>--report-dir</code> option can be used to optionally specify a directory to write tensorboard run files to. This can be useful for monitoring the progress of the simulations, especially online estimates of the free energies.</p>"},{"location":"guide-md/","title":"Molecular Dynamics","text":"<p>The <code>femto.md</code> module exposes a number of utilities for setting up and running MD simulations. These include solvating the system, applying hydrogen mass repartitioning (HMR), preparing a system for REST2 sampling, and running Hamiltonian replica exchange MD (HREMD) sampling across multiple processes.</p>"},{"location":"guide-md/#preparing-a-system","title":"Preparing a System","text":"<p>Most utilities within the framework in general expected an OpenMM <code>System</code> object and a mdtop.Topology. While these can be loaded and generated from a variety of sources, the framework provides built-in utilities for loading ligands from MOL2 and SDF files and 'receptors' (e.g. proteins with crystallographic waters) from PDB, MOL2 and SDF files.</p> <p>Single ligands can be easily loaded using femto.md.prepare.load_ligand</p> <pre><code>import pathlib\n\nimport femto.md.constants\nimport femto.md.prepare\n\neralpha_dir = pathlib.Path(\"eralpha\")\n\nligand = femto.md.prepare.load_ligand(\n    eralpha_dir / \"forcefield/2d/vacuum.mol2\",\n    residue_name=femto.md.constants.LIGAND_1_RESIDUE_NAME\n)\n</code></pre> <p>while two ligands (e.g. for use in an RBFE calculation) can be loaded using femto.md.prepare.load_ligands</p> <pre><code>ligand_1, ligand_2 = femto.md.prepare.load_ligands(\n    eralpha_dir / \"forcefield/2d/vacuum.mol2\",\n    eralpha_dir / \"forcefield/2e/vacuum.mol2\",\n)\n</code></pre> <p>in the latter case the ligands will have their residue names overwritten to femto.md.constants.LIGAND_1_RESIDUE_NAME and femto.md.constants.LIGAND_2_RESIDUE_NAME respectively.</p> <p>No modifications will be made to the ligands, so they should already be in the correct protonation state and tautomeric form of interest.</p> <p>The 'receptor' (possibly also including any crystal waters and ions) can be loaded using femto.md.prepare.load_receptor:</p> <pre><code>temoa_dir = pathlib.Path(\"temoa\")\n\nreceptor = femto.md.prepare.load_receptor(temoa_dir / \"host.mol2\")\n</code></pre>"},{"location":"guide-md/#prepare-the-system","title":"Prepare the System","text":"<p>Once the ligand and / or receptor have been loaded, they can be solvated and parameterized using femto.md.prepare.prepare_system. This step also includes neutralizing the system with counter ions, as well as optionally adding a salt concentration.</p> <pre><code>import openmm.unit\n\nimport femto.md.config\nimport femto.md.prepare\n\nprep_config = femto.md.config.Prepare(\n    ionic_strength=0.15 * openmm.unit.molar,\n    neutralize=True,\n    cation=\"Na+\",\n    anion=\"Cl-\",\n    water_model=\"tip3p\",\n    box_padding=10.0 * openmm.unit.angstrom,\n)\n\ntopology, system = femto.md.prepare.prepare_system(\n    receptor=receptor,  # or None if no receptor\n    ligand_1=ligand_1,\n    ligand_2=None,      # or `ligand_2` if setting up FEP for example\n    config=prep_config,\n)\n</code></pre> <p>By default, an OpenFF force field will be used to parameterize the ligands / any cofactors. The exact force field can be specified in the femto.md.config.Prepare configuration.</p> <p>If the ligands / receptor has already been parameterized, the OpenMM FFXML or AMBER prmtop files can additionally be specified:</p> <pre><code>extra_params = [\n    eralpha_dir / \"forcefield/2d/vacuum.parm7\",\n    eralpha_dir / \"forcefield/2e/vacuum.parm7\",\n]\n\ntopology, system = femto.md.prepare.prepare_system(\n    receptor=receptor,  # or None if no receptor\n    ligand_1=ligand_1,\n    ligand_2=None,      # or `ligand_2` if setting up FEP for example\n    config=prep_config,\n    extra_params=extra_params\n)\n</code></pre>"},{"location":"guide-md/#hmr-and-rest2","title":"HMR and REST2","text":"<p>HMR can be applied to the system using femto.md.prepare.apply_hmr:</p> <pre><code>femto.md.prepare.apply_hmr(system, topology)\n</code></pre> <p>This modifies the system in-place.</p> <p>Similarly, the system can be prepared for REST2 sampling using femto.md.rest.apply_rest:</p> <pre><code>import femto.md.rest\n\nrest_config = femto.md.config.REST(scale_torsions=True, scale_nonbonded=True)\n\nsolute_idxs = topology.select(f\"resn {femto.md.constants.LIGAND_1_RESIDUE_NAME}\")\nfemto.md.rest.apply_rest(system, solute_idxs, rest_config)\n</code></pre> <p>Currently only the torsions and non-bonded interactions (electrostatic and vdW) can be scaled, but this may be extended in the future. Again, this modifies the system in-place.</p> Warning <p>Any alchemical modifications to the system (e.g. using femto.fe.fep.apply_fep) should be applied before trying to apply REST2.</p> <p>REST2 is implemented by introducing global context parameters that represent \\(\\frac{\\beta_m}{\\beta_0}\\) and \\(\\sqrt{\\frac{\\beta_m}{\\beta_0}}\\) which can easily be set and modified on an OpenMM <code>Context</code>.</p> Tip <p>See femto.md.rest.REST_CTX_PARAM and femto.md.rest.REST_CTX_PARAM_SQRT for the names of these parameters, and later on in this guide for convenience functions for setting and modifying them.</p>"},{"location":"guide-md/#saving-the-system","title":"Saving the System","text":"<p>The prepared inputs are most easily stored as a coordinate file and an OpenMM XML system file:</p> <pre><code>import openmm\n\ntopology.to_file(\"system.pdb\")\npathlib.Path(\"system.xml\").write_text(openmm.XmlSerializer.serialize(system))\n</code></pre>"},{"location":"guide-md/#running-md","title":"Running MD","text":"<p>The <code>femto.md.simulate</code> modules provide convenience functions for simulating prepared systems. This includes chaining together multiple 'stages' such as minimization, annealing, and molecular dynamics.</p> <p>The simulation protocol is defined as a list of 'stage' configurations:</p> <pre><code>import openmm.unit\n\nimport femto.md.simulate\n\nkcal_per_mol = openmm.unit.kilocalorie_per_mole\nangstrom = openmm.unit.angstrom\n\ntemperature = 300.0 * openmm.unit.kelvin\n\nligand_mask = f\"resn {femto.md.constants.LIGAND_1_RESIDUE_NAME}\"\n\nrestraints = {\n    # each key should be an PyMol style selection mask that defines which\n    # atoms in the system should be restrained\n    ligand_mask: femto.md.config.FlatBottomRestraint(\n        k=25.0 * kcal_per_mol / angstrom**2, radius=1.5 * angstrom\n    )\n}\n\nstages = [\n    femto.md.config.Minimization(restraints=restraints),\n    femto.md.config.Anneal(\n        integrator=femto.md.config.LangevinIntegrator(\n            timestep=1.0 * openmm.unit.femtosecond,\n        ),\n        restraints=restraints,\n        temperature_initial=50.0 * openmm.unit.kelvin,\n        temperature_final=temperature,\n        n_steps=50000,\n        # the frequency, in number of steps, with which to increase\n        # the temperature\n        frequency=100,\n    ),\n    femto.md.config.Simulation(\n        integrator=femto.md.config.LangevinIntegrator(\n            timestep=1.0 * openmm.unit.femtosecond,\n        ),\n        restraints=restraints,\n        temperature=temperature,\n        pressure=None,\n        n_steps=50000,\n    ),\n    femto.md.config.Simulation(\n        integrator=femto.md.config.LangevinIntegrator(\n            timestep=4.0 * openmm.unit.femtosecond,\n        ),\n        temperature=temperature,\n        pressure=1.0 * openmm.unit.bar,\n        n_steps=150000,\n    )\n]\n</code></pre> <p>The restraints dictionary is optional, but can be used to place position restraints on atoms during the equilibration stages. The reference positions for the restraints are taken as the output from the previous stage, or the inital positions if it is the first stage.</p> <p>The femto.md.simulate.simulate_state function can then be used to run each stage sequentially:</p> <pre><code>import femto.md.simulate\n\nstate = {femto.md.rest.REST_CTX_PARAM: 1.0}\n\nfinal_coords = femto.md.simulate.simulate_state(\n    system, topology, state, stages, femto.md.constants.OpenMMPlatform.CUDA\n)\n</code></pre> <p>The initial coordinates and box vectors are taken from the <code>topology</code> object.</p> <p>The <code>state</code> dictionary is used to set OpenMM global context parameters. If your system does not use any global context parameters (e.g. it hasn't been prepared for REST2), or you're happy to use the defaults that were set, then you can simply pass an empty dictionary.</p> Note <p>By default the REST context parameters are set to 1.0, i.e., there is no scaling, but we set it explicitly here as an example.</p> <p>You may notice here that we have only set \\(\\frac{\\beta_m}{\\beta_0}\\) and not \\(\\sqrt{\\frac{\\beta_m}{\\beta_0}}\\) even though both are 'required'. The <code>simulate_state</code> will automatically set \\(\\sqrt{\\frac{\\beta_m}{\\beta_0}}\\) based on the value of \\(\\frac{\\beta_m}{\\beta_0}\\). See femto.md.utils.openmm.evaluate_ctx_parameters for more details.</p>"},{"location":"guide-md/#running-hremd","title":"Running HREMD","text":"<p>Hamiltonian replica exchange MD (HREMD) can be run using the femto.md.hremd module. It expects a system that has been prepared to expose global context parameters. These commonly include parameters for alchemically scaling the vdW and electrostatic interactions, as well as parameters for REST2 sampling.</p> <p>Each individual 'replica' (i.e. a simulation run at a given state as defined by a set of global context parameters) can either be run in a single process, or in parallel across multiple processes using MPI. In the case of the former, each state is run sequentially prior to proposing swaps, while in the latter case states are run in parallel.</p> Note <p>When running in parallel, the number of processes does not need to match the number of states. In this case, each process will be assigned a subset of states to run sequentially.</p>"},{"location":"guide-md/#running-in-a-single-process","title":"Running in a Single Process","text":"<p>The femto.md.hremd.run_hremd function can be used directly as part of another script if running HREMD in a single process:</p> <pre><code>import pathlib\n\nimport openmm.unit\n\nimport femto.md.config\nimport femto.md.constants\nimport femto.md.hremd\nimport femto.md.utils.openmm\nimport femto.md.rest\n\noutput_dir = pathlib.Path(\"hremd-outputs\")\n\n# define the REST2 temperatures to sample at\nrest_temperatures = [300.0, 310.0, 320.0] * openmm.unit.kelvin\nrest_betas = [\n    1.0 / (openmm.unit.MOLAR_GAS_CONSTANT_R * rest_temperature)\n    for rest_temperature in rest_temperatures\n]\n\nstates = [\n    {femto.md.rest.REST_CTX_PARAM: rest_beta / rest_betas[0]}\n    for rest_beta in rest_betas\n]\n# REST requires both beta_m / beta_0 and sqrt(beta_m / beta_0) to be defined\n# we can use a helper to compute the later from the former for each state\nstates = [\n    femto.md.utils.openmm.evaluate_ctx_parameters(state, system)\n    for state in states\n]\n\n# create the OpenMM simulation object\nintergrator_config = femto.md.config.LangevinIntegrator(\n    timestep=2.0 * openmm.unit.femtosecond,\n)\nintegrator = femto.md.utils.openmm.create_integrator(\n    intergrator_config, rest_temperatures[0]\n)\n\nsimulation = femto.md.utils.openmm.create_simulation(\n    system,\n    topology,\n    final_coords,  # or None to use the coordinates / box in topology\n    integrator=integrator,\n    state=states[0],\n    platform=femto.md.constants.OpenMMPlatform.CUDA,\n)\n\n# define how the HREMD should be run\nhremd_config = femto.md.config.HREMD(\n    # the number of steps to run each replica for before starting to\n    # propose swaps\n    n_warmup_steps=150000,\n    # the number of steps to run before proposing swaps\n    n_steps_per_cycle=500,\n    # the number of 'swaps' to propose - the total simulation length\n    # will be n_warmup_steps + n_steps * n_cycles\n    n_cycles=2000,\n    # the frequency with which to store trajectories of each replica.\n    # set to None to not store trajectories\n    trajectory_interval=10  # store every 10 * 500 steps.\n)\nfemto.md.hremd.run_hremd(\n    simulation,\n    states,\n    hremd_config,\n    # the directory to store sampled reduced potentials and trajectories to\n    output_dir=output_dir\n)\n</code></pre> <p>If successful, you should see a <code>hremd-outputs/samples.arrow</code> file being written to and a <code>hremd-outputs/trajectories</code> directory being created. The former contains the reduced potentials for each replica at each cycle, as well as statistics such as the number of swaps proposed and accepted.</p> <pre><code>import pyarrow\n\nwith pyarrow.OSFile(\"hremd-outputs/samples.arrow\", \"rb\") as file:\n    with pyarrow.RecordBatchStreamReader(file) as reader:\n        output_table = reader.read_all()\n\nprint(\"HREMD Schema:\", output_table.schema, flush=True)\nprint(\"HREMD Data:\", flush=True)\n\nprint(output_table.to_pandas().head(), flush=True)\n</code></pre> Tip <p>See also the femto.fe.ddg.load_u_kn utility for extracting decorrelated reduced potentials in a form that can be used with <code>pymbar</code></p>"},{"location":"guide-md/#running-in-parallel","title":"Running in Parallel","text":"<p>The above snipped for running HREMD in a single process can be easily modified to run in parallel across multiple processes using MPI. The main difference is that</p> <ol> <li>the snippet should be saved as a standalone script</li> <li>the following should (optionally) be added to the beginning of the script:</li> </ol> <pre><code>import femto.md.utils.mpi\n\nfemto.md.utils.mpi.divide_gpus()\n</code></pre> <p>This optional extra will attempt to crudely set the visible CUDA devices based on the current MPI rank. The script can then be run using <code>mpirun</code> (or <code>srun</code> etc.) as normal.</p>"},{"location":"guide-septop/","title":"SepTop","text":"<p>The Seperated Topology (SepTop) method, unlike traditional FEP methods and similar to ATM, does not require setting up any kind of hybrid topology which can be tricky to do rigorously. It proceeds instead by applying light restraints in the complex and solution phases to correctly orientate the ligands. Unlike ATM which can be run in a single shot, it currently requires computing the free energy of the ligand in the bound state, and the free energy of the ligand in the solution.</p> <p>It is highly recommended to read the original and updated SepTop publications for a more detailed description of the method. The implementation here was also inspired by the SepTop implementation implemented by Baumann et al.</p> <p>Here the general approach and python API for running SepTop calculations with <code>femto</code> is described. See the overview for instructions on running using the CLI.</p> Tip <p>This guide will walk through setting up all calculations serially, however <code>femto</code> supports parallelisation using MPI. See femto.fe.septop.run_complex_phase, femto.fe.septop.run_solution_phase and their respective sources for MPI ready runners / example implementations.</p>"},{"location":"guide-septop/#procedure","title":"Procedure","text":"<p>The implementation of SepTop in <code>femto</code> generally splits the setup and running of calculations into those required by the complex phase, and those required by the solution phase.</p> <p>Both phases however follow roughly the same steps, which include building and solvating the systems from the pre-prepared receptor and ligand structures, running equilibration simulation at each lambda state, running Hamiltonian replica exchange (HREMD) between each window, and finally computing the final free energy using MBAR or UWHAM.</p> <p>The full procedure is configured using the femto.fe.septop.SepTopConfig class:</p> <pre><code>import femto.fe.septop\n\nconfig = femto.fe.septop.SepTopConfig()\n</code></pre> <p>and partitions the options into those complex and those for the solution phase.</p>"},{"location":"guide-septop/#setup-complex","title":"Setup Complex","text":"<p>The setup procedure is responsible for combining the ligand(s) and receptor structures into a single complex, solvating it, selecting any reference atoms if not provided, applying restraints, and finally creating the main OpenMM system.</p> <p>It begins with the already prepared (correct binding pose, protonation, etc.) structures of the ligand(s) and receptor:</p> <pre><code>import pathlib\n\nimport femto.md.prepare\n\neralpha_dir = pathlib.Path(\"eralpha\")\n\nligand_1, ligand_2 = femto.md.prepare.load_ligands(\n    eralpha_dir / \"forcefield/2d/vacuum.mol2\",\n    eralpha_dir / \"forcefield/2e/vacuum.mol2\",\n)\nreceptor = femto.md.prepare.load_receptor(\n    eralpha_dir / \"proteins/eralpha/protein.pdb\"\n)\n</code></pre> <p>If the ligands / receptor has already been parameterized, the OpenMM XML or AMBER prmtop files can additionally be specified:</p> <pre><code>extra_parameters = [\n    eralpha_dir / \"forcefield/2d/vacuum.parm7\",\n    eralpha_dir / \"forcefield/2e/vacuum.parm7\",\n]\n</code></pre> <p>If unspecified, an OpenFF force field will be used to parameterize the ligands. The exact force field can be specified in the configuration.</p> Note <p>In previous versions of <code>femto</code>, the parameters were required. However in the current version, the parameters are optional and will be automatically generated if not provided.</p> <p>The ligand and receptor 'reference' atoms (i.e. those that will be used for the Boresch style restraints used to align the ligands) can be optionally specified by defining PyMol style atom selection queries:</p> <pre><code>ligand_1_ref_query = [\"...\", \"...\", \"...\"]  # OR None\nligand_2_ref_query = [\"...\", \"...\", \"...\"]  # OR None\n\nreceiver_ref_query = [\"...\", \"...\", \"...\"]  # OR None\n</code></pre> <p>These should match atoms in the respective ligands in isolation. If not specified, these will be automatically selected. By default (<code>ligand_method='baumann'</code>), this follows the procedure described in the Baumann et al. publication.</p> Note <p>Currently the selection procedure only considers a single configuration of the complex rather than a trajectory, and so does not include the variance criteria.</p> <p>The full complex topology and OpenMM system can then be created:</p> <pre><code>import femto.fe.septop\n\ncomplex_topology, complex_system = femto.fe.septop.setup_complex(\n    config.complex.setup,\n    receptor,\n    ligand_1,\n    ligand_2,\n    [],\n    receptor_ref_query,\n    ligand_1_ref_query,\n    ligand_2_ref_query,\n    extra_parameters\n)\n</code></pre> <p>At this point, the system object will contain the fully parameterized system, and a Boresch style restraint on each ligand. If HMR or REST2 were enabled in the config, the system will also contain the appropriate modifications enabling these.</p> Tip <p>The solvated system can be saved for easier inspection and checkpointing:</p> <pre><code>complex_topology.to_file(\"system.pdb\")\n</code></pre>"},{"location":"guide-septop/#setup-solution","title":"Setup Solution","text":"<p>The solution phase calculation follows the 'two ligands separated by a distance restraint' approach outlined by Baumann et al, rather than performing two absolute hydration free energy (HFE) calculations. This is mostly as it makes it easier to horizontally scale edge calculations independantly, but the framework does very much contain the machinery to perform absolute HFE calculations if desired.</p> <p>The setup procedure is responsible for combining the ligand(s) and at a fixed distance, solvating, selecting any reference atoms if not provided, applying restraints, and finally creating the main OpenMM system.</p> <pre><code>import femto.fe.septop\n\nsolution_topology, solution_system = femto.fe.septop.setup_solution(\n    config.solution.setup,\n    ligand_1,\n    ligand_2,\n    ligand_1_ref_query,\n    ligand_2_ref_query,\n)\n</code></pre> <p>The distance restraint between the two ligands is applied between the first reference atom of each ligand.</p> <p>At this point, the system object will contain the fully parameterized system, and a distance restraint between ligands. If HMR or REST2 were enabled in the config, the system will also contain the appropriate modifications enabling these.</p>"},{"location":"guide-septop/#equilibration","title":"Equilibration","text":"<p>The equilibration procedure is reasonably flexible, and is almost fully specified by the configuration. It comprises the list of 'stages' to run sequentially for each state, including minimization, temperature annealing, and either NVT or NPT MD simulation.</p> <p>The default procedure is to:</p> <ol> <li>energy minimize the system</li> <li>anneal the temperature from 50 K to 300 K over 100 ps</li> <li>run 300 ps of NPT simulation at 300 K</li> </ol> <p>where at each stage light flat bottom position restraints are applied to any protein and ligand atoms.</p> ComplexSolution <pre><code>import femto.md.constants\n\ncoords = femto.fe.septop.equilibrate_states(\n    complex_system,\n    complex_topology,\n    config.complex.states,\n    config.complex.equilibrate,\n    femto.md.constants.OpenMMPlatform.CUDA,\n    reporter=None\n)\n</code></pre> <pre><code>import femto.md.constants\n\ncoords = femto.fe.septop.equilibrate_states(\n    solution_system,\n    solution_topology,\n    config.solution.states,\n    config.solution.equilibrate,\n    femto.md.constants.OpenMMPlatform.CUDA,\n    reporter=None\n)\n</code></pre> <p>The results are returned as a list of OpenMM <code>State</code> objects.</p>"},{"location":"guide-septop/#hremd","title":"HREMD","text":"<p>The HREMD procedure is also reasonably flexible, and is almost fully specified by the configuration. By default, each step is propagated for 600 ps as a warmup phase. All statistics collected during the warmup are discarded.</p> <p>Following this, 10ns of replica exchange is performed with a timestep of 4 fs, with exchanges attempted every 4 ps.</p> ComplexSolution <pre><code>import femto.md.reporting\n\nreporter = femto.md.reporting.TensorboardReporter(output_dir)  # OR None\nconfig.sample.analysis_interval = 10\n\nfemto.fe.septop.run_hremd(\n    complex_system,\n    complex_topology,\n    coords,\n    config.complex.states,\n    config.complex.sample,\n    femto.md.constants.OpenMMPlatform.CUDA,\n    output_dir / \"complex\",\n    reporter\n)\n</code></pre> <pre><code>import femto.md.reporting\n\nreporter = femto.md.reporting.TensorboardReporter(output_dir)  # OR None\nconfig.sample.analysis_interval = 10\n\nfemto.fe.septop.run_hremd(\n    solution_system,\n    solution_topology,\n    coords,\n    config.solution.states,\n    config.solution.sample,\n    femto.md.constants.OpenMMPlatform.CUDA,\n    output_dir / \"solution\",\n    reporter\n)\n</code></pre> <p>We have passed an optional reporter to the <code>run_hremd</code> function. As the name suggests, this reporter will log statistics to a TensorBoard run file in the output directory. At present, these include online estimates of the total free energy and the free energy of each 'leg'.</p> <p>The statistics collected such as reduced potentials and acceptance rates are stored in a specified output directory as a convenient Arrow parquet file (<code>\"eralpha/outputs-septop/&lt;phase&gt;/samples.arrow\"</code>).</p>"},{"location":"guide-septop/#analysis","title":"Analysis","text":"<p>The final step is to compute the free energy using MBAR or UWHAM. This can be easily done using the femto.fe.septop.compute_ddg convience function:</p> <pre><code>import femto.fe.ddg\nimport femto.fe.septop\n\nu_kn_complex, n_k_complex = femto.fe.ddg.load_u_kn(\n    output_dir / \"complex/samples.arrow\"\n)\nu_kn_solution, n_k_solution = femto.fe.ddg.load_u_kn(\n    output_dir / \"solution/samples.arrow\"\n)\n\nddg_df = femto.fe.septop.compute_ddg(\n    config,\n    u_kn_complex,\n    n_k_complex,\n    complex_system,\n    u_kn_solution,\n    n_k_solution,\n    solution_system\n)\nprint(ddg_df)\n</code></pre>"},{"location":"guide-septop/#edges","title":"Edges","text":"<p>The SepTop CLI provides an option to specify a YAML file containing edge data. At present, this file can only be used to specify the edges that need to be computed:</p> <pre><code>edges:\n  - {ligand_1: 2d, ligand_2: 2e}\n  - {ligand_1: 2d, ligand_2: 3a}\n  - ...\n</code></pre> <p>where each name should match the name of a subdirectory in your <code>forcefield</code> directory.</p>"},{"location":"migration/","title":"Migration Guide","text":"<p>This document outlines the major API and behaviour changes made to the <code>femto</code> codebase between versions, and provides guidance on how to update your code to the latest version.</p>"},{"location":"migration/#from-pre-030-to-030","title":"From <code>pre 0.3.0</code> to <code>0.3.0</code>","text":"<p>The <code>femto</code> codebase was re-written to completely remove the dependency on <code>parmed</code>, allowing easy use of any force field in OpenFF, Amber, and OpenMM FFXML formats. This re-write also introduced a number of neccessary API changes.</p>"},{"location":"migration/#behaviour-changes","title":"Behaviour Changes","text":""},{"location":"migration/#md","title":"MD","text":"<ul> <li>Atom selection should now be performed using the <code>PyMol</code> atom selection language. This is more powerful and flexible     than the previous <code>Amber</code> atom selection language, but may require some changes to your configuration files. Amber     atom selection is currently still supported, but will be removed in a future version.</li> <li>Parameterization is now performed by     <code>openmmforcefields</code> rather than a combination of     <code>parmed</code> and <code>tleap</code>. This allows for more flexibility in the force fields that can be used, and should give near     identical parameters to those from <code>tleap</code>.</li> <li>Ligand force field parameters no longer need to be provided. The femto.md.config.Prepare configuration now     exposes a <code>default_ligand_ff</code> field that can be used to automatically parameterize ligands with an OpenFF based     force field.</li> <li>HREMD now correctly stores coordinates as <code>coords[i] = replica_i_coords</code> rather than <code>coords[i] = state_i_coords</code>.     Checkpoints from previous versions will likely be incorrect.</li> </ul>"},{"location":"migration/#fe","title":"FE","text":"<ul> <li>The force constant of P1\u2212L1\u2212L2 angle in SepTop Boresch-style restraints is now also scaled based on the P1-L1 distance by     default to improve stability.</li> <li>The solution phase of SepTop calculations now has a properly padded box when two ligands are present.</li> <li>Support has been added for co-factors, and force fields with virtual sites.</li> </ul>"},{"location":"migration/#api-changes","title":"API Changes","text":"<ul> <li>parmed.Structure is no longer used to store topological information. Instead, mdtop.Topology is     used. See the mdtop documentation for more information.</li> <li><code>femto.md.config.Solvent</code> has been renamed to femto.md.config.Prepare to better reflect that it is used to     more generally configure the system for simulation, not just solvation.</li> <li>The <code>tleap_sources</code> field of the old <code>femto.md.config.Solvent</code> configuration has been replaced by     femto.md.config.Prepare.default_protein_ff, which now stores the paths to OpenMM force field XML files. See     <code>openmmforcefields</code>     for details.</li> <li>A new <code>default_ligand_ff</code> field has been added to femto.md.config.Prepare. This will accept the name / path     to an OpenFF force field (e.g. <code>'openff-2.0.0.offxml'</code>) to use to automatically parameterize ligands.</li> <li>The <code>femto.md.solvate</code> and <code>femto.md.system</code> modules have been combined into a single <code>femto.md.prepare</code> module.</li> <li>The <code>femto.md.solvate.solvate_system</code> function has been replaced by the femto.md.prepare.prepare_system     function. The syntax is similar, but now also accepts cofactors, and an optional list of force field files to use     for the receptor, ligand, cofactors, and solvent / ions.</li> </ul>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#femto","title":"femto","text":"<p>A comprehensive toolkit for predicting free energies</p> <p>Modules:</p> <ul> <li> <code>fe</code>           \u2013            <p>Compute free energies using OpenMM.</p> </li> <li> <code>md</code>           \u2013            <p>Run MD simulations using OpenMM.</p> </li> </ul>"},{"location":"reference/#femto.__FilterSimTKDeprecation","title":"__FilterSimTKDeprecation","text":"<p>               Bases: <code>Filter</code></p> <p>Disable the deprecation warning from SimTK triggered by ParmEd which spams any CLI output / logs.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> femto<ul> <li> fe<ul> <li> atm</li> <li> config</li> <li> corrections</li> <li> ddg</li> <li> fep</li> <li> inputs</li> <li> reference</li> <li> septop</li> <li> utils<ul> <li> cli</li> <li> queue</li> </ul> </li> <li> uwham</li> </ul> </li> <li> md<ul> <li> anneal</li> <li> config</li> <li> constants</li> <li> hremd</li> <li> prepare</li> <li> reporting<ul> <li> openmm</li> </ul> </li> <li> rest</li> <li> restraints</li> <li> simulate</li> <li> utils<ul> <li> amber</li> <li> geometry</li> <li> logging</li> <li> models</li> <li> mpi</li> <li> openmm</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/fe/","title":"Index","text":""},{"location":"reference/fe/#femto.fe","title":"fe","text":"<p>Compute free energies using OpenMM.</p> <p>Modules:</p> <ul> <li> <code>atm</code>           \u2013            <p>Automated BFE calculations using the alchemical transfer method</p> </li> <li> <code>config</code>           \u2013            <p>Common configuration models.</p> </li> <li> <code>corrections</code>           \u2013            <p>Compute analytical corrections to free energies.</p> </li> <li> <code>ddg</code>           \u2013            <p>Estimate ddG values from sampled data.</p> </li> <li> <code>fep</code>           \u2013            <p>Modify OpenMM systems to depend on FEP lambdas.</p> </li> <li> <code>inputs</code>           \u2013            <p>Helpers for loading inputs from a standard directory structure.</p> </li> <li> <code>reference</code>           \u2013            <p>Utilities for automatically selecting 'reference' atoms for alignment.</p> </li> <li> <code>septop</code>           \u2013            <p>Automated BFE calculations using the seperated topology method</p> </li> <li> <code>tests</code>           \u2013            </li> <li> <code>utils</code>           \u2013            <p>Common utilities.</p> </li> <li> <code>uwham</code>           \u2013            <p>Estimate free energies using the UWHAM method [1]</p> </li> </ul>"},{"location":"reference/fe/config/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> config","text":""},{"location":"reference/fe/config/#femto.fe.config","title":"config","text":"<p>Common configuration models.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>FEP</code>           \u2013            <p>Configure modifying a system to be scalable by FEP lambdas.</p> </li> <li> <code>Edge</code>           \u2013            <p>Defines a basic edge in a free energy network.</p> </li> <li> <code>Network</code>           \u2013            <p>Defines a basic free energy network.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_INITIAL_TEMPERATURE</code>           \u2013            <p>The default temperature to begin annealing from during equilibration</p> </li> <li> <code>LigandReferenceMethod</code>           \u2013            <p>The method to use when automatically selecting ligand atoms to use in alignment</p> </li> </ul>"},{"location":"reference/fe/config/#femto.fe.config.DEFAULT_INITIAL_TEMPERATURE","title":"DEFAULT_INITIAL_TEMPERATURE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_INITIAL_TEMPERATURE = 50.0 * kelvin\n</code></pre> <p>The default temperature to begin annealing from during equilibration</p>"},{"location":"reference/fe/config/#femto.fe.config.LigandReferenceMethod","title":"LigandReferenceMethod  <code>module-attribute</code>","text":"<pre><code>LigandReferenceMethod = Literal['chen', 'baumann']\n</code></pre> <p>The method to use when automatically selecting ligand atoms to use in alignment restraints.</p>"},{"location":"reference/fe/config/#femto.fe.config.FEP","title":"FEP  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure modifying a system to be scalable by FEP lambdas.</p> <p>Fields:</p> <ul> <li> <code>scale_vdw</code>                 (<code>bool</code>)             </li> <li> <code>scale_charges</code>                 (<code>bool</code>)             </li> <li> <code>ligands_can_interact</code>                 (<code>bool</code>)             </li> </ul>"},{"location":"reference/fe/config/#femto.fe.config.FEP.scale_vdw","title":"scale_vdw  <code>pydantic-field</code>","text":"<pre><code>scale_vdw: bool = True\n</code></pre> <p>Whether to scale the vdW non-bonded interactions.</p>"},{"location":"reference/fe/config/#femto.fe.config.FEP.scale_charges","title":"scale_charges  <code>pydantic-field</code>","text":"<pre><code>scale_charges: bool = True\n</code></pre> <p>Whether to scale the electrostatic non-bonded interactions.</p>"},{"location":"reference/fe/config/#femto.fe.config.FEP.ligands_can_interact","title":"ligands_can_interact  <code>pydantic-field</code>","text":"<pre><code>ligands_can_interact: bool = False\n</code></pre> <p>Whether ligands are allowed to interact with each other.</p>"},{"location":"reference/fe/config/#femto.fe.config.FEP.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/config/#femto.fe.config.Edge","title":"Edge  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a basic edge in a free energy network.</p> <p>Fields:</p> <ul> <li> <code>ligand_1</code>                 (<code>str</code>)             </li> <li> <code>ligand_2</code>                 (<code>str | None</code>)             </li> <li> <code>ligand_1_metadata</code>                 (<code>dict[str, Any]</code>)             </li> <li> <code>ligand_2_metadata</code>                 (<code>dict[str, Any]</code>)             </li> </ul>"},{"location":"reference/fe/config/#femto.fe.config.Edge.ligand_1","title":"ligand_1  <code>pydantic-field</code>","text":"<pre><code>ligand_1: str\n</code></pre> <p>The name of the first ligand.</p>"},{"location":"reference/fe/config/#femto.fe.config.Edge.ligand_2","title":"ligand_2  <code>pydantic-field</code>","text":"<pre><code>ligand_2: str | None\n</code></pre> <p>The name of the second ligand. This should be <code>None</code> if running an ABFE calculation.</p>"},{"location":"reference/fe/config/#femto.fe.config.Edge.ligand_1_metadata","title":"ligand_1_metadata  <code>pydantic-field</code>","text":"<pre><code>ligand_1_metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata about ligand 1.</p>"},{"location":"reference/fe/config/#femto.fe.config.Edge.ligand_2_metadata","title":"ligand_2_metadata  <code>pydantic-field</code>","text":"<pre><code>ligand_2_metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata about ligand 2.</p>"},{"location":"reference/fe/config/#femto.fe.config.Edge.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/config/#femto.fe.config.Network","title":"Network  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines a basic free energy network.</p> <p>Fields:</p> <ul> <li> <code>receptor</code>                 (<code>str | None</code>)             </li> <li> <code>edges</code>                 (<code>list[Edge]</code>)             </li> <li> <code>receptor_metadata</code>                 (<code>dict[str, Any]</code>)             </li> </ul>"},{"location":"reference/fe/config/#femto.fe.config.Network.receptor","title":"receptor  <code>pydantic-field</code>","text":"<pre><code>receptor: str | None = None\n</code></pre> <p>The name of the receptor. If <code>None</code>, the receptor will be identified from the input directory structure</p>"},{"location":"reference/fe/config/#femto.fe.config.Network.edges","title":"edges  <code>pydantic-field</code>","text":"<pre><code>edges: list[Edge]\n</code></pre> <p>The edges in the free energy network.</p>"},{"location":"reference/fe/config/#femto.fe.config.Network.receptor_metadata","title":"receptor_metadata  <code>pydantic-field</code>","text":"<pre><code>receptor_metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata about the receptor.</p>"},{"location":"reference/fe/config/#femto.fe.config.Network.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/corrections/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> corrections","text":""},{"location":"reference/fe/corrections/#femto.fe.corrections","title":"corrections","text":"<p>Compute analytical corrections to free energies.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>analytical_correction_boresch</code>             \u2013              <p>Compute the analytical correction to the free energy due to disabling a</p> </li> </ul>"},{"location":"reference/fe/corrections/#femto.fe.corrections.analytical_correction_boresch","title":"analytical_correction_boresch","text":"<pre><code>analytical_correction_boresch(\n    dist_0: Quantity,\n    theta_a_0: Quantity,\n    theta_b_0: Quantity,\n    restraint: BoreschRestraint,\n    temperature: Quantity,\n) -&gt; Quantity\n</code></pre> <p>Compute the analytical correction to the free energy due to disabling a Boresch-style restraint as described by Eq. 32 in [1].</p> References <p>[1] Boresch, Stefan, et al. \"Absolute binding free energies: a quantitative approach for their calculation.\" The Journal of Physical Chemistry B 107.35 (2003): 9535-9551.</p> <p>Parameters:</p> <ul> <li> <code>dist_0</code>               (<code>Quantity</code>)           \u2013            <p>The equilibrium distance between r3 and l1.</p> </li> <li> <code>theta_a_0</code>               (<code>Quantity</code>)           \u2013            <p>The equilibrium angle between r2, r3, and l1.</p> </li> <li> <code>theta_b_0</code>               (<code>Quantity</code>)           \u2013            <p>The equilibrium angle between r3, l1, and l2.</p> </li> <li> <code>restraint</code>               (<code>BoreschRestraint</code>)           \u2013            <p>The Boresch restraint parameters.</p> </li> <li> <code>temperature</code>               (<code>Quantity</code>)           \u2013            <p>The temperature of the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Quantity</code>           \u2013            <p>The analytical correction.</p> </li> </ul> Source code in <code>femto/fe/corrections.py</code> <pre><code>def analytical_correction_boresch(\n    dist_0: openmm.unit.Quantity,\n    theta_a_0: openmm.unit.Quantity,\n    theta_b_0: openmm.unit.Quantity,\n    restraint: femto.md.config.BoreschRestraint,\n    temperature: openmm.unit.Quantity,\n) -&gt; openmm.unit.Quantity:\n    \"\"\"Compute the analytical correction to the free energy due to disabling a\n    Boresch-style restraint as described by Eq. 32 in [1].\n\n    References:\n        [1] Boresch, Stefan, et al. \"Absolute binding free energies: a quantitative\n        approach for their calculation.\" The Journal of Physical Chemistry B 107.35\n        (2003): 9535-9551.\n\n    Args:\n        dist_0: The equilibrium distance between r3 and l1.\n        theta_a_0: The equilibrium angle between r2, r3, and l1.\n        theta_b_0: The equilibrium angle between r3, l1, and l2.\n        restraint: The Boresch restraint parameters.\n        temperature: The temperature of the system.\n\n    Returns:\n        The analytical correction.\n    \"\"\"\n\n    sin_theta_a_0 = numpy.sin(theta_a_0.value_in_unit(openmm.unit.radian))\n    sin_theta_b_0 = numpy.sin(theta_b_0.value_in_unit(openmm.unit.radian))\n\n    k_dist = restraint.k_distance\n\n    k_theta_a = restraint.k_angle_a\n    k_theta_b = restraint.k_angle_b\n\n    k_phi_a = restraint.k_dihedral_a\n    k_phi_b = restraint.k_dihedral_b\n    k_phi_c = restraint.k_dihedral_c\n\n    volume_0 = 1660.0 * openmm.unit.angstrom**3  # taken from [1].\n\n    kt = openmm.unit.MOLAR_GAS_CONSTANT_R * temperature\n\n    correction = -kt * numpy.log(\n        ((8.0 * numpy.pi**2 * volume_0) / (dist_0**2 * sin_theta_a_0 * sin_theta_b_0))\n        * (\n            numpy.sqrt(k_dist * k_theta_a * k_theta_b * k_phi_a * k_phi_b * k_phi_c)\n            / (2.0 * numpy.pi * kt) ** 3\n        )\n    )\n\n    return correction\n</code></pre>"},{"location":"reference/fe/ddg/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> ddg","text":""},{"location":"reference/fe/ddg/#femto.fe.ddg","title":"ddg","text":"<p>Estimate ddG values from sampled data.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>load_u_kn</code>             \u2013              <p>Loads the reduced potentials from a replica exchange sampler output file and</p> </li> <li> <code>estimate_ddg</code>             \u2013              <p>Estimate the free energy change for each group of states as well as the total</p> </li> </ul>"},{"location":"reference/fe/ddg/#femto.fe.ddg.load_u_kn","title":"load_u_kn","text":"<pre><code>load_u_kn(results_path: Path) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Loads the reduced potentials from a replica exchange sampler output file and re-orders / de-correlates them into a form acceptable by MBAR.</p> Note <p>Samples will be de-correlated using the <code>pymbar.timeseries</code> module.</p> <p>Parameters:</p> <ul> <li> <code>results_path</code>               (<code>Path</code>)           \u2013            <p>The path to the arrow replica exchange output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>The loaded <code>u_kn</code> and <code>n_k</code> arrays.</p> </li> </ul> Source code in <code>femto/fe/ddg.py</code> <pre><code>def load_u_kn(results_path: pathlib.Path) -&gt; tuple[numpy.ndarray, numpy.ndarray]:\n    \"\"\"Loads the reduced potentials from a replica exchange sampler output file and\n    re-orders / de-correlates them into a form acceptable by MBAR.\n\n    Note:\n        Samples will be de-correlated using the ``pymbar.timeseries`` module.\n\n    Args:\n        results_path: The path to the arrow replica exchange output file.\n\n    Returns:\n        The loaded ``u_kn`` and ``n_k`` arrays.\n    \"\"\"\n    import pymbar.timeseries\n\n    with pyarrow.OSFile(str(results_path), \"rb\") as file:\n        with pyarrow.RecordBatchStreamReader(file) as reader:\n            output_table = reader.read_all()\n\n    replica_to_state_idx = numpy.hstack(\n        [numpy.array(x) for x in output_table[\"replica_to_state_idx\"].to_pylist()]\n    )\n\n    # group the data along axis 1 so that data sampled in the same state is grouped.\n    # this will let us more easily de-correlate the data.\n    u_kn = numpy.hstack([numpy.array(x) for x in output_table[\"u_kn\"].to_pylist()])\n    u_kn_per_k = [u_kn[:, replica_to_state_idx == i] for i in range(len(u_kn))]\n\n    n_uncorrelated = u_kn.shape[1] // u_kn.shape[0]\n\n    g = pymbar.timeseries.statistical_inefficiency_multiple(\n        [\n            u_kn_per_k[i][i, i * n_uncorrelated : (i + 1) * n_uncorrelated]\n            for i in range(len(u_kn))\n        ]\n    )\n    uncorrelated_frames = _uncorrelated_frames(n_uncorrelated, g)\n\n    for state_idx, state_u_kn in enumerate(u_kn_per_k):\n        u_kn_per_k[state_idx] = state_u_kn[:, uncorrelated_frames]\n\n    u_kn = numpy.hstack(u_kn_per_k)\n    n_k = numpy.array([len(uncorrelated_frames)] * u_kn.shape[0])\n\n    return u_kn, n_k\n</code></pre>"},{"location":"reference/fe/ddg/#femto.fe.ddg.estimate_ddg","title":"estimate_ddg","text":"<pre><code>estimate_ddg(\n    u_kn: ndarray,\n    n_k: ndarray,\n    temperature: Quantity,\n    state_groups: list[tuple[int, float]] | None = None,\n) -&gt; tuple[dict[str, float], dict[str, ndarray]]\n</code></pre> <p>Estimate the free energy change for each group of states as well as the total free energy change.</p> <p>Parameters:</p> <ul> <li> <code>u_kn</code>               (<code>ndarray</code>)           \u2013            <p>The reduced potentials.</p> </li> <li> <code>n_k</code>               (<code>ndarray</code>)           \u2013            <p>The number of samples per state.</p> </li> <li> <code>temperature</code>               (<code>Quantity</code>)           \u2013            <p>The temperature at which the samples were collected.</p> </li> <li> <code>state_groups</code>               (<code>list[tuple[int, float]] | None</code>, default:                   <code>None</code> )           \u2013            <p>If certain states should be grouped together (e.g. leg 1 and leg 2 in ATM), this should be a list of tuples containing the number of states belonging to each group as well as the multiplier to use when summing the total free energy.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[dict[str, float], dict[str, ndarray]]</code>           \u2013            <p>The free energy estimates and the overlap matrices.</p> </li> </ul> Source code in <code>femto/fe/ddg.py</code> <pre><code>def estimate_ddg(\n    u_kn: numpy.ndarray,\n    n_k: numpy.ndarray,\n    temperature: openmm.unit.Quantity,\n    state_groups: list[tuple[int, float]] | None = None,\n) -&gt; tuple[dict[str, float], dict[str, numpy.ndarray]]:\n    \"\"\"Estimate the free energy change for each group of states as well as the total\n    free energy change.\n\n    Args:\n        u_kn: The reduced potentials.\n        n_k: The number of samples per state.\n        temperature: The temperature at which the samples were collected.\n        state_groups: If certain states should be grouped together (e.g. leg 1 and\n            leg 2 in ATM), this should be a list of tuples containing the number of\n            states belonging to each group as well as the multiplier to use when\n            summing the total free energy.\n\n    Returns:\n        The free energy estimates and the overlap matrices.\n    \"\"\"\n    beta = 1.0 / (openmm.unit.MOLAR_GAS_CONSTANT_R * temperature)\n\n    state_idx = 0\n    sample_idx = 0\n\n    total_ddg = 0.0\n    total_ddg_error = 0.0\n\n    estimates = {}\n    overlaps = {}\n\n    state_groups = state_groups if state_groups is not None else [(len(n_k), 1.0)]\n\n    for group_idx, (n_states, factor) in enumerate(state_groups):\n        group_n_k = n_k[state_idx : state_idx + n_states]\n        group_u_kn = u_kn[\n            state_idx : state_idx + n_states, sample_idx : sample_idx + group_n_k.sum()\n        ]\n\n        f_i, f_i_variance, weights = _estimate_f_i(group_u_kn, group_n_k)\n        overlaps[f\"overlap_{group_idx}\"] = group_n_k * (weights.T @ weights)\n\n        ddg = (f_i[-1] - f_i[0]) / beta\n        ddg = float(ddg.value_in_unit(openmm.unit.kilocalorie_per_mole))\n\n        ddg_error = numpy.sqrt(f_i_variance[-1] + f_i_variance[0]) / beta\n        ddg_error = float(ddg_error.value_in_unit(openmm.unit.kilocalorie_per_mole))\n\n        total_ddg += factor * ddg\n        total_ddg_error += ddg_error**2\n\n        state_idx += n_states\n        sample_idx += group_n_k.sum()\n\n        estimates[f\"ddG_{group_idx}_kcal_mol\"] = ddg\n        estimates[f\"ddG_{group_idx}_error_kcal_mol\"] = ddg_error\n\n    total_ddg_error = numpy.sqrt(total_ddg_error)\n\n    estimates[\"ddG_kcal_mol\"] = total_ddg\n    estimates[\"ddG_error_kcal_mol\"] = total_ddg_error\n\n    return estimates, overlaps\n</code></pre>"},{"location":"reference/fe/fep/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> fep","text":""},{"location":"reference/fe/fep/#femto.fe.fep","title":"fep","text":"<p>Modify OpenMM systems to depend on FEP lambdas.</p> Notes <p>Currently the implementation here is very simple and only assumes morphing full ligands to ideal states. This is sufficient for the current use case of implementing separated topology calculations, but may be expanded in future if full relative FEP calculations are to be supported.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>apply_fep</code>             \u2013              <p>Modifies an OpenMM system so that different interactions can be scaled by</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>LAMBDA_VDW_LIGAND_1</code>           \u2013            <p>The global parameter used to scale the vdW interactions of ligand 1.</p> </li> <li> <code>LAMBDA_VDW_LIGAND_2</code>           \u2013            <p>The global parameter used to scale the vdW interactions of ligand 2.</p> </li> <li> <code>LAMBDA_CHARGES_LIGAND_1</code>           \u2013            <p>The global parameter used to scale the electrostatic interactions of</p> </li> <li> <code>LAMBDA_CHARGES_LIGAND_2</code>           \u2013            <p>The global parameter used to scale the electrostatic interactions of</p> </li> </ul>"},{"location":"reference/fe/fep/#femto.fe.fep.LAMBDA_VDW_LIGAND_1","title":"LAMBDA_VDW_LIGAND_1  <code>module-attribute</code>","text":"<pre><code>LAMBDA_VDW_LIGAND_1 = 'lambda_vdw_lig_1'\n</code></pre> <p>The global parameter used to scale the vdW interactions of ligand 1.</p>"},{"location":"reference/fe/fep/#femto.fe.fep.LAMBDA_VDW_LIGAND_2","title":"LAMBDA_VDW_LIGAND_2  <code>module-attribute</code>","text":"<pre><code>LAMBDA_VDW_LIGAND_2 = 'lambda_vdw_lig_2'\n</code></pre> <p>The global parameter used to scale the vdW interactions of ligand 2.</p>"},{"location":"reference/fe/fep/#femto.fe.fep.LAMBDA_CHARGES_LIGAND_1","title":"LAMBDA_CHARGES_LIGAND_1  <code>module-attribute</code>","text":"<pre><code>LAMBDA_CHARGES_LIGAND_1 = 'lambda_charges_lig_1'\n</code></pre> <p>The global parameter used to scale the electrostatic interactions of ligand 1.</p>"},{"location":"reference/fe/fep/#femto.fe.fep.LAMBDA_CHARGES_LIGAND_2","title":"LAMBDA_CHARGES_LIGAND_2  <code>module-attribute</code>","text":"<pre><code>LAMBDA_CHARGES_LIGAND_2 = 'lambda_charges_lig_2'\n</code></pre> <p>The global parameter used to scale the electrostatic interactions of ligand 2.</p>"},{"location":"reference/fe/fep/#femto.fe.fep.apply_fep","title":"apply_fep","text":"<pre><code>apply_fep(\n    system: System,\n    ligand_1_idxs: set[int],\n    ligand_2_idxs: set[int] | None,\n    config: FEP,\n)\n</code></pre> <p>Modifies an OpenMM system so that different interactions can be scaled by corresponding lambda parameters.</p> Notes <ul> <li>All intra-molecular interactions of alchemical ligands are currently replaced   with exceptions and are not scaled by lambda parameters. This will lead to   slightly different energies from the original system as cutoffs are not   applied to them by OpenMM.</li> <li>LJ vdW interactions between ligands and the rest of the system will be   replaced with a Beutler-style soft-core LJ potential with a-b-c of 1-1-6 and   alpha=0.5.</li> <li>Ligand indices must correspond to all atoms in the ligand,   alchemically modifying part of a molecule is not yet supported.</li> </ul> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to modify in-place.</p> </li> <li> <code>ligand_1_idxs</code>               (<code>set[int]</code>)           \u2013            <p>The indices of the ligand atoms whose interactions should be scaled by lambda.</p> </li> <li> <code>ligand_2_idxs</code>               (<code>set[int] | None</code>)           \u2013            <p>The indices of the ligand atoms whose interactions should be scaled by 1 - lambda.</p> </li> <li> <code>config</code>               (<code>FEP</code>)           \u2013            <p>Configuration options.</p> </li> </ul> Source code in <code>femto/fe/fep.py</code> <pre><code>def apply_fep(\n    system: openmm.System,\n    ligand_1_idxs: set[int],\n    ligand_2_idxs: set[int] | None,\n    config: femto.fe.config.FEP,\n):\n    \"\"\"Modifies an OpenMM system so that different interactions can be scaled by\n    corresponding lambda parameters.\n\n    Notes:\n        * All intra-molecular interactions of alchemical ligands are currently replaced\n          with exceptions and are not scaled by lambda parameters. This will lead to\n          slightly different energies from the original system as cutoffs are not\n          applied to them by OpenMM.\n        * LJ vdW interactions between ligands and the rest of the system will be\n          replaced with a Beutler-style soft-core LJ potential with a-b-c of 1-1-6 and\n          alpha=0.5.\n        * Ligand indices **must** correspond to **all** atoms in the ligand,\n          alchemically modifying part of a molecule is not yet supported.\n\n    Args:\n        system: The system to modify in-place.\n        ligand_1_idxs: The indices of the ligand atoms whose interactions should be\n            scaled by lambda.\n        ligand_2_idxs: The indices of the ligand atoms whose interactions should be\n            scaled by 1 - lambda.\n        config: Configuration options.\n    \"\"\"\n\n    forces_by_type = collections.defaultdict(list)\n\n    for force in system.getForces():\n        if type(force) not in _SUPPORTED_FORCES:\n            raise ValueError(\n                f\"Force type {type(force)} is not supported when alchemical modifying \"\n                f\"a system.\"\n            )\n        forces_by_type[type(force)].append(force)\n\n    updated_forces = []\n\n    for force_type, forces in forces_by_type.items():\n        if len(forces) != 1:\n            raise NotImplementedError(\"only one force of each type is supported.\")\n\n        force = forces[0]\n\n        if force_type == openmm.NonbondedForce:\n            nonbonded_forces = _apply_nonbonded_lambdas(\n                force, ligand_1_idxs, ligand_2_idxs, config\n            )\n            updated_forces.extend(nonbonded_forces)\n        else:\n            updated_forces.append(copy.deepcopy(force))\n\n    for i in reversed(range(system.getNumForces())):\n        system.removeForce(i)\n\n    for force in updated_forces:\n        if force is not None:\n            system.addForce(force)\n</code></pre>"},{"location":"reference/fe/inputs/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> inputs","text":""},{"location":"reference/fe/inputs/#femto.fe.inputs","title":"inputs","text":"<p>Helpers for loading inputs from a standard directory structure.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Structure</code>           \u2013            <p>A basic representation of a single structure (i.e. a ligand or a receptor).</p> </li> <li> <code>Edge</code>           \u2013            <p>A basic representation of an edge in a free energy network.</p> </li> <li> <code>Network</code>           \u2013            <p>A basic definition of a free energy network of edges.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>find_edges</code>             \u2013              <p>Attempts to find the input files for a network free energy 'edges' in the</p> </li> </ul>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Structure","title":"Structure","text":"<p>A basic representation of a single structure (i.e. a ligand or a receptor).</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the structure.</p> </li> <li> <code>coords</code>               (<code>Path</code>)           \u2013            <p>The path to the associated coordinate file (.rst7, .mol2, .pdb).</p> </li> <li> <code>params</code>               (<code>Path | None</code>)           \u2013            <p>The path to the associated parameter file (.parm7).</p> </li> <li> <code>metadata</code>               (<code>dict[str, Any]</code>)           \u2013            <p>Any additional metadata associated with the structure.</p> </li> </ul>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Structure.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the structure.</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Structure.coords","title":"coords  <code>instance-attribute</code>","text":"<pre><code>coords: Path\n</code></pre> <p>The path to the associated coordinate file (.rst7, .mol2, .pdb).</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Structure.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: Path | None\n</code></pre> <p>The path to the associated parameter file (.parm7).</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Structure.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata associated with the structure.</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Edge","title":"Edge","text":"<p>A basic representation of an edge in a free energy network.</p> <p>Attributes:</p> <ul> <li> <code>ligand_1</code>               (<code>Structure</code>)           \u2013            <p>The first ligand.</p> </li> <li> <code>ligand_2</code>               (<code>Structure | None</code>)           \u2013            <p>The second ligand if computing a RBFE.</p> </li> </ul>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Edge.ligand_1","title":"ligand_1  <code>instance-attribute</code>","text":"<pre><code>ligand_1: Structure\n</code></pre> <p>The first ligand.</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Edge.ligand_2","title":"ligand_2  <code>instance-attribute</code>","text":"<pre><code>ligand_2: Structure | None\n</code></pre> <p>The second ligand if computing a RBFE.</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Network","title":"Network","text":"<p>A basic definition of a free energy network of edges.</p> <p>Methods:</p> <ul> <li> <code>find_edge</code>             \u2013              <p>Find an edge in the network.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>receptor</code>               (<code>Structure</code>)           \u2013            <p>The receptor.</p> </li> <li> <code>edges</code>               (<code>list[Edge]</code>)           \u2013            <p>The edges in the network.</p> </li> </ul>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Network.receptor","title":"receptor  <code>instance-attribute</code>","text":"<pre><code>receptor: Structure\n</code></pre> <p>The receptor.</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Network.edges","title":"edges  <code>instance-attribute</code>","text":"<pre><code>edges: list[Edge]\n</code></pre> <p>The edges in the network.</p>"},{"location":"reference/fe/inputs/#femto.fe.inputs.Network.find_edge","title":"find_edge","text":"<pre><code>find_edge(\n    ligand_1: str, ligand_2: str | None = None\n) -&gt; Edge\n</code></pre> <p>Find an edge in the network.</p> <p>Parameters:</p> <ul> <li> <code>ligand_1</code>               (<code>str</code>)           \u2013            <p>The name of the first ligand.</p> </li> <li> <code>ligand_2</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the second ligand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Edge</code>           \u2013            <p>The edge.</p> </li> </ul> Source code in <code>femto/fe/inputs.py</code> <pre><code>def find_edge(self, ligand_1: str, ligand_2: str | None = None) -&gt; Edge:\n    \"\"\"Find an edge in the network.\n\n    Args:\n        ligand_1: The name of the first ligand.\n        ligand_2: The name of the second ligand.\n\n    Returns:\n        The edge.\n    \"\"\"\n\n    edges = [edge for edge in self.edges if edge.ligand_1.name == ligand_1]\n\n    filter_fn = (\n        (lambda e: e.ligand_2 is not None and e.ligand_2.name == ligand_2)\n        if ligand_2 is not None\n        else (lambda e: e.ligand_2 is None)\n    )\n    edges = [edge for edge in edges if filter_fn(edge)]\n\n    if len(edges) == 0:\n        raise RuntimeError(f\"Could not find {ligand_1}~{ligand_2}\")\n\n    assert len(edges) == 1, f\"found multiple edges for {ligand_1}~{ligand_2}\"\n    return edges[0]\n</code></pre>"},{"location":"reference/fe/inputs/#femto.fe.inputs.find_edges","title":"find_edges","text":"<pre><code>find_edges(\n    root_dir: Path,\n    config_cls: type[Network] = Network,\n    config_path: Path | None = None,\n) -&gt; Network\n</code></pre> <p>Attempts to find the input files for a network free energy 'edges' in the standard directory structure.</p> <p>Parameters:</p> <ul> <li> <code>root_dir</code>               (<code>Path</code>)           \u2013            <p>The root of the directory structure.</p> </li> <li> <code>config_cls</code>               (<code>type[Network]</code>, default:                   <code>Network</code> )           \u2013            <p>The class to use to parse the <code>'edges.yaml'</code> file if present.</p> </li> <li> <code>config_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the file defining the edges to run.</p> </li> </ul> Source code in <code>femto/fe/inputs.py</code> <pre><code>def find_edges(\n    root_dir: pathlib.Path,\n    config_cls: type[femto.fe.config.Network] = femto.fe.config.Network,\n    config_path: pathlib.Path | None = None,\n) -&gt; Network:\n    \"\"\"Attempts to find the input files for a network free energy 'edges' in the\n    standard directory structure.\n\n    Args:\n        root_dir: The root of the directory structure.\n        config_cls: The class to use to parse the ``'edges.yaml'`` file if present.\n        config_path: The path to the file defining the edges to run.\n    \"\"\"\n\n    config = (\n        _find_config(root_dir, config_cls)\n        if config_path is None\n        else config_cls(**yaml.safe_load(config_path.read_text()))\n    )\n\n    receptor = _find_receptor(root_dir, config.receptor, config.receptor_metadata)\n    edges = [_find_edge(root_dir, edge) for edge in config.edges]\n\n    return Network(receptor, edges)\n</code></pre>"},{"location":"reference/fe/reference/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> reference","text":""},{"location":"reference/fe/reference/#femto.fe.reference","title":"reference","text":"<p>Utilities for automatically selecting 'reference' atoms for alignment.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>queries_to_idxs</code>             \u2013              <p>Find the indices of those atoms matched by a set of atom queries.</p> </li> <li> <code>select_ligand_idxs</code>             \u2013              <p>Returns the indices of the reference atoms that may be used to align ligands.</p> </li> <li> <code>select_receptor_idxs</code>             \u2013              <p>Select possible protein atoms for Boresch-style restraints using the method</p> </li> <li> <code>check_receptor_idxs</code>             \u2013              <p>Check if the specified receptor atoms meet the criteria for use in Boresch-style</p> </li> <li> <code>select_protein_cavity_atoms</code>             \u2013              <p>Select the alpha carbon atoms that define the binding cavity of the protein based</p> </li> </ul>"},{"location":"reference/fe/reference/#femto.fe.reference.queries_to_idxs","title":"queries_to_idxs","text":"<pre><code>queries_to_idxs(\n    topology: Topology, queries: Iterable[str]\n) -&gt; tuple[int, ...]\n</code></pre> <p>Find the indices of those atoms matched by a set of atom queries.</p> <p>Parameters:</p> <ul> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The ligand to query.</p> </li> <li> <code>queries</code>               (<code>Iterable[str]</code>)           \u2013            <p>The atom selection queries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>The indices of the matched atoms.</p> </li> </ul> Source code in <code>femto/fe/reference.py</code> <pre><code>def queries_to_idxs(\n    topology: mdtop.Topology, queries: typing.Iterable[str]\n) -&gt; tuple[int, ...]:\n    \"\"\"Find the indices of those atoms matched by a set of atom queries.\n\n    Args:\n        topology: The ligand to query.\n        queries: The atom selection queries.\n\n    Returns:\n        The indices of the matched atoms.\n    \"\"\"\n    ref_idxs = []\n\n    for query in queries:\n        mask_idxs = topology.select(query)\n\n        if len(mask_idxs) != 1:\n            raise ValueError(\n                f\"{query} matched {len(mask_idxs)} atoms. exactly 1 atom was expected.\"\n            )\n\n        ref_idxs.extend(mask_idxs)\n\n    return tuple(ref_idxs)\n</code></pre>"},{"location":"reference/fe/reference/#femto.fe.reference.select_ligand_idxs","title":"select_ligand_idxs","text":"<pre><code>select_ligand_idxs(\n    ligand_1: Topology,\n    ligand_2: Topology | None,\n    method: LigandReferenceMethod,\n    ligand_1_queries: tuple[str, str, str] | None = None,\n    ligand_2_queries: tuple[str, str, str] | None = None,\n) -&gt; tuple[\n    tuple[int, int, int], tuple[int, int, int] | None\n]\n</code></pre> <p>Returns the indices of the reference atoms that may be used to align ligands.</p> Notes <ul> <li>Some methods, e.g. <code>chen</code>, select reference atoms based on the two ligands   meaning they can only be used in RBFE calculations, whereas others, e.g.   <code>baumann</code>, select reference atoms based on a single ligand.</li> </ul> <p>Parameters:</p> <ul> <li> <code>ligand_1</code>               (<code>Topology</code>)           \u2013            <p>The first ligand.</p> </li> <li> <code>ligand_2</code>               (<code>Topology | None</code>)           \u2013            <p>The second ligand.</p> </li> <li> <code>method</code>               (<code>LigandReferenceMethod</code>)           \u2013            <p>The method to use to select the reference atoms if none are specified.</p> </li> <li> <code>ligand_1_queries</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Three (optional) selection queries to use to manually select atoms from the first ligand.</p> </li> <li> <code>ligand_2_queries</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Three (optional) selection queries to use to manually select atoms from the second ligand</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[tuple[int, int, int], tuple[int, int, int] | None]</code>           \u2013            <p>The indices of the first and second ligand respectively. No offset is applied to the second ligand indices so a query of <code>\"idx. 1\"</code> would yield <code>0</code> rather than <code>n_ligand_1_atoms</code>.</p> </li> </ul> Source code in <code>femto/fe/reference.py</code> <pre><code>def select_ligand_idxs(\n    ligand_1: mdtop.Topology,\n    ligand_2: mdtop.Topology | None,\n    method: femto.fe.config.LigandReferenceMethod,\n    ligand_1_queries: tuple[str, str, str] | None = None,\n    ligand_2_queries: tuple[str, str, str] | None = None,\n) -&gt; tuple[tuple[int, int, int], tuple[int, int, int] | None]:\n    \"\"\"Returns the indices of the reference atoms that may be used to align ligands.\n\n    Notes:\n        * Some methods, e.g. ``chen``, select reference atoms based on the two ligands\n          meaning they can only be used in RBFE calculations, whereas others, e.g.\n          ``baumann``, select reference atoms based on a single ligand.\n\n    Args:\n        ligand_1: The first ligand.\n        ligand_2: The second ligand.\n        method: The method to use to select the reference atoms if none are specified.\n        ligand_1_queries: Three (optional) selection queries to use to manually\n            select atoms from the first ligand.\n        ligand_2_queries: Three (optional) selection queries to use to manually\n            select atoms from the second ligand\n\n    Returns:\n        The indices of the first and second ligand respectively. No offset is applied\n        to the second ligand indices so a query of ``\"idx. 1\"`` would yield ``0``\n        rather than ``n_ligand_1_atoms``.\n    \"\"\"\n    if ligand_1_queries is None or (ligand_2 is not None and ligand_2_queries is None):\n        _LOGGER.info(\"selecting ligand reference atoms\")\n\n        ligand_queries = _create_ligand_queries(ligand_1, ligand_2, method)\n\n        if ligand_1_queries is None:\n            ligand_1_queries = ligand_queries[0]\n        if ligand_2_queries is None and ligand_2 is not None:\n            ligand_2_queries = ligand_queries[1]\n\n    _LOGGER.info(f\"ligand 1 ref queries={ligand_1_queries}\")\n    _LOGGER.info(f\"ligand 2 ref queries={ligand_2_queries}\")\n\n    ligand_1_idxs = queries_to_idxs(ligand_1, ligand_1_queries)\n\n    if ligand_2 is not None:\n        ligand_2_idxs = queries_to_idxs(ligand_2, ligand_2_queries)\n    else:\n        ligand_2_idxs = None\n\n    return ligand_1_idxs, ligand_2_idxs\n</code></pre>"},{"location":"reference/fe/reference/#femto.fe.reference.select_receptor_idxs","title":"select_receptor_idxs","text":"<pre><code>select_receptor_idxs(\n    topology: Topology | Trajectory,\n    ligand_ref_idxs: tuple[int, int, int],\n) -&gt; tuple[int, int, int]\n</code></pre> <p>Select possible protein atoms for Boresch-style restraints using the method outlined by Baumann et al [1].</p> References <p>[1] Baumann, Hannah M., et al. \"Broadening the scope of binding free energy     calculations using a Separated Topologies approach.\" (2023).</p> <p>Parameters:</p> <ul> <li> <code>topology</code>               (<code>Topology | Trajectory</code>)           \u2013            <p>The topology containing the receptor and ligands.</p> </li> <li> <code>ligand_ref_idxs</code>               (<code>tuple[int, int, int]</code>)           \u2013            <p>The indices of the three ligands atoms that will be restrained.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int, int]</code>           \u2013            <p>The indices of the three atoms to use for the restraint</p> </li> </ul> Source code in <code>femto/fe/reference.py</code> <pre><code>def select_receptor_idxs(\n    topology: mdtop.Topology | mdtraj.Trajectory,\n    ligand_ref_idxs: tuple[int, int, int],\n) -&gt; tuple[int, int, int]:\n    \"\"\"Select possible protein atoms for Boresch-style restraints using the method\n    outlined by Baumann et al [1].\n\n    References:\n        [1] Baumann, Hannah M., et al. \"Broadening the scope of binding free energy\n            calculations using a Separated Topologies approach.\" (2023).\n\n    Args:\n        topology: The topology containing the receptor and ligands.\n        ligand_ref_idxs: The indices of the three ligands atoms that will be restrained.\n\n    Returns:\n        The indices of the three atoms to use for the restraint\n    \"\"\"\n\n    if isinstance(topology, mdtop.Topology):\n        topology = _topology_to_mdtraj(topology)\n\n    receptor_idxs = _filter_receptor_atoms(topology, ligand_ref_idxs[0])\n\n    l1, l2, l3 = ligand_ref_idxs\n\n    valid_r1_idxs = [\n        r1 for r1 in receptor_idxs if _is_valid_r1(topology, r1, l1, l2, l3)\n    ]\n\n    found_r1, found_r2 = next(\n        (\n            (r1, r2)\n            for r1 in valid_r1_idxs\n            for r2 in receptor_idxs\n            if _is_valid_r2(topology, r1, r2, l1, l2)\n        ),\n        None,\n    )\n\n    if found_r1 is None or found_r2 is None:\n        raise ValueError(\"could not find valid R1 / R2 atoms\")\n\n    valid_r3_idxs = [\n        r3 for r3 in receptor_idxs if _is_valid_r3(topology, found_r1, found_r2, r3, l1)\n    ]\n\n    if len(valid_r3_idxs) == 0:\n        raise ValueError(\"could not find a valid R3 atom\")\n\n    r3_distances_per_frame = []\n\n    for frame in topology.xyz:\n        r3_r_distances = scipy.spatial.distance.cdist(\n            frame[valid_r3_idxs, :], frame[[found_r1, found_r2], :]\n        )\n        r3_l_distances = scipy.spatial.distance.cdist(\n            frame[valid_r3_idxs, :], frame[[ligand_ref_idxs[0]], :]\n        )\n\n        r3_distances_per_frame.append(numpy.hstack([r3_r_distances, r3_l_distances]))\n\n    # chosen to match the SepTop reference implementation at commit 3705ba5\n    max_distance = 0.8 * (topology.unitcell_lengths.mean(axis=0).min(axis=-1) / 2)\n\n    r3_distances_avg = numpy.stack(r3_distances_per_frame).mean(axis=0)\n\n    max_distance_mask = r3_distances_avg.max(axis=-1) &lt; max_distance\n    r3_distances_avg = r3_distances_avg[max_distance_mask]\n\n    valid_r3_idxs = numpy.array(valid_r3_idxs)[max_distance_mask].tolist()\n\n    r3_distances_prod = r3_distances_avg[:, 0] * r3_distances_avg[:, 1]\n    found_r3 = valid_r3_idxs[r3_distances_prod.argmax()]\n\n    return found_r1, found_r2, found_r3\n</code></pre>"},{"location":"reference/fe/reference/#femto.fe.reference.check_receptor_idxs","title":"check_receptor_idxs","text":"<pre><code>check_receptor_idxs(\n    topology: Topology | Trajectory,\n    receptor_idxs: tuple[int, int, int],\n    ligand_ref_idxs: tuple[int, int, int],\n) -&gt; bool\n</code></pre> <p>Check if the specified receptor atoms meet the criteria for use in Boresch-style restraints as defined by Baumann et al [1].</p> References <p>[1] Baumann, Hannah M., et al. \"Broadening the scope of binding free energy     calculations using a Separated Topologies approach.\" (2023).</p> <p>Parameters:</p> <ul> <li> <code>topology</code>               (<code>Topology | Trajectory</code>)           \u2013            <p>The system topology.</p> </li> <li> <code>receptor_idxs</code>               (<code>tuple[int, int, int]</code>)           \u2013            <p>The indices of the three receptor atoms that will be restrained.</p> </li> <li> <code>ligand_ref_idxs</code>               (<code>tuple[int, int, int]</code>)           \u2013            <p>The indices of the three ligand atoms that will be restrained.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the atoms meet the criteria, False otherwise.</p> </li> </ul> Source code in <code>femto/fe/reference.py</code> <pre><code>def check_receptor_idxs(\n    topology: mdtop.Topology | mdtraj.Trajectory,\n    receptor_idxs: tuple[int, int, int],\n    ligand_ref_idxs: tuple[int, int, int],\n) -&gt; bool:\n    \"\"\"Check if the specified receptor atoms meet the criteria for use in Boresch-style\n    restraints as defined by Baumann et al [1].\n\n    References:\n        [1] Baumann, Hannah M., et al. \"Broadening the scope of binding free energy\n            calculations using a Separated Topologies approach.\" (2023).\n\n    Args:\n        topology: The system topology.\n        receptor_idxs: The indices of the three receptor atoms that will be restrained.\n        ligand_ref_idxs: The indices of the three ligand atoms that will be restrained.\n\n    Returns:\n        True if the atoms meet the criteria, False otherwise.\n    \"\"\"\n\n    if isinstance(topology, mdtop.Topology):\n        topology = _topology_to_mdtraj(topology)\n\n    r1, r2, r3 = receptor_idxs\n    l1, l2, l3 = ligand_ref_idxs\n\n    is_valid_r1 = _is_valid_r1(topology, r1, l1, l2, l3)\n    is_valid_r2 = _is_valid_r2(topology, r1, r2, l1, l2)\n    is_valid_r3 = _is_valid_r3(topology, r1, r2, r3, l1)\n\n    r3_distances_per_frame = [\n        scipy.spatial.distance.cdist(frame[[r3], :], frame[[r1, r2], :])\n        for frame in topology.xyz\n    ]\n    r3_distance_avg = numpy.stack(r3_distances_per_frame).mean(axis=0)\n\n    max_distance = 0.8 * (topology.unitcell_lengths[-1][0] / 2)\n    is_valid_distance = r3_distance_avg.max(axis=-1) &lt; max_distance\n\n    return is_valid_r1 and is_valid_r2 and is_valid_r3 and is_valid_distance\n</code></pre>"},{"location":"reference/fe/reference/#femto.fe.reference.select_protein_cavity_atoms","title":"select_protein_cavity_atoms","text":"<pre><code>select_protein_cavity_atoms(\n    protein: Topology,\n    ligands: list[Topology],\n    cutoff: Quantity,\n) -&gt; str\n</code></pre> <p>Select the alpha carbon atoms that define the binding cavity of the protein based on their distance to ligand atoms.</p> <p>Parameters:</p> <ul> <li> <code>protein</code>               (<code>Topology</code>)           \u2013            <p>The protein.</p> </li> <li> <code>ligands</code>               (<code>list[Topology]</code>)           \u2013            <p>The ligands to consider.</p> </li> <li> <code>cutoff</code>               (<code>Quantity</code>)           \u2013            <p>Residues further than this distance from a ligand will be excluded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The AMBER style query that will select the reference atoms of the protein.</p> </li> </ul> Source code in <code>femto/fe/reference.py</code> <pre><code>def select_protein_cavity_atoms(\n    protein: mdtop.Topology,\n    ligands: list[mdtop.Topology],\n    cutoff: openmm.unit.Quantity,\n) -&gt; str:\n    \"\"\"Select the alpha carbon atoms that define the binding cavity of the protein based\n    on their distance to ligand atoms.\n\n    Args:\n        protein: The protein.\n        ligands: The ligands to consider.\n        cutoff: Residues further than this distance from a ligand will be excluded.\n\n    Returns:\n        The AMBER style query that will select the reference atoms of the protein.\n    \"\"\"\n\n    ref_atoms = []\n\n    for residue in protein.residues:\n        if (\n            sorted(a.atomic_num for a in residue.atoms) == [1, 1, 8]\n            # a bit of a hack to check for ions.\n            or len(residue.atoms) == 1\n        ):\n            continue\n\n        c_alpha_idxs = [a.index for a in residue.atoms if a.name == \"CA\"]\n\n        if len(c_alpha_idxs) &lt; 1:\n            continue\n\n        ref_atoms.extend(c_alpha_idxs)\n\n    protein_coords = protein.xyz.value_in_unit(openmm.unit.angstrom)[ref_atoms, :]\n\n    cutoff = cutoff.value_in_unit(openmm.unit.angstrom)\n\n    is_reference = numpy.array([False] * len(ref_atoms))\n\n    for ligand in ligands:\n        ligand_coords = ligand.xyz.value_in_unit(openmm.unit.angstrom)\n\n        distances = scipy.spatial.distance_matrix(protein_coords, ligand_coords)\n        is_reference = is_reference | (distances &lt; cutoff).any(axis=1)\n\n    n_atoms = is_reference.sum()\n\n    if n_atoms &lt; 1:\n        raise RuntimeError(\"Could not find the protein binding site reference atoms.\")\n\n    ref_mask = \"index \" + \"+\".join(\n        str(i + 1) for i, keep in zip(ref_atoms, is_reference, strict=True) if keep\n    )\n    return ref_mask\n</code></pre>"},{"location":"reference/fe/uwham/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> uwham","text":""},{"location":"reference/fe/uwham/#femto.fe.uwham","title":"uwham","text":"<p>Estimate free energies using the UWHAM method [1]</p> References <p>[1]: Zhiqiang Tan, Emilio Gallicchio, Mauro Lapelosa, and Ronald M. Levy,      \"Theory of binless multi-state free energy estimation with applications      to protein-ligand binding\", J. Chem. Phys. 136, 144102 (2012)</p> <p>Functions:</p> <ul> <li> <code>estimate_f_i</code>             \u2013              <p>Estimates the free energies of a set of sampled states.</p> </li> </ul>"},{"location":"reference/fe/uwham/#femto.fe.uwham.estimate_f_i","title":"estimate_f_i","text":"<pre><code>estimate_f_i(\n    u_kn: ndarray, n_k: ndarray\n) -&gt; tuple[ndarray, ndarray, ndarray]\n</code></pre> <p>Estimates the free energies of a set of sampled states.</p> <p>Parameters:</p> <ul> <li> <code>u_kn</code>               (<code>ndarray</code>)           \u2013            <p>The uncorrelated reduced potentials sampled at <code>k</code> states with <code>shape=(n_states, n_samples)</code>.</p> </li> <li> <code>n_k</code>               (<code>ndarray</code>)           \u2013            <p>The number of samples at state <code>k</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray, ndarray]</code>           \u2013            <p>The estimated reduced free energies and their estimated variance.</p> </li> </ul> Source code in <code>femto/fe/uwham.py</code> <pre><code>def estimate_f_i(\n    u_kn: numpy.ndarray, n_k: numpy.ndarray\n) -&gt; tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]:\n    \"\"\"Estimates the free energies of a set of *sampled* states.\n\n    Args:\n        u_kn: The uncorrelated reduced potentials sampled at ``k`` states with\n            ``shape=(n_states, n_samples)``.\n        n_k: The number of samples at state ``k``.\n\n    Returns:\n        The estimated reduced free energies and their estimated variance.\n    \"\"\"\n\n    u_kn = numpy.array(u_kn)\n    n_k = numpy.array(n_k)\n\n    ln_q = -u_kn.T\n\n    n_samples, n_states = ln_q.shape\n\n    if n_states != len(n_k):\n        raise RuntimeError(\"The number of states do not match\")\n    if n_samples != n_k.sum():\n        raise RuntimeError(\"The number of samples do not match\")\n\n    ln_z = numpy.zeros(len(n_k) - 1)  # ln_z_0 is always fixed at 0.0\n    ln_q -= ln_q[:, :1]\n\n    n = n_k.sum()\n    factor = n_k / n\n\n    result = scipy.optimize.minimize(\n        functools.partial(_compute_kappa, ln_q=ln_q, n=n, factor=factor),\n        ln_z,\n        method=\"trust-ncg\",\n        jac=True,\n        hess=functools.partial(_compute_kappa_hessian, ln_q=ln_q, n=n, factor=factor),\n    )\n\n    if not result.success:\n        raise RuntimeError(\"The UWHAM minimization failed to converge.\")\n\n    f_i = numpy.insert(-result.x, 0, 0.0)\n    ln_z = numpy.insert(result.x, 0, 0.0)\n\n    weights = _compute_weights(ln_z, ln_q, factor)\n\n    if not numpy.allclose(weights.sum(axis=0) / n, 1.0, atol=1e-3):\n        raise RuntimeError(\"The UWHAM weights do not sum to 1.0\")\n\n    df_i = _compute_variance(ln_z, weights, factor, n)\n\n    return f_i, df_i, weights / n\n</code></pre>"},{"location":"reference/fe/atm/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> atm","text":""},{"location":"reference/fe/atm/#femto.fe.atm","title":"atm","text":"<p>Automated BFE calculations using the alchemical transfer method</p> <p>Classes:</p> <ul> <li> <code>ATMAlignmentRestraint</code>           \u2013            <p>Configuration for an ATM alignment restraint.</p> </li> <li> <code>ATMConfig</code>           \u2013            <p>Configuration the stages of the ATM calculation.</p> </li> <li> <code>ATMEdge</code>           \u2013            <p>Defines an ATM specific edge in a free energy network.</p> </li> <li> <code>ATMEquilibrateStage</code>           \u2013            <p>Configure how the system will be equilibrated prior to replica exchange.</p> </li> <li> <code>ATMNetwork</code>           \u2013            <p>Defines an ATM specific free energy network.</p> </li> <li> <code>ATMReferenceSelection</code>           \u2013            <p>Configure how receptor binding sites and ligand alignment reference atoms are</p> </li> <li> <code>ATMRestraints</code>           \u2013            <p>Configure the restraints that will be applied during the ATM calculations.</p> </li> <li> <code>ATMSamplingStage</code>           \u2013            <p>Configure how the system will be sampled using Hamiltonian replica exchange.</p> </li> <li> <code>ATMSetupStage</code>           \u2013            <p>Configure how the complex will be solvated and restrained prior to</p> </li> <li> <code>ATMSoftCore</code>           \u2013            <p>Configuration for the ATM soft-core potential.</p> </li> <li> <code>ATMStates</code>           \u2013            <p>Configure the lambda schedules.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>compute_ddg</code>             \u2013              <p>Computes the total binding free energy.</p> </li> <li> <code>load_config</code>             \u2013              <p>Load a configuration from a YAML file.</p> </li> <li> <code>equilibrate_states</code>             \u2013              <p>Equilibrate the system at each lambda window.</p> </li> <li> <code>run_workflow</code>             \u2013              <p>Run the setup, equilibration, and sampling phases.</p> </li> <li> <code>submit_network</code>             \u2013              <p>Submits a set of ATM calculations to the SLURM queueing manager.</p> </li> <li> <code>run_hremd</code>             \u2013              <p>Perform replica exchange sampling for a system prepared for ATM calculations.</p> </li> <li> <code>select_displacement</code>             \u2013              <p>Attempts to automatically select a displacement vector for the ligands.</p> </li> <li> <code>setup_system</code>             \u2013              <p>Prepares a system ready for running the ATM method.</p> </li> <li> <code>create_state_dicts</code>             \u2013              <p>Map the lambda states specified in the configuration to a list of dictionaries.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_ALPHA</code>           \u2013            <p>The default alpha schedule.</p> </li> <li> <code>DEFAULT_BM_B0</code>           \u2013            <p>The default beta scaling factors to use if running with REST2.</p> </li> <li> <code>DEFAULT_DIRECTION</code>           \u2013            <p>The default direction schedule.</p> </li> <li> <code>DEFAULT_EQUILIBRATE_INTEGRATOR</code>           \u2013            <p>The default integrator to use during equilibration.</p> </li> <li> <code>DEFAULT_EQUILIBRATE_RESTRAINTS</code>           \u2013            <p>The default position restraints to apply during equilibration.</p> </li> <li> <code>DEFAULT_LAMBDA_1</code>           \u2013            <p>The default lambda 1 schedule.</p> </li> <li> <code>DEFAULT_LAMBDA_2</code>           \u2013            <p>The default lambda 2 schedule.</p> </li> <li> <code>DEFAULT_MAX_REST_TEMPERATURE</code>           \u2013            <p>The default maximum temperature to use during the REST2 calculations.</p> </li> <li> <code>DEFAULT_U0</code>           \u2013            <p>The default u0 schedule.</p> </li> <li> <code>DEFAULT_W0</code>           \u2013            <p>The default w0 schedule.</p> </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_ALPHA","title":"DEFAULT_ALPHA  <code>module-attribute</code>","text":"<pre><code>DEFAULT_ALPHA = (\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n    0.1,\n)\n</code></pre> <p>The default alpha schedule.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_BM_B0","title":"DEFAULT_BM_B0  <code>module-attribute</code>","text":"<pre><code>DEFAULT_BM_B0 = tuple(tolist())\n</code></pre> <p>The default beta scaling factors to use if running with REST2.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_DIRECTION","title":"DEFAULT_DIRECTION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_DIRECTION = (\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n)\n</code></pre> <p>The default direction schedule.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_EQUILIBRATE_INTEGRATOR","title":"DEFAULT_EQUILIBRATE_INTEGRATOR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EQUILIBRATE_INTEGRATOR = LangevinIntegrator(\n    timestep=2.0 * femtosecond, friction=1.0 / picosecond\n)\n</code></pre> <p>The default integrator to use during equilibration.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_EQUILIBRATE_RESTRAINTS","title":"DEFAULT_EQUILIBRATE_RESTRAINTS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EQUILIBRATE_RESTRAINTS = {\n    DEFAULT_RESTRAINT_MASK: FlatBottomRestraint(\n        k=25.0 * _KCAL_PER_ANG_SQR, radius=1.5 * _ANGSTROM\n    )\n}\n</code></pre> <p>The default position restraints to apply during equilibration.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_LAMBDA_1","title":"DEFAULT_LAMBDA_1  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_1 = (\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.1,\n    0.2,\n    0.3,\n    0.4,\n    0.5,\n    0.5,\n    0.4,\n    0.3,\n    0.2,\n    0.1,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n)\n</code></pre> <p>The default lambda 1 schedule.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_LAMBDA_2","title":"DEFAULT_LAMBDA_2  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_2 = (\n    0.0,\n    0.1,\n    0.2,\n    0.3,\n    0.4,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.5,\n    0.4,\n    0.3,\n    0.2,\n    0.1,\n    0.0,\n)\n</code></pre> <p>The default lambda 2 schedule.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_MAX_REST_TEMPERATURE","title":"DEFAULT_MAX_REST_TEMPERATURE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAX_REST_TEMPERATURE = 900.0\n</code></pre> <p>The default maximum temperature to use during the REST2 calculations.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_U0","title":"DEFAULT_U0  <code>module-attribute</code>","text":"<pre><code>DEFAULT_U0 = (\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n    110.0,\n)\n</code></pre> <p>The default u0 schedule.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.DEFAULT_W0","title":"DEFAULT_W0  <code>module-attribute</code>","text":"<pre><code>DEFAULT_W0 = (\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n)\n</code></pre> <p>The default w0 schedule.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMAlignmentRestraint","title":"ATMAlignmentRestraint  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for an ATM alignment restraint.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['atm']</code>)             </li> <li> <code>k_distance</code>                 (<code>OpenMMQuantity[_KCAL_PER_ANG_SQR]</code>)             </li> <li> <code>k_angle</code>                 (<code>OpenMMQuantity[_KCAL_PER_MOL]</code>)             </li> <li> <code>k_dihedral</code>                 (<code>OpenMMQuantity[_KCAL_PER_MOL]</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMAlignmentRestraint.k_distance","title":"k_distance  <code>pydantic-field</code>","text":"<pre><code>k_distance: OpenMMQuantity[_KCAL_PER_ANG_SQR]\n</code></pre> <p>Force constant [kcal/mol/\u00c5^2] of the flat-bottom potential restraining the distance between the ligands.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMAlignmentRestraint.k_angle","title":"k_angle  <code>pydantic-field</code>","text":"<pre><code>k_angle: OpenMMQuantity[_KCAL_PER_MOL]\n</code></pre> <p>Force constant [kcal/mol] of the 1-cos(theta) potential restraining the angle between the ligands.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMAlignmentRestraint.k_dihedral","title":"k_dihedral  <code>pydantic-field</code>","text":"<pre><code>k_dihedral: OpenMMQuantity[_KCAL_PER_MOL]\n</code></pre> <p>Force constant [kcal/mol] of the 1-cos(phi) potential restraining the dihedral angle between the ligands.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMAlignmentRestraint.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMConfig","title":"ATMConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration the stages of the ATM calculation.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['atm']</code>)             </li> <li> <code>setup</code>                 (<code>ATMSetupStage</code>)             </li> <li> <code>states</code>                 (<code>ATMStates</code>)             </li> <li> <code>equilibrate</code>                 (<code>ATMEquilibrateStage</code>)             </li> <li> <code>sample</code>                 (<code>ATMSamplingStage</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMConfig.setup","title":"setup  <code>pydantic-field</code>","text":"<pre><code>setup: ATMSetupStage = ATMSetupStage()\n</code></pre> <p>Prepare the system for equilibration.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMConfig.states","title":"states  <code>pydantic-field</code>","text":"<pre><code>states: ATMStates = ATMStates()\n</code></pre> <p>Configure the lambda schedules.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMConfig.equilibrate","title":"equilibrate  <code>pydantic-field</code>","text":"<pre><code>equilibrate: ATMEquilibrateStage = ATMEquilibrateStage()\n</code></pre> <p>Equilibrate the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMConfig.sample","title":"sample  <code>pydantic-field</code>","text":"<pre><code>sample: ATMSamplingStage = ATMSamplingStage()\n</code></pre> <p>Sample across lambda windows using replica exchange.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMConfig.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge","title":"ATMEdge  <code>pydantic-model</code>","text":"<p>               Bases: <code>Edge</code></p> <p>Defines an ATM specific edge in a free energy network.</p> <p>Fields:</p> <ul> <li> <code>ligand_1_ref_atoms</code>                 (<code>tuple[str, str, str] | None</code>)             </li> <li> <code>ligand_2_ref_atoms</code>                 (<code>tuple[str, str, str] | None</code>)             </li> <li> <code>ligand_1_metadata</code>                 (<code>dict[str, Any]</code>)             </li> <li> <code>ligand_2_metadata</code>                 (<code>dict[str, Any]</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.ligand_1","title":"ligand_1  <code>pydantic-field</code>","text":"<pre><code>ligand_1: str\n</code></pre> <p>The name of the first ligand.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.ligand_2","title":"ligand_2  <code>pydantic-field</code>","text":"<pre><code>ligand_2: str | None\n</code></pre> <p>The name of the second ligand. This should be <code>None</code> if running an ABFE calculation.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.ligand_1_ref_atoms","title":"ligand_1_ref_atoms  <code>pydantic-field</code>","text":"<pre><code>ligand_1_ref_atoms: tuple[str, str, str] | None = None\n</code></pre> <p>Three (optional) AMBER style queries that select the atoms of the first ligand to align during an RBFE calculation.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.ligand_2_ref_atoms","title":"ligand_2_ref_atoms  <code>pydantic-field</code>","text":"<pre><code>ligand_2_ref_atoms: tuple[str, str, str] | None = None\n</code></pre> <p>Three (optional) AMBER style queries that select the atoms of the second ligand to align during an RBFE calculation.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.ligand_1_metadata","title":"ligand_1_metadata  <code>pydantic-field</code>","text":"<pre><code>ligand_1_metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata about ligand 1.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.ligand_2_metadata","title":"ligand_2_metadata  <code>pydantic-field</code>","text":"<pre><code>ligand_2_metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata about ligand 2.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEdge.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEquilibrateStage","title":"ATMEquilibrateStage  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how the system will be equilibrated prior to replica exchange.</p> <p>Fields:</p> <ul> <li> <code>stages</code>                 (<code>list[SimulationStage]</code>)             </li> <li> <code>report_interval</code>                 (<code>int</code>)             </li> <li> <code>soft_core</code>                 (<code>ATMSoftCore</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEquilibrateStage.report_interval","title":"report_interval  <code>pydantic-field</code>","text":"<pre><code>report_interval: int = 5000\n</code></pre> <p>The number of steps to report energy, volume, etc after.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEquilibrateStage.soft_core","title":"soft_core  <code>pydantic-field</code>","text":"<pre><code>soft_core: ATMSoftCore = ATMSoftCore(\n    u_max=1000 * _KCAL_PER_MOL,\n    u0=500 * _KCAL_PER_MOL,\n    a=1.0 / 16.0,\n)\n</code></pre> <p>The ATM soft-core potential parameters to use during equilibration.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMEquilibrateStage.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMNetwork","title":"ATMNetwork  <code>pydantic-model</code>","text":"<p>               Bases: <code>Network</code></p> <p>Defines an ATM specific free energy network.</p> <p>Fields:</p> <ul> <li> <code>receptor_ref_query</code>                 (<code>str | None</code>)             </li> <li> <code>edges</code>                 (<code>list[ATMEdge]</code>)             </li> <li> <code>receptor_metadata</code>                 (<code>dict[str, Any]</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMNetwork.receptor","title":"receptor  <code>pydantic-field</code>","text":"<pre><code>receptor: str | None = None\n</code></pre> <p>The name of the receptor. If <code>None</code>, the receptor will be identified from the input directory structure</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMNetwork.receptor_ref_query","title":"receptor_ref_query  <code>pydantic-field</code>","text":"<pre><code>receptor_ref_query: str | None = None\n</code></pre> <p>An (optional) query to manually select the receptor atoms that define the binding site. If unspecified, alpha carbons within a specified distance to either ligand will be selected.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMNetwork.edges","title":"edges  <code>pydantic-field</code>","text":"<pre><code>edges: list[ATMEdge]\n</code></pre> <p>The edges in the free energy network.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMNetwork.receptor_metadata","title":"receptor_metadata  <code>pydantic-field</code>","text":"<pre><code>receptor_metadata: dict[str, Any]\n</code></pre> <p>Any additional metadata about the receptor.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMNetwork.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMReferenceSelection","title":"ATMReferenceSelection  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how receptor binding sites and ligand alignment reference atoms are selected if the user does not explicitly provide them.</p> <p>Fields:</p> <ul> <li> <code>receptor_cutoff</code>                 (<code>OpenMMQuantity[_ANGSTROM]</code>)             </li> <li> <code>ligand_method</code>                 (<code>LigandReferenceMethod</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMReferenceSelection.receptor_cutoff","title":"receptor_cutoff  <code>pydantic-field</code>","text":"<pre><code>receptor_cutoff: OpenMMQuantity[_ANGSTROM] = 5.0 * _ANGSTROM\n</code></pre> <p>The minimum distance between a residues' alpha carbon and a ligand atom to be considered part of the binding site.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMReferenceSelection.ligand_method","title":"ligand_method  <code>pydantic-field</code>","text":"<pre><code>ligand_method: LigandReferenceMethod = 'chen'\n</code></pre> <p>The default method to use to select ligand reference atoms during RBFE calculations if the user does not explicitly provide them.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMReferenceSelection.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMRestraints","title":"ATMRestraints  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure the restraints that will be applied during the ATM calculations.</p> <p>Fields:</p> <ul> <li> <code>com</code>                 (<code>FlatBottomRestraint</code>)             </li> <li> <code>alignment</code>                 (<code>ATMAlignmentRestraint | None</code>)             </li> <li> <code>receptor</code>                 (<code>FlatBottomRestraint</code>)             </li> <li> <code>receptor_query</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMRestraints.com","title":"com  <code>pydantic-field</code>","text":"<pre><code>com: FlatBottomRestraint = FlatBottomRestraint(\n    k=25.0 * _KCAL_PER_ANG_SQR, radius=5.0 * _ANGSTROM\n)\n</code></pre> <p>The potential that restrains the ligands to the binding site.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMRestraints.alignment","title":"alignment  <code>pydantic-field</code>","text":"<pre><code>alignment: ATMAlignmentRestraint | None = (\n    ATMAlignmentRestraint(\n        k_distance=2.5 * _KCAL_PER_ANG_SQR,\n        k_angle=25.0 * _KCAL_PER_MOL,\n        k_dihedral=25.0 * _KCAL_PER_MOL,\n    )\n)\n</code></pre> <p>The potential that restrains the orientation of the two ligands during an RBFE calculation.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMRestraints.receptor","title":"receptor  <code>pydantic-field</code>","text":"<pre><code>receptor: FlatBottomRestraint = FlatBottomRestraint(\n    k=25.0 * _KCAL_PER_ANG_SQR, radius=1.5 * _ANGSTROM\n)\n</code></pre> <p>The potential that restrains specified receptor atoms to their initial coordinates.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMRestraints.receptor_query","title":"receptor_query  <code>pydantic-field</code>","text":"<pre><code>receptor_query: str = 'name CA'\n</code></pre> <p>An Amber query used to identify which receptor atoms to restrain.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMRestraints.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage","title":"ATMSamplingStage  <code>pydantic-model</code>","text":"<p>               Bases: <code>HREMD</code></p> <p>Configure how the system will be sampled using Hamiltonian replica exchange.</p> <p>Fields:</p> <ul> <li> <code>integrator</code>                 (<code>LangevinIntegrator</code>)             </li> <li> <code>soft_core</code>                 (<code>ATMSoftCore</code>)             </li> <li> <code>analysis_interval</code>                 (<code>int | None</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.temperature","title":"temperature  <code>pydantic-field</code>","text":"<pre><code>temperature: OpenMMQuantity[kelvin] = DEFAULT_TEMPERATURE\n</code></pre> <p>The temperature to sample at.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.n_warmup_steps","title":"n_warmup_steps  <code>pydantic-field</code>","text":"<pre><code>n_warmup_steps: int = 150000\n</code></pre> <p>The number of steps to run each replica for before starting hremd trials. All energies gathered during this period will be discarded.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.n_steps_per_cycle","title":"n_steps_per_cycle  <code>pydantic-field</code>","text":"<pre><code>n_steps_per_cycle: int = 1000\n</code></pre> <p>The number of steps to propagate the system by before attempting an exchange.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.n_cycles","title":"n_cycles  <code>pydantic-field</code>","text":"<pre><code>n_cycles: int = 2500\n</code></pre> <p>The number of cycles of 'propagate the system' -&gt; 'exchange replicas' to run.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.max_step_retries","title":"max_step_retries  <code>pydantic-field</code>","text":"<pre><code>max_step_retries: int = 5\n</code></pre> <p>The maximum number of times to attempt to step if a NaN is encountered before raising an exception</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.swap_mode","title":"swap_mode  <code>pydantic-field</code>","text":"<pre><code>swap_mode: HREMDSwapModeLiteral | None = ALL.value\n</code></pre> <p>The mode in which to propose state swaps between replicas. This can either be: 'neighbours', only try and swap adjacent states or ii. 'all', try and swap all states stochastically. If <code>None</code>, no replica exchanges will be attempted.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.max_swaps","title":"max_swaps  <code>pydantic-field</code>","text":"<pre><code>max_swaps: int | None = None\n</code></pre> <p>The maximum number of swap proposals to make if running in 'all' mode. This variable does nothing when running in 'neighbours' mode.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.trajectory_interval","title":"trajectory_interval  <code>pydantic-field</code>","text":"<pre><code>trajectory_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to DCD trajectory files. If <code>None</code>, no trajectories will be saved.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.trajectory_enforce_pbc","title":"trajectory_enforce_pbc  <code>pydantic-field</code>","text":"<pre><code>trajectory_enforce_pbc: bool = False\n</code></pre> <p>Whether to apply periodic boundary conditions when retrieving coordinates for writing to trajectory files.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.checkpoint_interval","title":"checkpoint_interval  <code>pydantic-field</code>","text":"<pre><code>checkpoint_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to checkpoint files. If <code>None</code>, no checkpoints will be saved.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.integrator","title":"integrator  <code>pydantic-field</code>","text":"<pre><code>integrator: LangevinIntegrator = LangevinIntegrator(\n    timestep=4.0 * femtosecond, friction=1.0 / picosecond\n)\n</code></pre> <p>The MD integrator to use.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.soft_core","title":"soft_core  <code>pydantic-field</code>","text":"<pre><code>soft_core: ATMSoftCore = ATMSoftCore(\n    u_max=200 * _KCAL_PER_MOL,\n    u0=100 * _KCAL_PER_MOL,\n    a=1.0 / 16.0,\n)\n</code></pre> <p>The ATM soft-core potential parameters to use.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.analysis_interval","title":"analysis_interval  <code>pydantic-field</code>","text":"<pre><code>analysis_interval: int | None = None\n</code></pre> <p>The interval (in number of cycles) between estimating and reporting the free energy. If <code>None</code>, no analysis will be performed.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSamplingStage.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage","title":"ATMSetupStage  <code>pydantic-model</code>","text":"<p>               Bases: <code>Prepare</code></p> <p>Configure how the complex will be solvated and restrained prior to equilibration</p> <p>Fields:</p> <ul> <li> <code>displacement</code>                 (<code>OpenMMQuantity[_ANGSTROM] | tuple[OpenMMQuantity[_ANGSTROM], OpenMMQuantity[_ANGSTROM], OpenMMQuantity[_ANGSTROM]]</code>)             </li> <li> <code>reference</code>                 (<code>ATMReferenceSelection</code>)             </li> <li> <code>restraints</code>                 (<code>ATMRestraints</code>)             </li> <li> <code>apply_hmr</code>                 (<code>bool</code>)             </li> <li> <code>hydrogen_mass</code>                 (<code>OpenMMQuantity[amu]</code>)             </li> <li> <code>apply_rest</code>                 (<code>bool</code>)             </li> <li> <code>rest_config</code>                 (<code>REST | None</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_rest_config</code>                 \u2192                   <code>rest_config</code> </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.ionic_strength","title":"ionic_strength  <code>pydantic-field</code>","text":"<pre><code>ionic_strength: OpenMMQuantity[molar] = 0.0 * molar\n</code></pre> <p>The total concentration of ions pairs (<code>anion</code> and <code>cation</code>) to add to approximate an ionic strength. This does not include ions that are added to neutralize the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.neutralize","title":"neutralize  <code>pydantic-field</code>","text":"<pre><code>neutralize: bool = True\n</code></pre> <p>Whether to add counter ions to neutralize the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.cation","title":"cation  <code>pydantic-field</code>","text":"<pre><code>cation: Literal['Na+', 'K+'] = 'K+'\n</code></pre> <p>The cation to use when neutralizing the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.anion","title":"anion  <code>pydantic-field</code>","text":"<pre><code>anion: Literal['Cl-'] = 'Cl-'\n</code></pre> <p>The anion to use when neutralizing the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.water_model","title":"water_model  <code>pydantic-field</code>","text":"<pre><code>water_model: Literal['tip3p'] = 'tip3p'\n</code></pre> <p>The water model to use when generating solvent coordinates. The actual force field parameters used for the solvent are determined by the <code>default_protein_ff</code> or any extra parameters provided while preparing the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.default_protein_ff","title":"default_protein_ff  <code>pydantic-field</code>","text":"<pre><code>default_protein_ff: list[str] = [*DEFAULT_OPENMM_FF_SOURCES]\n</code></pre> <p>The default parameters to use when parameterizing the protein, solvent, and ions.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.default_ligand_ff","title":"default_ligand_ff  <code>pydantic-field</code>","text":"<pre><code>default_ligand_ff: str | None = 'openff-2.0.0.offxml'\n</code></pre> <p>The default parameters to apply when parameterizing ligands, or <code>None</code> otherwise. Currently, only the path to an OpenFF <code>offxml</code> file can be specified.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.box_padding","title":"box_padding  <code>pydantic-field</code>","text":"<pre><code>box_padding: OpenMMQuantity[_ANGSTROM] | None = (\n    10.0 * _ANGSTROM\n)\n</code></pre> <p>The minimum distance between any complex atom (including any offset ligands) and the box wall. This option is mutually exclusive with <code>n_waters</code>.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.box_shape","title":"box_shape  <code>pydantic-field</code>","text":"<pre><code>box_shape: Literal['cube', 'cubeoid'] = 'cubeoid'\n</code></pre> <p>The shape of the box to use when solvating the complex, when <code>box_padding</code> is specified.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.n_waters","title":"n_waters  <code>pydantic-field</code>","text":"<pre><code>n_waters: int | None = None\n</code></pre> <p>The number of extra waters to solvate the complex using. This option is mutually exclusive with <code>box_padding</code>.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.displacement","title":"displacement  <code>pydantic-field</code>","text":"<pre><code>displacement: (\n    OpenMMQuantity[_ANGSTROM]\n    | tuple[\n        OpenMMQuantity[_ANGSTROM],\n        OpenMMQuantity[_ANGSTROM],\n        OpenMMQuantity[_ANGSTROM],\n    ]\n) = (\n    38.0 * _ANGSTROM\n)\n</code></pre> <p>The distance to displace ligands from the binding site along an automatically selected displacement vector, or the vector to displace the ligands by.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.reference","title":"reference  <code>pydantic-field</code>","text":"<pre><code>reference: ATMReferenceSelection = ATMReferenceSelection()\n</code></pre> <p>Selection of receptor and ligand reference atoms.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.restraints","title":"restraints  <code>pydantic-field</code>","text":"<pre><code>restraints: ATMRestraints = ATMRestraints()\n</code></pre> <p>Control how the system should be restrained.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.apply_hmr","title":"apply_hmr  <code>pydantic-field</code>","text":"<pre><code>apply_hmr: bool = True\n</code></pre> <p>Whether to aply hydrogen mass repartitioning to the system.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.hydrogen_mass","title":"hydrogen_mass  <code>pydantic-field</code>","text":"<pre><code>hydrogen_mass: OpenMMQuantity[amu] = 1.5 * amu\n</code></pre> <p>The mass to assign to hydrogen atoms when applying HMR.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.apply_rest","title":"apply_rest  <code>pydantic-field</code>","text":"<pre><code>apply_rest: bool = False\n</code></pre> <p>Whether to prepare the system for REST sampling.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.rest_config","title":"rest_config  <code>pydantic-field</code>","text":"<pre><code>rest_config: REST | None = REST(\n    scale_nonbonded=True,\n    scale_torsions=True,\n    scale_angles=False,\n    scale_bonds=False,\n)\n</code></pre> <p>The REST configuration to use if <code>apply_rest</code> is True.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSetupStage.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSoftCore","title":"ATMSoftCore  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the ATM soft-core potential.</p> <p>Fields:</p> <ul> <li> <code>u_max</code>                 (<code>OpenMMQuantity[_KCAL_PER_MOL]</code>)             </li> <li> <code>u0</code>                 (<code>OpenMMQuantity[_KCAL_PER_MOL]</code>)             </li> <li> <code>a</code>                 (<code>float</code>)             </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSoftCore.u_max","title":"u_max  <code>pydantic-field</code>","text":"<pre><code>u_max: OpenMMQuantity[_KCAL_PER_MOL]\n</code></pre> <p>The 'u max' [kcal/mol] parameter.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSoftCore.u0","title":"u0  <code>pydantic-field</code>","text":"<pre><code>u0: OpenMMQuantity[_KCAL_PER_MOL]\n</code></pre> <p>The 'u0' [kcal/mol] parameter.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSoftCore.a","title":"a  <code>pydantic-field</code>","text":"<pre><code>a: float\n</code></pre> <p>The 'a' parameter.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMSoftCore.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMStates","title":"ATMStates  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure the lambda schedules.</p> <p>Fields:</p> <ul> <li> <code>lambda_1</code>                 (<code>list[float]</code>)             </li> <li> <code>lambda_2</code>                 (<code>list[float]</code>)             </li> <li> <code>direction</code>                 (<code>list[Literal[-1, 1]]</code>)             </li> <li> <code>alpha</code>                 (<code>list[float]</code>)             </li> <li> <code>alpha_unit</code>                 (<code>ClassVar</code>)             </li> <li> <code>u0</code>                 (<code>list[float]</code>)             </li> <li> <code>u0_unit</code>                 (<code>ClassVar</code>)             </li> <li> <code>w0</code>                 (<code>list[float]</code>)             </li> <li> <code>w0_unit</code>                 (<code>ClassVar</code>)             </li> <li> <code>bm_b0</code>                 (<code>list[float] | None</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_lambda_lengths</code> </li> </ul>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMStates.bm_b0","title":"bm_b0  <code>pydantic-field</code>","text":"<pre><code>bm_b0: list[float] | None = None\n</code></pre> <p>The REST2 beta scaling factors (beta_m / beta_0) to use. <code>apply_rest</code> must be set to true in the setup config if using this.</p>"},{"location":"reference/fe/atm/#femto.fe.atm.ATMStates.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.compute_ddg","title":"compute_ddg","text":"<pre><code>compute_ddg(\n    config: ATMSamplingStage,\n    states: ATMStates,\n    u_kn: ndarray,\n    n_k: ndarray,\n) -&gt; DataFrame\n</code></pre> <p>Computes the total binding free energy.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>ATMSamplingStage</code>)           \u2013            <p>The sampling configuration.</p> </li> <li> <code>states</code>               (<code>ATMStates</code>)           \u2013            <p>The sampled states.</p> </li> <li> <code>u_kn</code>               (<code>ndarray</code>)           \u2013            <p>The samples.</p> </li> <li> <code>n_k</code>               (<code>ndarray</code>)           \u2013            <p>The sample counts.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A pandas DataFrame containing the total binding free energy and its components.</p> </li> </ul> Source code in <code>femto/fe/atm/_analyze.py</code> <pre><code>def compute_ddg(\n    config: \"femto.fe.atm.ATMSamplingStage\",\n    states: \"femto.fe.atm.ATMStates\",\n    u_kn: numpy.ndarray,\n    n_k: numpy.ndarray,\n) -&gt; \"pandas.DataFrame\":\n    \"\"\"Computes the total binding free energy.\n\n    Args:\n        config: The sampling configuration.\n        states: The sampled states.\n        u_kn: The samples.\n        n_k: The sample counts.\n\n    Returns:\n        A pandas DataFrame containing the total binding free energy and its components.\n    \"\"\"\n    import pandas\n\n    n_states = len(states.lambda_1)\n    n_states_leg_1 = states.direction.index(-1)\n\n    state_groups = [(n_states_leg_1, 1.0), (n_states - n_states_leg_1, 1.0)]\n\n    estimated, _ = femto.fe.ddg.estimate_ddg(\n        u_kn, n_k, config.temperature, state_groups\n    )\n    return pandas.DataFrame([estimated])\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.load_config","title":"load_config","text":"<pre><code>load_config(path: Path) -&gt; ATMConfig\n</code></pre> <p>Load a configuration from a YAML file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the YAML configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ATMConfig</code>           \u2013            <p>The loaded configuration.</p> </li> </ul> Source code in <code>femto/fe/atm/_config.py</code> <pre><code>def load_config(path: pathlib.Path) -&gt; ATMConfig:\n    \"\"\"Load a configuration from a YAML file.\n\n    Args:\n        path: The path to the YAML configuration.\n\n    Returns:\n        The loaded configuration.\n    \"\"\"\n    return ATMConfig(**yaml.safe_load(path.read_text()))\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.equilibrate_states","title":"equilibrate_states","text":"<pre><code>equilibrate_states(\n    system: System,\n    topology: Topology,\n    states: ATMStates,\n    config: ATMEquilibrateStage,\n    offset: Quantity,\n    platform: OpenMMPlatform,\n    reporter: Reporter | None = None,\n) -&gt; list[State]\n</code></pre> <p>Equilibrate the system at each lambda window.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology of the system to simulate.</p> </li> <li> <code>states</code>               (<code>ATMStates</code>)           \u2013            <p>The states of the system to simulate.</p> </li> <li> <code>config</code>               (<code>ATMEquilibrateStage</code>)           \u2013            <p>Configuration settings.</p> </li> <li> <code>offset</code>               (<code>Quantity</code>)           \u2013            <p>The vector to offset the ligand by using the ATM force.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The accelerator to use.</p> </li> <li> <code>reporter</code>               (<code>Reporter | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) reporter to use to record system statistics such as volume and energy.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[State]</code>           \u2013            <p>The final equilibrated state.</p> </li> </ul> Source code in <code>femto/fe/atm/_equilibrate.py</code> <pre><code>def equilibrate_states(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    states: \"femto.fe.atm.ATMStates\",\n    config: \"femto.fe.atm.ATMEquilibrateStage\",\n    offset: openmm.unit.Quantity,\n    platform: femto.md.constants.OpenMMPlatform,\n    reporter: femto.md.reporting.Reporter | None = None,\n) -&gt; list[openmm.State]:\n    \"\"\"Equilibrate the system at each lambda window.\n\n    Args:\n        system: The system to simulate.\n        topology: The topology of the system to simulate.\n        states: The states of the system to simulate.\n        config: Configuration settings.\n        offset: The vector to offset the ligand by using the ATM force.\n        platform: The accelerator to use.\n        reporter: The (optional) reporter to use to record system statistics such as\n            volume and energy.\n\n    Returns:\n        The final equilibrated state.\n    \"\"\"\n    import femto.fe.atm._utils\n\n    reporter = femto.md.reporting.NullReporter() if reporter is None else reporter\n\n    openmm_reporter = femto.md.reporting.openmm.OpenMMStateReporter(\n        reporter, \"equilibration\", config.report_interval\n    )\n\n    state_dicts = femto.fe.atm._utils.create_state_dicts(states)\n\n    system = copy.deepcopy(system)\n    femto.fe.atm._utils.add_atm_force(system, topology, config.soft_core, offset)\n\n    equilibrated_coords = femto.md.simulate.simulate_states(\n        system, topology, state_dicts, config.stages, platform, openmm_reporter\n    )\n\n    box_vectors = [\n        coords.getPeriodicBoxVectors(asNumpy=True).value_in_unit(openmm.unit.angstrom)\n        for coords in equilibrated_coords\n    ]\n    box_vectors_max = numpy.max(numpy.stack(box_vectors), axis=0) * openmm.unit.angstrom\n\n    for i, coords in enumerate(equilibrated_coords):\n        context = openmm.Context(system, openmm.VerletIntegrator(0.00001))\n        context.setState(coords)\n        context.setPeriodicBoxVectors(*box_vectors_max)\n\n        equilibrated_coords[i] = context.getState(getPositions=True)\n\n    return equilibrated_coords\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.run_workflow","title":"run_workflow","text":"<pre><code>run_workflow(\n    config: ATMConfig,\n    ligand_1_path: Path,\n    ligand_2_path: Path | None,\n    receptor_path: Path,\n    cofactor_paths: list[Path] | None,\n    output_dir: Path,\n    report_dir: Path | None = None,\n    displacement: Quantity | None = None,\n    ligand_1_ref_atoms: tuple[str, str, str] | None = None,\n    ligand_2_ref_atoms: tuple[str, str, str] | None = None,\n    receptor_ref_atoms: str | None = None,\n    extra_params: list[Path] | None = None,\n)\n</code></pre> <p>Run the setup, equilibration, and sampling phases.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>ATMConfig</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>ligand_1_path</code>               (<code>Path</code>)           \u2013            <p>The path to the first ligand.</p> </li> <li> <code>ligand_2_path</code>               (<code>Path | None</code>)           \u2013            <p>The path to the second ligand, if present.</p> </li> <li> <code>receptor_path</code>               (<code>Path</code>)           \u2013            <p>The path to the receptor.</p> </li> <li> <code>cofactor_paths</code>               (<code>list[Path] | None</code>)           \u2013            <p>The paths to any cofactors.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store all outputs in.</p> </li> <li> <code>report_dir</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The directory to store the logs / reports in.</p> </li> <li> <code>displacement</code>               (<code>Quantity | None</code>, default:                   <code>None</code> )           \u2013            <p>The displacement to offset the ligands by.</p> </li> <li> <code>ligand_1_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query masks that select the first ligands' reference atoms.</p> </li> <li> <code>ligand_2_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query masks that select the second ligands' reference atoms.</p> </li> <li> <code>receptor_ref_atoms</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query mask that selects the receptor atoms that form the binding site.</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> Source code in <code>femto/fe/atm/_runner.py</code> <pre><code>def run_workflow(\n    config: \"femto.fe.atm.ATMConfig\",\n    ligand_1_path: pathlib.Path,\n    ligand_2_path: pathlib.Path | None,\n    receptor_path: pathlib.Path,\n    cofactor_paths: list[pathlib.Path] | None,\n    output_dir: pathlib.Path,\n    report_dir: pathlib.Path | None = None,\n    displacement: openmm.unit.Quantity | None = None,\n    ligand_1_ref_atoms: tuple[str, str, str] | None = None,\n    ligand_2_ref_atoms: tuple[str, str, str] | None = None,\n    receptor_ref_atoms: str | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n):\n    \"\"\"Run the setup, equilibration, and sampling phases.\n\n    Args:\n        config: The configuration.\n        ligand_1_path: The path to the first ligand.\n        ligand_2_path: The path to the second ligand, if present.\n        receptor_path: The path to the receptor.\n        cofactor_paths: The paths to any cofactors.\n        output_dir: The directory to store all outputs in.\n        report_dir: The directory to store the logs / reports in.\n        displacement: The displacement to offset the ligands by.\n        ligand_1_ref_atoms: The AMBER style query masks that select the first ligands'\n            reference atoms.\n        ligand_2_ref_atoms: The AMBER style query masks that select the second ligands'\n            reference atoms.\n        receptor_ref_atoms: The AMBER style query mask that selects the receptor atoms\n            that form the binding site.\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n    \"\"\"\n    import femto.fe.atm._equilibrate\n    import femto.fe.atm._sample\n\n    reporter = (\n        femto.md.reporting.NullReporter()\n        if report_dir is None or not femto.md.utils.mpi.is_rank_zero()\n        else femto.md.reporting.TensorboardReporter(report_dir)\n    )\n\n    topology, system, displacement = _prepare_system(\n        config.setup,\n        receptor_path,\n        ligand_1_path,\n        ligand_2_path,\n        cofactor_paths,\n        displacement,\n        ligand_1_ref_atoms,\n        ligand_2_ref_atoms,\n        receptor_ref_atoms,\n        output_dir / \"_setup\",\n        extra_params,\n    )\n\n    equilibrate_dir = output_dir / \"_equilibrate\"\n    equilibrate_dir.mkdir(exist_ok=True, parents=True)\n\n    coord_paths = [\n        equilibrate_dir / f\"state_{state_idx}.xml\"\n        for state_idx in range(len(config.states.lambda_1))\n    ]\n\n    if any(not path.exists() for path in coord_paths):\n        coords = femto.fe.atm._equilibrate.equilibrate_states(\n            system,\n            topology,\n            config.states,\n            config.equilibrate,\n            displacement,\n            femto.md.constants.OpenMMPlatform.CUDA,\n            reporter,\n        )\n        _cache_equilibrate_outputs(coords, coord_paths)\n    else:\n        coords = [\n            openmm.XmlSerializer.deserialize(path.read_text()) for path in coord_paths\n        ]\n\n    sample_dir = output_dir / \"_sample\"\n    result_path = output_dir / \"ddg.csv\"\n\n    if not result_path.exists():\n        femto.fe.atm._sample.run_hremd(\n            system,\n            topology,\n            coords,\n            config.states,\n            config.sample,\n            displacement,\n            femto.md.constants.OpenMMPlatform.CUDA,\n            sample_dir,\n            reporter,\n        )\n        _analyze_results(config, sample_dir, result_path)\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.submit_network","title":"submit_network","text":"<pre><code>submit_network(\n    config: ATMConfig,\n    network: Network,\n    output_dir: Path,\n    queue_options: SLURMOptions,\n    mpi_command: list[str] | None = None,\n) -&gt; list[str]\n</code></pre> <p>Submits a set of ATM calculations to the SLURM queueing manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>ATMConfig</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>network</code>               (<code>Network</code>)           \u2013            <p>The network of edges to run.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store any outputs in.</p> </li> <li> <code>queue_options</code>               (<code>SLURMOptions</code>)           \u2013            <p>The options to use when submitting the jobs.</p> </li> <li> <code>mpi_command</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The mpi runner command to use. The default is <code>\"srun --mpi=pmix\"</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The ids of the submitted jobs.</p> </li> </ul> Source code in <code>femto/fe/atm/_runner.py</code> <pre><code>def submit_network(\n    config: \"femto.fe.atm.ATMConfig\",\n    network: femto.fe.inputs.Network,\n    output_dir: pathlib.Path,\n    queue_options: femto.fe.utils.queue.SLURMOptions,\n    mpi_command: list[str] | None = None,\n) -&gt; list[str]:\n    \"\"\"Submits a set of ATM calculations to the SLURM queueing manager.\n\n    Args:\n        config: The configuration.\n        network: The network of edges to run.\n        output_dir: The directory to store any outputs in.\n        queue_options: The options to use when submitting the jobs.\n        mpi_command: The mpi runner command to use. The default is\n            ``\"srun --mpi=pmix\"``.\n\n    Returns:\n        The ids of the submitted jobs.\n    \"\"\"\n\n    mpi_command = mpi_command if mpi_command is not None else [\"srun\", \"--mpi=pmix\"]\n\n    output_dir.mkdir(exist_ok=True, parents=True)\n\n    date_str = datetime.datetime.now().strftime(\"%Y-%m-%d--%H-%M-%S\")\n    config_path = output_dir / f\"config-{date_str}.yaml\"\n    config_path.write_text(config.model_dump_yaml(sort_keys=False))\n\n    femto_command = [\n        \"femto\",\n        \"atm\",\n        f\"--config={config_path}\",\n        \"run-workflow\",\n    ]\n\n    slurm_job_ids = []\n\n    for edge in network.edges:\n        edge_dir = output_dir / f\"{edge.ligand_1.name}~{edge.ligand_2.name}\"\n\n        job_id = femto.fe.utils.queue.submit_slurm_job(\n            [\n                *mpi_command,\n                *femto_command,\n                *_create_run_flags(network.receptor, \"receptor\"),\n                *_create_run_flags(edge.ligand_1, \"ligand-1\"),\n                *_create_run_flags(edge.ligand_2, \"ligand-2\"),\n                f\"--output-dir={edge_dir}\",\n                f\"--report-dir={edge_dir}\",\n            ],\n            queue_options,\n            edge_dir / f\"run-{date_str}.out\",\n        )\n\n        slurm_job_ids.append(job_id)\n\n    return slurm_job_ids\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.run_hremd","title":"run_hremd","text":"<pre><code>run_hremd(\n    system: System,\n    topology: Topology,\n    coords: list[State],\n    states: ATMStates,\n    config: ATMSamplingStage,\n    offset: Quantity,\n    platform: OpenMMPlatform,\n    output_dir: Path,\n    reporter: Reporter | None = None,\n)\n</code></pre> <p>Perform replica exchange sampling for a system prepared for ATM calculations.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate. It should not already contain an ATM force.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology associated with the system.</p> </li> <li> <code>coords</code>               (<code>list[State]</code>)           \u2013            <p>The starting coordinates for each state.</p> </li> <li> <code>states</code>               (<code>ATMStates</code>)           \u2013            <p>The lambda states to sample.</p> </li> <li> <code>config</code>               (<code>ATMSamplingStage</code>)           \u2013            <p>Configuration settings.</p> </li> <li> <code>offset</code>               (<code>Quantity</code>)           \u2013            <p>The vector to offset the ligand by using the ATM force.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The platform to run on.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store the sampled energies and statistics to, and any trajectory files if requested.</p> </li> <li> <code>reporter</code>               (<code>Reporter | None</code>, default:                   <code>None</code> )           \u2013            <p>The reporter to log statistics such as online estimates of the free energy to.</p> </li> </ul> Source code in <code>femto/fe/atm/_sample.py</code> <pre><code>def run_hremd(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    coords: list[openmm.State],\n    states: \"femto.fe.atm.ATMStates\",\n    config: \"femto.fe.atm.ATMSamplingStage\",\n    offset: openmm.unit.Quantity,\n    platform: femto.md.constants.OpenMMPlatform,\n    output_dir: pathlib.Path,\n    reporter: femto.md.reporting.Reporter | None = None,\n):\n    \"\"\"Perform replica exchange sampling for a system prepared for ATM calculations.\n\n    Args:\n        system: The system to simulate. It should *not* already contain an ATM force.\n        topology: The topology associated with the system.\n        coords: The starting coordinates for each state.\n        states: The lambda states to sample.\n        config: Configuration settings.\n        offset: The vector to offset the ligand by using the ATM force.\n        platform: The platform to run on.\n        output_dir: The directory to store the sampled energies and statistics to, and\n            any trajectory files if requested.\n        reporter: The reporter to log statistics such as online estimates of the\n            free energy to.\n    \"\"\"\n    import femto.fe.atm._utils\n\n    state_dicts = femto.fe.atm._utils.create_state_dicts(states)\n\n    system = copy.deepcopy(system)\n    femto.fe.atm._utils.add_atm_force(system, topology, config.soft_core, offset)\n\n    integrator = femto.md.utils.openmm.create_integrator(\n        config.integrator, config.temperature\n    )\n    simulation = femto.md.utils.openmm.create_simulation(\n        system, topology, coords[0], integrator, state_dicts[0], platform\n    )\n\n    n_states = len(state_dicts)\n\n    swap_mask = {\n        (i, j)\n        for i in range(n_states)\n        for j in range(n_states)\n        if states.direction[i] != states.direction[j]\n    }\n\n    analysis_fn = None\n\n    if reporter is not None and config.analysis_interval is not None:\n        analysis_fn = functools.partial(\n            _analyze, config=config, states=states, reporter=reporter\n        )\n\n    return femto.md.hremd.run_hremd(\n        simulation,\n        state_dicts,\n        config,\n        output_dir,\n        swap_mask,\n        initial_coords=coords,\n        analysis_fn=analysis_fn,\n        analysis_interval=config.analysis_interval,\n    )\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.select_displacement","title":"select_displacement","text":"<pre><code>select_displacement(\n    receptor: Topology,\n    ligand_1: Topology,\n    ligand_2: Topology | None,\n    distance: Quantity,\n) -&gt; Quantity\n</code></pre> <p>Attempts to automatically select a displacement vector for the ligands.</p> <p>Parameters:</p> <ul> <li> <code>receptor</code>               (<code>Topology</code>)           \u2013            <p>The receptor.</p> </li> <li> <code>ligand_1</code>               (<code>Topology</code>)           \u2013            <p>The first ligand positioned in the binding site.</p> </li> <li> <code>ligand_2</code>               (<code>Topology | None</code>)           \u2013            <p>The second ligand positioned in the binding site.</p> </li> <li> <code>distance</code>               (<code>Quantity</code>)           \u2013            <p>The distance to translate ligands along the displacement vector by.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Quantity</code>           \u2013            <p>The displacement vector.</p> </li> </ul> Source code in <code>femto/fe/atm/_setup.py</code> <pre><code>def select_displacement(\n    receptor: mdtop.Topology,\n    ligand_1: mdtop.Topology,\n    ligand_2: mdtop.Topology | None,\n    distance: openmm.unit.Quantity,\n) -&gt; openmm.unit.Quantity:\n    \"\"\"Attempts to automatically select a displacement vector for the ligands.\n\n    Args:\n        receptor: The receptor.\n        ligand_1: The first ligand positioned in the binding site.\n        ligand_2: The second ligand positioned in the binding site.\n        distance: The distance to translate ligands along the displacement vector by.\n\n    Returns:\n        The displacement vector.\n    \"\"\"\n\n    ligand_coords = numpy.vstack(\n        [ligand_1.xyz.value_in_unit(openmm.unit.angstrom)]\n        + (\n            []\n            if ligand_2 is None\n            else [ligand_2.xyz.value_in_unit(openmm.unit.angstrom)]\n        )\n    )\n    receptor_coords = receptor.xyz.value_in_unit(openmm.unit.angstrom)\n\n    directions = numpy.array(\n        [\n            [-1.0, -1.0, -1.0],\n            [+1.0, -1.0, -1.0],\n            [+1.0, +1.0, -1.0],\n            [-1.0, +1.0, -1.0],\n            [-1.0, -1.0, +1.0],\n            [+1.0, -1.0, +1.0],\n            [+1.0, +1.0, +1.0],\n            [-1.0, +1.0, +1.0],\n        ]\n    )\n    directions /= numpy.linalg.norm(directions, axis=1, keepdims=True)\n\n    closest_distances = []\n\n    for direction in directions:\n        displacement = direction * distance.value_in_unit(openmm.unit.angstrom)\n\n        offset_coords = ligand_coords + displacement\n\n        distances = scipy.spatial.distance.cdist(offset_coords, receptor_coords)\n        closest_distances.append(distances.min())\n\n    direction = directions[numpy.argmax(closest_distances)]\n    return direction.flatten() * distance\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.setup_system","title":"setup_system","text":"<pre><code>setup_system(\n    config: ATMSetupStage,\n    receptor: Topology,\n    ligand_1: Topology,\n    ligand_2: Topology | None,\n    cofactors: list[Topology] | None,\n    displacement: Quantity,\n    receptor_ref_query: str | None,\n    ligand_1_ref_query: tuple[str, str, str] | None = None,\n    ligand_2_ref_query: tuple[str, str, str] | None = None,\n    extra_params: list[Path] | None = None,\n) -&gt; tuple[Topology, System]\n</code></pre> <p>Prepares a system ready for running the ATM method.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>ATMSetupStage</code>)           \u2013            <p>The configuration for setting up the system.</p> </li> <li> <code>receptor</code>               (<code>Topology</code>)           \u2013            <p>The receptor topology.</p> </li> <li> <code>ligand_1</code>               (<code>Topology</code>)           \u2013            <p>The first ligand.</p> </li> <li> <code>ligand_2</code>               (<code>Topology | None</code>)           \u2013            <p>The second ligand if one is present.</p> </li> <li> <code>cofactors</code>               (<code>list[Topology] | None</code>)           \u2013            <p>Any cofactors.</p> </li> <li> <code>displacement</code>               (<code>Quantity</code>)           \u2013            <p>The displacement vector to use for the ligands.</p> </li> <li> <code>receptor_ref_query</code>               (<code>str | None</code>)           \u2013            <p>The query to select the receptor reference atoms.</p> </li> <li> <code>ligand_1_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the first ligand reference atoms.</p> </li> <li> <code>ligand_2_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the second ligand reference atoms.</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Topology, System]</code>           \u2013            <p>The prepared topology and OpenMM system object.</p> </li> </ul> Source code in <code>femto/fe/atm/_setup.py</code> <pre><code>def setup_system(\n    config: \"femto.fe.atm.ATMSetupStage\",\n    receptor: mdtop.Topology,\n    ligand_1: mdtop.Topology,\n    ligand_2: mdtop.Topology | None,\n    cofactors: list[mdtop.Topology] | None,\n    displacement: openmm.unit.Quantity,\n    receptor_ref_query: str | None,\n    ligand_1_ref_query: tuple[str, str, str] | None = None,\n    ligand_2_ref_query: tuple[str, str, str] | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n) -&gt; tuple[mdtop.Topology, openmm.System]:\n    \"\"\"Prepares a system ready for running the ATM method.\n\n    Args:\n        config: The configuration for setting up the system.\n        receptor: The receptor topology.\n        ligand_1: The first ligand.\n        ligand_2: The second ligand if one is present.\n        cofactors: Any cofactors.\n        displacement: The displacement vector to use for the ligands.\n        receptor_ref_query: The query to select the receptor reference atoms.\n        ligand_1_ref_query: The query to select the first ligand reference atoms.\n        ligand_2_ref_query: The query to select the second ligand reference atoms.\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n\n    Returns:\n        The prepared topology and OpenMM system object.\n    \"\"\"\n\n    _LOGGER.info(f\"setting up an {'ABFE' if ligand_2 is None else 'RBFE'} calculation\")\n\n    # we carve out a 'cavity' where the first ligand will be displaced into during the\n    # ATM calculations. this should make equilibration at all states easier.\n    cavity_formers = [_offset_ligand(ligand_1, displacement)]\n\n    if ligand_2 is not None:\n        # we make sure that when placing solvent molecules we don't accidentally place\n        # any on top of the ligands in the cavity itself\n        cavity_formers.append(ligand_2)\n        ligand_2 = _offset_ligand(ligand_2, displacement)\n\n    _LOGGER.info(\"preparing system\")\n    topology, system = femto.md.prepare.prepare_system(\n        receptor,\n        ligand_1,\n        ligand_2,\n        cofactors,\n        config,\n        displacement,\n        cavity_formers=cavity_formers,\n        extra_params=extra_params,\n    )\n\n    if config.apply_hmr:\n        _LOGGER.info(\"applying HMR.\")\n        femto.md.prepare.apply_hmr(system, topology, config.hydrogen_mass)\n\n    ligand_1_idxs = topology.select(f\"resn {femto.md.constants.LIGAND_1_RESIDUE_NAME}\")\n    ligand_2_idxs = topology.select(f\"resn {femto.md.constants.LIGAND_2_RESIDUE_NAME}\")\n\n    ligand_1 = topology.subset(ligand_1_idxs)\n    ligand_2 = topology.subset(ligand_2_idxs) if ligand_2 is not None else None\n\n    if config.apply_rest:\n        _LOGGER.info(\"applying REST2.\")\n\n        solute_idxs = {*ligand_1_idxs, *({} if ligand_2 is None else ligand_2_idxs)}\n        femto.md.rest.apply_rest(system, solute_idxs, config.rest_config)\n\n    _LOGGER.info(\"applying restraints.\")\n    ligand_1_ref_idxs, ligand_2_ref_idxs = None, None\n\n    if ligand_2 is not None:\n        (\n            ligand_1_ref_idxs_0,\n            ligand_2_ref_idxs_0,\n        ) = femto.fe.reference.select_ligand_idxs(\n            ligand_1,\n            ligand_2,\n            config.reference.ligand_method,\n            ligand_1_ref_query,\n            ligand_2_ref_query,\n        )\n        assert ligand_2_ref_idxs_0 is not None, \"ligand 2 ref atoms were not selected\"\n\n        ligand_1_ref_idxs = [ligand_1_idxs[i] for i in ligand_1_ref_idxs_0]\n        ligand_2_ref_idxs = [ligand_2_idxs[i] for i in ligand_2_ref_idxs_0]\n\n        _LOGGER.info(f\"ligand 1 ref idxs={ligand_1_idxs}\")\n        _LOGGER.info(f\"ligand 2 ref idxs={ligand_2_idxs}\")\n\n    receptor_start_idx = ligand_1.n_atoms + (\n        0 if ligand_2 is None else ligand_2.n_atoms\n    )\n\n    if receptor_ref_query is not None:\n        receptor_ref_idxs = receptor.select(receptor_ref_query) + receptor_start_idx\n    else:\n        # we need to select the receptor cavity atoms before offsetting any ligands\n        # as the query is distance based\n        receptor_cutoff = config.reference.receptor_cutoff.value_in_unit(\n            openmm.unit.angstrom\n        )\n        receptor_ref_query = (\n            f\"name CA near_to {receptor_cutoff} of \"\n            f\"resn {femto.md.constants.LIGAND_1_RESIDUE_NAME}\"\n        )\n        receptor_ref_idxs = topology.select(receptor_ref_query)\n\n    _LOGGER.info(f\"receptor cavity idxs={receptor_ref_idxs}\")\n\n    _apply_atm_restraints(\n        system,\n        config.restraints,\n        ligand_1_com_idxs=ligand_1_idxs,\n        ligand_1_ref_idxs=ligand_1_ref_idxs,\n        ligand_2_com_idxs=ligand_2_idxs if ligand_2 is not None else None,\n        ligand_2_ref_idxs=ligand_2_ref_idxs,\n        receptor_ref_idxs=receptor_ref_idxs,\n        offset=displacement,\n    )\n\n    restraint_idxs = (\n        receptor.select(config.restraints.receptor_query) + receptor_start_idx\n    )\n    _LOGGER.info(f\"receptor restrained idxs={restraint_idxs}\")\n\n    _apply_receptor_restraints(\n        system, config.restraints, {i: topology.xyz[i] for i in restraint_idxs}\n    )\n\n    femto.md.utils.openmm.assign_force_groups(system)\n\n    return topology, system\n</code></pre>"},{"location":"reference/fe/atm/#femto.fe.atm.create_state_dicts","title":"create_state_dicts","text":"<pre><code>create_state_dicts(\n    states: ATMSamplingStage,\n) -&gt; list[dict[str, float]]\n</code></pre> <p>Map the lambda states specified in the configuration to a list of dictionaries.</p> <p>Parameters:</p> <ul> <li> <code>states</code>               (<code>ATMSamplingStage</code>)           \u2013            <p>The lambda states.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, float]]</code>           \u2013            <p>The dictionaries of lambda states.</p> </li> </ul> Source code in <code>femto/fe/atm/_utils.py</code> <pre><code>def create_state_dicts(\n    states: \"femto.fe.atm.ATMSamplingStage\",\n) -&gt; list[dict[str, float]]:\n    \"\"\"Map the lambda states specified in the configuration to a list of dictionaries.\n\n    Args:\n        states: The lambda states.\n\n    Returns:\n        The dictionaries of lambda states.\n    \"\"\"\n    return [\n        {\n            openmm.ATMForce.Lambda1(): states.lambda_1[i],\n            openmm.ATMForce.Lambda2(): states.lambda_2[i],\n            openmm.ATMForce.Direction(): states.direction[i],\n            openmm.ATMForce.Alpha(): (\n                states.alpha[i] * states.alpha_unit\n            ).value_in_unit(openmm.unit.kilojoules_per_mole**-1),\n            openmm.ATMForce.Uh(): (states.u0[i] * states.u0_unit).value_in_unit(\n                openmm.unit.kilojoules_per_mole\n            ),\n            openmm.ATMForce.W0(): (states.w0[i] * states.w0_unit).value_in_unit(\n                openmm.unit.kilojoules_per_mole\n            ),\n            **(\n                {femto.md.rest.REST_CTX_PARAM: states.bm_b0[i]}\n                if states.bm_b0 is not None\n                else {}\n            ),\n        }\n        for i in range(len(states.lambda_1))\n    ]\n</code></pre>"},{"location":"reference/fe/septop/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> septop","text":""},{"location":"reference/fe/septop/#femto.fe.septop","title":"septop","text":"<p>Automated BFE calculations using the seperated topology method</p> <p>Classes:</p> <ul> <li> <code>SepTopComplexRestraints</code>           \u2013            <p>Configure the restraints to apply in the complex phase.</p> </li> <li> <code>SepTopConfig</code>           \u2013            <p>Configuration a separated topology FE calculation.</p> </li> <li> <code>SepTopEquilibrateStage</code>           \u2013            <p>Configure how the system will be equilibrated prior to replica exchange.</p> </li> <li> <code>SepTopPhaseConfig</code>           \u2013            <p>Configure one phase (i.e. complex or solution) of a separated topology</p> </li> <li> <code>SepTopSamplingStage</code>           \u2013            <p>Configure how the system will be sampled using Hamiltonian replica exchange.</p> </li> <li> <code>SepTopSetupStage</code>           \u2013            <p>Configure how the complex will be solvated and restrained prior to</p> </li> <li> <code>SepTopSolutionRestraints</code>           \u2013            <p>Configure the restraints to apply in the solution phase.</p> </li> <li> <code>SepTopStates</code>           \u2013            <p>Configure the lambda schedules.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>compute_ddg</code>             \u2013              <p>Computes the binding free energy from the complex and solution phase samples.</p> </li> <li> <code>load_config</code>             \u2013              <p>Load a configuration from a YAML file.</p> </li> <li> <code>equilibrate_states</code>             \u2013              <p>Equilibrate the system at each lambda window.</p> </li> <li> <code>run_complex_phase</code>             \u2013              <p>Run the complex phase of the SepTop calculation.</p> </li> <li> <code>run_solution_phase</code>             \u2013              <p>Run the solution phase of the SepTop calculation.</p> </li> <li> <code>submit_network</code>             \u2013              <p>Submits a set of SepTop calculations to an HPC queueing manager.</p> </li> <li> <code>run_hremd</code>             \u2013              <p>Perform replica exchange sampling for a system prepared for SepTop calculations.</p> </li> <li> <code>setup_complex</code>             \u2013              <p>Prepares a system ready for running the SepTop method.</p> </li> <li> <code>setup_solution</code>             \u2013              <p>Prepares a system ready for running the SepTop method.</p> </li> <li> <code>create_state_dicts</code>             \u2013              <p>Map the lambda states specified in the configuration to a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_BORESCH_K_DISTANCE</code>           \u2013            <p>The default force constant of the Boresch distance restraint.</p> </li> <li> <code>DEFAULT_BORESCH_K_THETA</code>           \u2013            <p>The default force constant of the Boresch angle restraint.</p> </li> <li> <code>DEFAULT_EQUILIBRATE_INTEGRATOR</code>           \u2013            <p>The default integrator to use during equilibration.</p> </li> <li> <code>DEFAULT_EQUILIBRATE_RESTRAINTS</code>           \u2013            <p>The default position restraints to apply during equilibration.</p> </li> <li> <code>DEFAULT_LAMBDA_BORESCH_LIGAND_1</code>           \u2013            <p>The default lambda schedule of the Boresch restraint on the first ligand in the</p> </li> <li> <code>DEFAULT_LAMBDA_BORESCH_LIGAND_2</code>           \u2013            <p>The default lambda schedule of the Boresch restraint on the second ligand in the</p> </li> <li> <code>DEFAULT_LAMBDA_CHARGES_1_COMPLEX</code>           \u2013            <p>The default charge lambda schedule of the first ligand in the complex phase.</p> </li> <li> <code>DEFAULT_LAMBDA_CHARGES_1_SOLUTION</code>           \u2013            <p>The default charge lambda schedule of the first ligand in the solution phase.</p> </li> <li> <code>DEFAULT_LAMBDA_CHARGES_2_COMPLEX</code>           \u2013            <p>The default charge lambda schedule of the second ligand in the complex phase.</p> </li> <li> <code>DEFAULT_LAMBDA_CHARGES_2_SOLUTION</code>           \u2013            <p>The default charge lambda schedule of the second ligand in the solution phase.</p> </li> <li> <code>DEFAULT_LAMBDA_VDW_1_COMPLEX</code>           \u2013            <p>The default vdW lambda schedule of the first ligand in the complex phase.</p> </li> <li> <code>DEFAULT_LAMBDA_VDW_1_SOLUTION</code>           \u2013            <p>The default vdW lambda schedule of the first ligand in the solution phase.</p> </li> <li> <code>DEFAULT_LAMBDA_VDW_2_COMPLEX</code>           \u2013            <p>The default vdW lambda schedule of the second ligand in the complex phase.</p> </li> <li> <code>DEFAULT_LAMBDA_VDW_2_SOLUTION</code>           \u2013            <p>The default vdW lambda schedule of the second ligand in the solution phase.</p> </li> <li> <code>DEFAULT_RESTRAINT_MASK</code>           \u2013            <p>The default Amber style selection mask to apply position restraints to.</p> </li> <li> <code>LAMBDA_BORESCH_LIGAND_1</code>           \u2013            <p>The name of the context variable used to control the Boresch-style restraints on the</p> </li> <li> <code>LAMBDA_BORESCH_LIGAND_2</code>           \u2013            <p>The name of the context variable used to control the Boresch-style restraints on the</p> </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_BORESCH_K_DISTANCE","title":"DEFAULT_BORESCH_K_DISTANCE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_BORESCH_K_DISTANCE = 20.0 * _KCAL_PER_ANG_SQR\n</code></pre> <p>The default force constant of the Boresch distance restraint.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_BORESCH_K_THETA","title":"DEFAULT_BORESCH_K_THETA  <code>module-attribute</code>","text":"<pre><code>DEFAULT_BORESCH_K_THETA = 20.0 * _KCAL_PER_RAD_SQR\n</code></pre> <p>The default force constant of the Boresch angle restraint.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_EQUILIBRATE_INTEGRATOR","title":"DEFAULT_EQUILIBRATE_INTEGRATOR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EQUILIBRATE_INTEGRATOR = LangevinIntegrator(\n    timestep=2.0 * femtosecond, friction=1.0 / picosecond\n)\n</code></pre> <p>The default integrator to use during equilibration.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_EQUILIBRATE_RESTRAINTS","title":"DEFAULT_EQUILIBRATE_RESTRAINTS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EQUILIBRATE_RESTRAINTS = {\n    DEFAULT_RESTRAINT_MASK: FlatBottomRestraint(\n        k=25.0 * _KCAL_PER_ANG_SQR, radius=1.5 * _ANGSTROM\n    )\n}\n</code></pre> <p>The default position restraints to apply during equilibration.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_BORESCH_LIGAND_1","title":"DEFAULT_LAMBDA_BORESCH_LIGAND_1  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_BORESCH_LIGAND_1 = (\n    [0.0, 0.05, 0.1, 0.3, 0.5, 0.75, 1.0, 1.0]\n    + [1.0] * 3\n    + [1.0] * 8\n)\n</code></pre> <p>The default lambda schedule of the Boresch restraint on the first ligand in the complex phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_BORESCH_LIGAND_2","title":"DEFAULT_LAMBDA_BORESCH_LIGAND_2  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_BORESCH_LIGAND_2 = (\n    [1.0] * 8\n    + [1.0] * 3\n    + [1.0, 0.95, 0.9, 0.7, 0.5, 0.25, 0.0, 0.0]\n)\n</code></pre> <p>The default lambda schedule of the Boresch restraint on the second ligand in the complex phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_CHARGES_1_COMPLEX","title":"DEFAULT_LAMBDA_CHARGES_1_COMPLEX  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_CHARGES_1_COMPLEX = (\n    [0.0] * 8 + [0.25, 0.5, 0.75] + [1.0] * 8\n)\n</code></pre> <p>The default charge lambda schedule of the first ligand in the complex phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_CHARGES_1_SOLUTION","title":"DEFAULT_LAMBDA_CHARGES_1_SOLUTION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_CHARGES_1_SOLUTION = [\n    0.0,\n    0.125,\n    0.25,\n    0.375,\n    0.5,\n    0.625,\n    0.75,\n    0.875,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n]\n</code></pre> <p>The default charge lambda schedule of the first ligand in the solution phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_CHARGES_2_COMPLEX","title":"DEFAULT_LAMBDA_CHARGES_2_COMPLEX  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_CHARGES_2_COMPLEX = (\n    [1.0] * 8 + [0.75, 0.5, 0.25] + [0.0] * 8\n)\n</code></pre> <p>The default charge lambda schedule of the second ligand in the complex phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_CHARGES_2_SOLUTION","title":"DEFAULT_LAMBDA_CHARGES_2_SOLUTION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_CHARGES_2_SOLUTION = [\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    1.0,\n    0.875,\n    0.75,\n    0.625,\n    0.5,\n    0.375,\n    0.25,\n    0.125,\n    0.0,\n]\n</code></pre> <p>The default charge lambda schedule of the second ligand in the solution phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_VDW_1_COMPLEX","title":"DEFAULT_LAMBDA_VDW_1_COMPLEX  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_VDW_1_COMPLEX = (\n    [0.0] * 8 + [0.0, 0.0, 0.0] + tolist()\n)\n</code></pre> <p>The default vdW lambda schedule of the first ligand in the complex phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_VDW_1_SOLUTION","title":"DEFAULT_LAMBDA_VDW_1_SOLUTION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_VDW_1_SOLUTION = [\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.12,\n    0.24,\n    0.36,\n    0.48,\n    0.6,\n    0.7,\n    0.77,\n    0.85,\n    1.0,\n]\n</code></pre> <p>The default vdW lambda schedule of the first ligand in the solution phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_VDW_2_COMPLEX","title":"DEFAULT_LAMBDA_VDW_2_COMPLEX  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_VDW_2_COMPLEX = (\n    tolist() + [0.0, 0.0, 0.0] + [0.0] * 8\n)\n</code></pre> <p>The default vdW lambda schedule of the second ligand in the complex phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_LAMBDA_VDW_2_SOLUTION","title":"DEFAULT_LAMBDA_VDW_2_SOLUTION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_LAMBDA_VDW_2_SOLUTION = [\n    1.0,\n    0.85,\n    0.77,\n    0.7,\n    0.6,\n    0.48,\n    0.36,\n    0.24,\n    0.12,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n    0.0,\n]\n</code></pre> <p>The default vdW lambda schedule of the second ligand in the solution phase.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.DEFAULT_RESTRAINT_MASK","title":"DEFAULT_RESTRAINT_MASK  <code>module-attribute</code>","text":"<pre><code>DEFAULT_RESTRAINT_MASK = 'not (water or ion or elem H)'\n</code></pre> <p>The default Amber style selection mask to apply position restraints to.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.LAMBDA_BORESCH_LIGAND_1","title":"LAMBDA_BORESCH_LIGAND_1  <code>module-attribute</code>","text":"<pre><code>LAMBDA_BORESCH_LIGAND_1 = 'lambda_boresch_lig_1'\n</code></pre> <p>The name of the context variable used to control the Boresch-style restraints on the first ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.LAMBDA_BORESCH_LIGAND_2","title":"LAMBDA_BORESCH_LIGAND_2  <code>module-attribute</code>","text":"<pre><code>LAMBDA_BORESCH_LIGAND_2 = 'lambda_boresch_lig_2'\n</code></pre> <p>The name of the context variable used to control the Boresch-style restraints on the second ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints","title":"SepTopComplexRestraints  <code>pydantic-model</code>","text":"<p>               Bases: <code>BoreschRestraint</code></p> <p>Configure the restraints to apply in the complex phase.</p> <p>Fields:</p> <ul> <li> <code>scale_k_angle_a</code>                 (<code>bool</code>)             </li> <li> <code>scale_k_angle_b</code>                 (<code>bool</code>)             </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.k_distance","title":"k_distance  <code>pydantic-field</code>","text":"<pre><code>k_distance: OpenMMQuantity[_KCAL_PER_ANG_SQR]\n</code></pre> <p>Force constant [kcal/mol/\u00c5^2] of the harmonic distance restraint between r3 and l1.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.k_angle_a","title":"k_angle_a  <code>pydantic-field</code>","text":"<pre><code>k_angle_a: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic angle restraint on the angle formed by r2, r3, and l1.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.k_angle_b","title":"k_angle_b  <code>pydantic-field</code>","text":"<pre><code>k_angle_b: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic angle restraint on the angle formed by r3, l1, and l2.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.k_dihedral_a","title":"k_dihedral_a  <code>pydantic-field</code>","text":"<pre><code>k_dihedral_a: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic dihedral restraint on the dihedral angle formed by r1, r2, r3, and l1.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.k_dihedral_b","title":"k_dihedral_b  <code>pydantic-field</code>","text":"<pre><code>k_dihedral_b: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic dihedral restraint on the dihedral angle formed by r2, r3, l1, and l2.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.k_dihedral_c","title":"k_dihedral_c  <code>pydantic-field</code>","text":"<pre><code>k_dihedral_c: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic dihedral restraint on the dihedral angle formed by r3, l1, l2, and l3.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.scale_k_angle_a","title":"scale_k_angle_a  <code>pydantic-field</code>","text":"<pre><code>scale_k_angle_a: bool = True\n</code></pre> <p>Whether to scale the force constant for the P2, P1, and L1 angle based on the initial distance between P1 and L1.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.scale_k_angle_b","title":"scale_k_angle_b  <code>pydantic-field</code>","text":"<pre><code>scale_k_angle_b: bool = True\n</code></pre> <p>Whether to scale the force constant for the P1, L1, and L2 angle based on the initial distance between P1 and L1.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopComplexRestraints.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopConfig","title":"SepTopConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration a separated topology FE calculation.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['septop']</code>)             </li> <li> <code>complex</code>                 (<code>SepTopPhaseConfig</code>)             </li> <li> <code>solution</code>                 (<code>SepTopPhaseConfig</code>)             </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopConfig.complex","title":"complex  <code>pydantic-field</code>","text":"<pre><code>complex: SepTopPhaseConfig = SepTopPhaseConfig(\n    setup=SepTopSetupStage(\n        restraints=DEFAULT_COMPLEX_RESTRAINTS\n    ),\n    states=SepTopStates(\n        lambda_vdw_ligand_1=DEFAULT_LAMBDA_VDW_1_COMPLEX,\n        lambda_charges_ligand_1=DEFAULT_LAMBDA_CHARGES_1_COMPLEX,\n        lambda_boresch_ligand_1=DEFAULT_LAMBDA_BORESCH_LIGAND_1,\n        lambda_vdw_ligand_2=DEFAULT_LAMBDA_VDW_2_COMPLEX,\n        lambda_charges_ligand_2=DEFAULT_LAMBDA_CHARGES_2_COMPLEX,\n        lambda_boresch_ligand_2=DEFAULT_LAMBDA_BORESCH_LIGAND_2,\n    ),\n)\n</code></pre> <p>Configure the complex phase calculations.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopConfig.solution","title":"solution  <code>pydantic-field</code>","text":"<pre><code>solution: SepTopPhaseConfig = SepTopPhaseConfig(\n    setup=SepTopSetupStage(\n        box_shape=\"cube\",\n        restraints=DEFAULT_SOLUTION_RESTRAINTS,\n    ),\n    states=SepTopStates(\n        lambda_vdw_ligand_1=DEFAULT_LAMBDA_VDW_1_SOLUTION,\n        lambda_charges_ligand_1=DEFAULT_LAMBDA_CHARGES_1_SOLUTION,\n        lambda_vdw_ligand_2=DEFAULT_LAMBDA_VDW_2_SOLUTION,\n        lambda_charges_ligand_2=DEFAULT_LAMBDA_CHARGES_2_SOLUTION,\n        lambda_boresch_ligand_1=None,\n        lambda_boresch_ligand_2=None,\n    ),\n)\n</code></pre> <p>Configure the solution phase calculations.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopConfig.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopEquilibrateStage","title":"SepTopEquilibrateStage  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure how the system will be equilibrated prior to replica exchange.</p> <p>Fields:</p> <ul> <li> <code>stages</code>                 (<code>list[SimulationStage]</code>)             </li> <li> <code>report_interval</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopEquilibrateStage.report_interval","title":"report_interval  <code>pydantic-field</code>","text":"<pre><code>report_interval: int = 5000\n</code></pre> <p>The number of steps to report energy, volume, etc after.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopEquilibrateStage.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopPhaseConfig","title":"SepTopPhaseConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure one phase (i.e. complex or solution) of a separated topology FE calculation.</p> <p>Fields:</p> <ul> <li> <code>setup</code>                 (<code>SepTopSetupStage</code>)             </li> <li> <code>states</code>                 (<code>SepTopStates</code>)             </li> <li> <code>equilibrate</code>                 (<code>SepTopEquilibrateStage</code>)             </li> <li> <code>sample</code>                 (<code>SepTopSamplingStage</code>)             </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopPhaseConfig.setup","title":"setup  <code>pydantic-field</code>","text":"<pre><code>setup: SepTopSetupStage\n</code></pre> <p>Prepare the system for equilibration.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopPhaseConfig.states","title":"states  <code>pydantic-field</code>","text":"<pre><code>states: SepTopStates\n</code></pre> <p>Configure the lambda schedules.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopPhaseConfig.equilibrate","title":"equilibrate  <code>pydantic-field</code>","text":"<pre><code>equilibrate: SepTopEquilibrateStage = (\n    SepTopEquilibrateStage()\n)\n</code></pre> <p>Equilibrate the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopPhaseConfig.sample","title":"sample  <code>pydantic-field</code>","text":"<pre><code>sample: SepTopSamplingStage = SepTopSamplingStage()\n</code></pre> <p>Sample the system across lambda windows using HREMD.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopPhaseConfig.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage","title":"SepTopSamplingStage  <code>pydantic-model</code>","text":"<p>               Bases: <code>HREMD</code></p> <p>Configure how the system will be sampled using Hamiltonian replica exchange.</p> <p>Fields:</p> <ul> <li> <code>integrator</code>                 (<code>LangevinIntegrator</code>)             </li> <li> <code>pressure</code>                 (<code>OpenMMQuantity[atmosphere] | None</code>)             </li> <li> <code>barostat_frequency</code>                 (<code>int</code>)             </li> <li> <code>analysis_interval</code>                 (<code>int | None</code>)             </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.temperature","title":"temperature  <code>pydantic-field</code>","text":"<pre><code>temperature: OpenMMQuantity[kelvin] = DEFAULT_TEMPERATURE\n</code></pre> <p>The temperature to sample at.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.n_warmup_steps","title":"n_warmup_steps  <code>pydantic-field</code>","text":"<pre><code>n_warmup_steps: int = 150000\n</code></pre> <p>The number of steps to run each replica for before starting hremd trials. All energies gathered during this period will be discarded.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.n_steps_per_cycle","title":"n_steps_per_cycle  <code>pydantic-field</code>","text":"<pre><code>n_steps_per_cycle: int = 1000\n</code></pre> <p>The number of steps to propagate the system by before attempting an exchange.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.n_cycles","title":"n_cycles  <code>pydantic-field</code>","text":"<pre><code>n_cycles: int = 2500\n</code></pre> <p>The number of cycles of 'propagate the system' -&gt; 'exchange replicas' to run.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.max_step_retries","title":"max_step_retries  <code>pydantic-field</code>","text":"<pre><code>max_step_retries: int = 5\n</code></pre> <p>The maximum number of times to attempt to step if a NaN is encountered before raising an exception</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.swap_mode","title":"swap_mode  <code>pydantic-field</code>","text":"<pre><code>swap_mode: HREMDSwapModeLiteral | None = ALL.value\n</code></pre> <p>The mode in which to propose state swaps between replicas. This can either be: 'neighbours', only try and swap adjacent states or ii. 'all', try and swap all states stochastically. If <code>None</code>, no replica exchanges will be attempted.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.max_swaps","title":"max_swaps  <code>pydantic-field</code>","text":"<pre><code>max_swaps: int | None = None\n</code></pre> <p>The maximum number of swap proposals to make if running in 'all' mode. This variable does nothing when running in 'neighbours' mode.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.trajectory_interval","title":"trajectory_interval  <code>pydantic-field</code>","text":"<pre><code>trajectory_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to DCD trajectory files. If <code>None</code>, no trajectories will be saved.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.trajectory_enforce_pbc","title":"trajectory_enforce_pbc  <code>pydantic-field</code>","text":"<pre><code>trajectory_enforce_pbc: bool = False\n</code></pre> <p>Whether to apply periodic boundary conditions when retrieving coordinates for writing to trajectory files.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.checkpoint_interval","title":"checkpoint_interval  <code>pydantic-field</code>","text":"<pre><code>checkpoint_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to checkpoint files. If <code>None</code>, no checkpoints will be saved.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.integrator","title":"integrator  <code>pydantic-field</code>","text":"<pre><code>integrator: LangevinIntegrator = LangevinIntegrator(\n    timestep=4.0 * femtosecond, friction=1.0 / picosecond\n)\n</code></pre> <p>The MD integrator to use.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.pressure","title":"pressure  <code>pydantic-field</code>","text":"<pre><code>pressure: OpenMMQuantity[atmosphere] | None = (\n    DEFAULT_PRESSURE\n)\n</code></pre> <p>The pressure to simulate at, or <code>None</code> to run in NVT.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.barostat_frequency","title":"barostat_frequency  <code>pydantic-field</code>","text":"<pre><code>barostat_frequency: int = 25\n</code></pre> <p>The frequency at which to apply the barostat. This is ignored if <code>pressure</code> is <code>None</code>.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.analysis_interval","title":"analysis_interval  <code>pydantic-field</code>","text":"<pre><code>analysis_interval: int | None = None\n</code></pre> <p>The interval (in number of cycles) between estimating and reporting the free energy. If <code>None</code>, no analysis will be performed.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSamplingStage.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage","title":"SepTopSetupStage  <code>pydantic-model</code>","text":"<p>               Bases: <code>Prepare</code></p> <p>Configure how the complex will be solvated and restrained prior to equilibration</p> <p>Fields:</p> <ul> <li> <code>restraints</code>                 (<code>SepTopComplexRestraints | SepTopSolutionRestraints</code>)             </li> <li> <code>apply_hmr</code>                 (<code>bool</code>)             </li> <li> <code>hydrogen_mass</code>                 (<code>OpenMMQuantity[amu]</code>)             </li> <li> <code>apply_rest</code>                 (<code>bool</code>)             </li> <li> <code>rest_config</code>                 (<code>REST | None</code>)             </li> <li> <code>fep_config</code>                 (<code>FEP</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_rest_config</code>                 \u2192                   <code>rest_config</code> </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.ionic_strength","title":"ionic_strength  <code>pydantic-field</code>","text":"<pre><code>ionic_strength: OpenMMQuantity[molar] = 0.0 * molar\n</code></pre> <p>The total concentration of ions pairs (<code>anion</code> and <code>cation</code>) to add to approximate an ionic strength. This does not include ions that are added to neutralize the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.neutralize","title":"neutralize  <code>pydantic-field</code>","text":"<pre><code>neutralize: bool = True\n</code></pre> <p>Whether to add counter ions to neutralize the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.cation","title":"cation  <code>pydantic-field</code>","text":"<pre><code>cation: Literal['Na+', 'K+'] = 'K+'\n</code></pre> <p>The cation to use when neutralizing the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.anion","title":"anion  <code>pydantic-field</code>","text":"<pre><code>anion: Literal['Cl-'] = 'Cl-'\n</code></pre> <p>The anion to use when neutralizing the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.water_model","title":"water_model  <code>pydantic-field</code>","text":"<pre><code>water_model: Literal['tip3p'] = 'tip3p'\n</code></pre> <p>The water model to use when generating solvent coordinates. The actual force field parameters used for the solvent are determined by the <code>default_protein_ff</code> or any extra parameters provided while preparing the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.default_protein_ff","title":"default_protein_ff  <code>pydantic-field</code>","text":"<pre><code>default_protein_ff: list[str] = [*DEFAULT_OPENMM_FF_SOURCES]\n</code></pre> <p>The default parameters to use when parameterizing the protein, solvent, and ions.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.default_ligand_ff","title":"default_ligand_ff  <code>pydantic-field</code>","text":"<pre><code>default_ligand_ff: str | None = 'openff-2.0.0.offxml'\n</code></pre> <p>The default parameters to apply when parameterizing ligands, or <code>None</code> otherwise. Currently, only the path to an OpenFF <code>offxml</code> file can be specified.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.box_padding","title":"box_padding  <code>pydantic-field</code>","text":"<pre><code>box_padding: OpenMMQuantity[_ANGSTROM] | None = (\n    10.0 * _ANGSTROM\n)\n</code></pre> <p>The minimum distance between any complex atom (including any offset ligands) and the box wall. This option is mutually exclusive with <code>n_waters</code>.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.box_shape","title":"box_shape  <code>pydantic-field</code>","text":"<pre><code>box_shape: Literal['cube', 'cubeoid'] = 'cubeoid'\n</code></pre> <p>The shape of the box to use when solvating the complex, when <code>box_padding</code> is specified.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.n_waters","title":"n_waters  <code>pydantic-field</code>","text":"<pre><code>n_waters: int | None = None\n</code></pre> <p>The number of extra waters to solvate the complex using. This option is mutually exclusive with <code>box_padding</code>.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.restraints","title":"restraints  <code>pydantic-field</code>","text":"<pre><code>restraints: (\n    SepTopComplexRestraints | SepTopSolutionRestraints\n)\n</code></pre> <p>Control how the system should be restrained.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.apply_hmr","title":"apply_hmr  <code>pydantic-field</code>","text":"<pre><code>apply_hmr: bool = True\n</code></pre> <p>Whether to aply hydrogen mass repartitioning to the system.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.hydrogen_mass","title":"hydrogen_mass  <code>pydantic-field</code>","text":"<pre><code>hydrogen_mass: OpenMMQuantity[amu] = 1.5 * amu\n</code></pre> <p>The mass to assign to hydrogen atoms when applying HMR.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.apply_rest","title":"apply_rest  <code>pydantic-field</code>","text":"<pre><code>apply_rest: bool = False\n</code></pre> <p>Whether to prepare the system for REST sampling.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.rest_config","title":"rest_config  <code>pydantic-field</code>","text":"<pre><code>rest_config: REST | None = REST(\n    scale_nonbonded=True,\n    scale_torsions=True,\n    scale_angles=False,\n    scale_bonds=False,\n)\n</code></pre> <p>The REST configuration to use if <code>apply_rest</code> is True.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.fep_config","title":"fep_config  <code>pydantic-field</code>","text":"<pre><code>fep_config: FEP = FEP(ligands_can_interact=False)\n</code></pre> <p>Configure how to alchemically couple the ligands.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSetupStage.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSolutionRestraints","title":"SepTopSolutionRestraints  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure the restraints to apply in the solution phase.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['harmonic']</code>)             </li> <li> <code>k_distance</code>                 (<code>OpenMMQuantity[_KCAL_PER_ANG_SQR]</code>)             </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSolutionRestraints.k_distance","title":"k_distance  <code>pydantic-field</code>","text":"<pre><code>k_distance: OpenMMQuantity[_KCAL_PER_ANG_SQR] = (\n    2.4 * _KCAL_PER_ANG_SQR\n)\n</code></pre> <p>Force constant [kcal/mol/\u00c5^2] of the distance restraint that will separate the ligands during an RBFE calculation.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopSolutionRestraints.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates","title":"SepTopStates  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure the lambda schedules.</p> <p>Fields:</p> <ul> <li> <code>lambda_vdw_ligand_1</code>                 (<code>list[float]</code>)             </li> <li> <code>lambda_vdw_ligand_2</code>                 (<code>list[float] | None</code>)             </li> <li> <code>lambda_charges_ligand_1</code>                 (<code>list[float]</code>)             </li> <li> <code>lambda_charges_ligand_2</code>                 (<code>list[float] | None</code>)             </li> <li> <code>lambda_boresch_ligand_1</code>                 (<code>list[float] | None</code>)             </li> <li> <code>lambda_boresch_ligand_2</code>                 (<code>list[float] | None</code>)             </li> <li> <code>bm_b0</code>                 (<code>list[float] | None</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_lambda_lengths</code> </li> </ul>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.lambda_vdw_ligand_1","title":"lambda_vdw_ligand_1  <code>pydantic-field</code>","text":"<pre><code>lambda_vdw_ligand_1: list[float]\n</code></pre> <p>The vdW lambda schedule of the first ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.lambda_vdw_ligand_2","title":"lambda_vdw_ligand_2  <code>pydantic-field</code>","text":"<pre><code>lambda_vdw_ligand_2: list[float] | None\n</code></pre> <p>The vdW lambda schedule of the second ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.lambda_charges_ligand_1","title":"lambda_charges_ligand_1  <code>pydantic-field</code>","text":"<pre><code>lambda_charges_ligand_1: list[float]\n</code></pre> <p>The charge lambda schedule of the first ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.lambda_charges_ligand_2","title":"lambda_charges_ligand_2  <code>pydantic-field</code>","text":"<pre><code>lambda_charges_ligand_2: list[float] | None\n</code></pre> <p>The charge lambda schedule of the second ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.lambda_boresch_ligand_1","title":"lambda_boresch_ligand_1  <code>pydantic-field</code>","text":"<pre><code>lambda_boresch_ligand_1: list[float] | None\n</code></pre> <p>The lambda schedule of the boresch restraint on the first ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.lambda_boresch_ligand_2","title":"lambda_boresch_ligand_2  <code>pydantic-field</code>","text":"<pre><code>lambda_boresch_ligand_2: list[float] | None\n</code></pre> <p>The lambda schedule of the boresch restraint on the second ligand.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.bm_b0","title":"bm_b0  <code>pydantic-field</code>","text":"<pre><code>bm_b0: list[float] | None = None\n</code></pre> <p>The REST2 beta scaling factors (beta_m / beta_0) to use. Set this to <code>None</code> to disable REST2 scaling.</p>"},{"location":"reference/fe/septop/#femto.fe.septop.SepTopStates.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.compute_ddg","title":"compute_ddg","text":"<pre><code>compute_ddg(\n    config: SepTopConfig,\n    complex_u_kn: ndarray,\n    complex_n_k: ndarray,\n    complex_system: System,\n    solution_u_kn: ndarray,\n    solution_n_k: ndarray,\n    solution_system: System,\n) -&gt; DataFrame\n</code></pre> <p>Computes the binding free energy from the complex and solution phase samples.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopConfig</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>complex_u_kn</code>               (<code>ndarray</code>)           \u2013            <p>The complex phase samples.</p> </li> <li> <code>complex_n_k</code>               (<code>ndarray</code>)           \u2013            <p>The complex phase sample counts.</p> </li> <li> <code>complex_system</code>               (<code>System</code>)           \u2013            <p>The complex phase system.</p> </li> <li> <code>solution_u_kn</code>               (<code>ndarray</code>)           \u2013            <p>The solution phase samples.</p> </li> <li> <code>solution_n_k</code>               (<code>ndarray</code>)           \u2013            <p>The solution phase sample counts.</p> </li> <li> <code>solution_system</code>               (<code>System</code>)           \u2013            <p>The solution phase system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A pandas DataFrame containing the total binding free energy and its components.</p> </li> </ul> Source code in <code>femto/fe/septop/_analyze.py</code> <pre><code>def compute_ddg(\n    config: \"femto.fe.septop.SepTopConfig\",\n    complex_u_kn: numpy.ndarray,\n    complex_n_k: numpy.ndarray,\n    complex_system: openmm.System,\n    solution_u_kn: numpy.ndarray,\n    solution_n_k: numpy.ndarray,\n    solution_system: openmm.System,\n) -&gt; \"pandas.DataFrame\":\n    \"\"\"Computes the binding free energy from the complex and solution phase samples.\n\n    Args:\n        config: The configuration.\n        complex_u_kn: The complex phase samples.\n        complex_n_k: The complex phase sample counts.\n        complex_system: The complex phase system.\n        solution_u_kn: The solution phase samples.\n        solution_n_k: The solution phase sample counts.\n        solution_system: The solution phase system.\n\n    Returns:\n        A pandas DataFrame containing the total binding free energy and its components.\n    \"\"\"\n    import pandas\n\n    import femto.fe.septop\n\n    samples = {\n        \"complex\": (complex_u_kn, complex_n_k),\n        \"solution\": (solution_u_kn, solution_n_k),\n    }\n    results = {}\n\n    for phase in \"complex\", \"solution\":\n        phase_config: femto.fe.septop.SepTopPhaseConfig = getattr(config, phase)\n        phase_u_kn, phase_n_k = samples[phase]\n\n        estimated, _ = femto.fe.ddg.estimate_ddg(\n            phase_u_kn, phase_n_k, phase_config.sample.temperature\n        )\n        del estimated[\"ddG_0_kcal_mol\"]\n        del estimated[\"ddG_0_error_kcal_mol\"]\n\n        results.update({f\"{phase}_{k}\": v for k, v in estimated.items()})\n\n    results.update(compute_complex_correction(config.complex, complex_system))\n    results.update(compute_solution_correction(config.solution, solution_system))\n\n    results[\"ddG_kcal_mol\"] = (\n        results[\"complex_ddG_kcal_mol\"] + results[\"complex_ddG_correction_kcal_mol\"]\n    ) - (results[\"solution_ddG_kcal_mol\"] + results[\"solution_ddG_correction_kcal_mol\"])\n\n    results[\"ddG_error_kcal_mol\"] = numpy.sqrt(\n        results[\"complex_ddG_error_kcal_mol\"] ** 2\n        + results[\"solution_ddG_error_kcal_mol\"] ** 2\n    )\n\n    return pandas.DataFrame([results])\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.load_config","title":"load_config","text":"<pre><code>load_config(path: Path) -&gt; SepTopConfig\n</code></pre> <p>Load a configuration from a YAML file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the YAML configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SepTopConfig</code>           \u2013            <p>The loaded configuration.</p> </li> </ul> Source code in <code>femto/fe/septop/_config.py</code> <pre><code>def load_config(path: pathlib.Path) -&gt; SepTopConfig:\n    \"\"\"Load a configuration from a YAML file.\n\n    Args:\n        path: The path to the YAML configuration.\n\n    Returns:\n        The loaded configuration.\n    \"\"\"\n    return SepTopConfig(**yaml.safe_load(path.read_text()))\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.equilibrate_states","title":"equilibrate_states","text":"<pre><code>equilibrate_states(\n    system: System,\n    topology: Topology,\n    states: SepTopStates,\n    config: SepTopEquilibrateStage,\n    platform: OpenMMPlatform,\n    reporter: Reporter | None = None,\n) -&gt; list[State]\n</code></pre> <p>Equilibrate the system at each lambda window.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology of the system to simulate.</p> </li> <li> <code>states</code>               (<code>SepTopStates</code>)           \u2013            <p>The states of the system to simulate.</p> </li> <li> <code>config</code>               (<code>SepTopEquilibrateStage</code>)           \u2013            <p>Configuration settings.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The accelerator to use.</p> </li> <li> <code>reporter</code>               (<code>Reporter | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) reporter to use to record system statistics such as volume and energy.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[State]</code>           \u2013            <p>The final equilibrated state.</p> </li> </ul> Source code in <code>femto/fe/septop/_equilibrate.py</code> <pre><code>def equilibrate_states(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    states: \"femto.fe.septop.SepTopStates\",\n    config: \"femto.fe.septop.SepTopEquilibrateStage\",\n    platform: femto.md.constants.OpenMMPlatform,\n    reporter: femto.md.reporting.Reporter | None = None,\n) -&gt; list[openmm.State]:\n    \"\"\"Equilibrate the system at each lambda window.\n\n    Args:\n        system: The system to simulate.\n        topology: The topology of the system to simulate.\n        states: The states of the system to simulate.\n        config: Configuration settings.\n        platform: The accelerator to use.\n        reporter: The (optional) reporter to use to record system statistics such as\n            volume and energy.\n\n    Returns:\n        The final equilibrated state.\n    \"\"\"\n    import femto.fe.septop\n\n    reporter = femto.md.reporting.NullReporter() if reporter is None else reporter\n\n    openmm_reporter = femto.md.reporting.openmm.OpenMMStateReporter(\n        reporter, \"equilibration\", config.report_interval\n    )\n\n    state_dicts = femto.fe.septop.create_state_dicts(states, system)\n\n    equilibrated_coords = femto.md.simulate.simulate_states(\n        system, topology, state_dicts, config.stages, platform, openmm_reporter\n    )\n    return equilibrated_coords\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.run_complex_phase","title":"run_complex_phase","text":"<pre><code>run_complex_phase(\n    config: SepTopConfig,\n    ligand_1_path: Path,\n    ligand_2_path: Path | None,\n    receptor_path: Path,\n    cofactor_paths: list[Path] | None,\n    output_dir: Path,\n    report_dir: Path | None = None,\n    ligand_1_ref_atoms: tuple[str, str, str] | None = None,\n    ligand_2_ref_atoms: tuple[str, str, str] | None = None,\n    receptor_ref_atoms: tuple[str, str, str] | None = None,\n    extra_params: list[Path] | None = None,\n)\n</code></pre> <p>Run the complex phase of the SepTop calculation.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopConfig</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>ligand_1_path</code>               (<code>Path</code>)           \u2013            <p>The path to the first ligand.</p> </li> <li> <code>ligand_2_path</code>               (<code>Path | None</code>)           \u2013            <p>The path to the second ligand, if present.</p> </li> <li> <code>receptor_path</code>               (<code>Path</code>)           \u2013            <p>The path to the receptor.</p> </li> <li> <code>cofactor_paths</code>               (<code>list[Path] | None</code>)           \u2013            <p>The paths to any cofactors.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store all outputs in.</p> </li> <li> <code>report_dir</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The directory to store the logs / reports in.</p> </li> <li> <code>ligand_1_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query masks that select the first ligands reference atoms.</p> </li> <li> <code>ligand_2_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query masks that select the second ligands reference atoms.</p> </li> <li> <code>receptor_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query mask that selects the receptor atoms used to align the ligand.</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> Source code in <code>femto/fe/septop/_runner.py</code> <pre><code>def run_complex_phase(\n    config: \"femto.fe.septop.SepTopConfig\",\n    ligand_1_path: pathlib.Path,\n    ligand_2_path: pathlib.Path | None,\n    receptor_path: pathlib.Path,\n    cofactor_paths: list[pathlib.Path] | None,\n    output_dir: pathlib.Path,\n    report_dir: pathlib.Path | None = None,\n    ligand_1_ref_atoms: tuple[str, str, str] | None = None,\n    ligand_2_ref_atoms: tuple[str, str, str] | None = None,\n    receptor_ref_atoms: tuple[str, str, str] | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n):\n    \"\"\"Run the complex phase of the SepTop calculation.\n\n    Args:\n        config: The configuration.\n        ligand_1_path: The path to the first ligand.\n        ligand_2_path: The path to the second ligand, if present.\n        receptor_path: The path to the receptor.\n        cofactor_paths: The paths to any cofactors.\n        output_dir: The directory to store all outputs in.\n        report_dir: The directory to store the logs / reports in.\n        ligand_1_ref_atoms: The AMBER style query masks that select the first ligands\n            reference atoms.\n        ligand_2_ref_atoms: The AMBER style query masks that select the second ligands\n            reference atoms.\n        receptor_ref_atoms: The AMBER style query mask that selects the receptor atoms\n            used to align the ligand.\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n    \"\"\"\n\n    prepare_fn = functools.partial(\n        _prepare_complex_phase,\n        config.complex,\n        receptor_path,\n        ligand_1_path,\n        ligand_2_path,\n        cofactor_paths,\n        ligand_1_ref_atoms,\n        ligand_2_ref_atoms,\n        receptor_ref_atoms,\n        extra_params,\n    )\n    _run_phase(config.complex, prepare_fn, output_dir, report_dir)\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.run_solution_phase","title":"run_solution_phase","text":"<pre><code>run_solution_phase(\n    config: SepTopConfig,\n    ligand_1_path: Path,\n    ligand_2_path: Path | None,\n    output_dir: Path,\n    report_dir: Path | None = None,\n    ligand_1_ref_atoms: tuple[str, str, str] | None = None,\n    ligand_2_ref_atoms: tuple[str, str, str] | None = None,\n    extra_params: list[Path] | None = None,\n)\n</code></pre> <p>Run the solution phase of the SepTop calculation.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopConfig</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>ligand_1_path</code>               (<code>Path</code>)           \u2013            <p>The path to the first ligand.</p> </li> <li> <code>ligand_2_path</code>               (<code>Path | None</code>)           \u2013            <p>The path to the second ligand, if present.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store all outputs in.</p> </li> <li> <code>report_dir</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The directory to store the report in.</p> </li> <li> <code>ligand_1_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query masks that select the first ligands reference atoms.</p> </li> <li> <code>ligand_2_ref_atoms</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The AMBER style query masks that select the second ligands reference atoms.</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> Source code in <code>femto/fe/septop/_runner.py</code> <pre><code>def run_solution_phase(\n    config: \"femto.fe.septop.SepTopConfig\",\n    ligand_1_path: pathlib.Path,\n    ligand_2_path: pathlib.Path | None,\n    output_dir: pathlib.Path,\n    report_dir: pathlib.Path | None = None,\n    ligand_1_ref_atoms: tuple[str, str, str] | None = None,\n    ligand_2_ref_atoms: tuple[str, str, str] | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n):\n    \"\"\"Run the solution phase of the SepTop calculation.\n\n    Args:\n        config: The configuration.\n        ligand_1_path: The path to the first ligand.\n        ligand_2_path: The path to the second ligand, if present.\n        output_dir: The directory to store all outputs in.\n        report_dir: The directory to store the report in.\n        ligand_1_ref_atoms: The AMBER style query masks that select the first ligands\n            reference atoms.\n        ligand_2_ref_atoms: The AMBER style query masks that select the second ligands\n            reference atoms.\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n    \"\"\"\n\n    prepare_fn = functools.partial(\n        _prepare_solution_phase,\n        config.solution,\n        ligand_1_path,\n        ligand_2_path,\n        ligand_1_ref_atoms,\n        ligand_2_ref_atoms,\n        extra_params,\n    )\n    _run_phase(config.solution, prepare_fn, output_dir, report_dir)\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.submit_network","title":"submit_network","text":"<pre><code>submit_network(\n    config: SepTopConfig,\n    network: Network,\n    output_dir: Path,\n    queue_options: SLURMOptions,\n    mpi_command: list[str] | None = None,\n) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Submits a set of SepTop calculations to an HPC queueing manager.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopConfig</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>network</code>               (<code>Network</code>)           \u2013            <p>The network of edges to run.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store any outputs in.</p> </li> <li> <code>queue_options</code>               (<code>SLURMOptions</code>)           \u2013            <p>The options to use when submitting the jobs.</p> </li> <li> <code>mpi_command</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The mpi runner command to use. The default is <code>\"srun --mpi=pmix\"</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[tuple[str, str, str]]</code>           \u2013            <p>The ids of the submitted jobs.</p> </li> </ul> Source code in <code>femto/fe/septop/_runner.py</code> <pre><code>def submit_network(\n    config: \"femto.fe.septop.SepTopConfig\",\n    network: femto.fe.inputs.Network,\n    output_dir: pathlib.Path,\n    queue_options: femto.fe.utils.queue.SLURMOptions,\n    mpi_command: list[str] | None = None,\n) -&gt; list[tuple[str, str, str]]:\n    \"\"\"Submits a set of SepTop calculations to an HPC queueing manager.\n\n    Args:\n        config: The configuration.\n        network: The network of edges to run.\n        output_dir: The directory to store any outputs in.\n        queue_options: The options to use when submitting the jobs.\n        mpi_command: The mpi runner command to use. The default is\n            ``\"srun --mpi=pmix\"``.\n\n    Returns:\n        The ids of the submitted jobs.\n    \"\"\"\n\n    mpi_command = mpi_command if mpi_command is not None else [\"srun\", \"--mpi=pmix\"]\n\n    output_dir.mkdir(exist_ok=True, parents=True)\n\n    date_str = datetime.datetime.now().strftime(\"%Y-%m-%d--%H-%M-%S\")\n    config_path = output_dir / f\"config-{date_str}.yaml\"\n    config_path.write_text(config.model_dump_yaml(sort_keys=False))\n\n    femto_command = [\"femto\", \"septop\", \"--config\", config_path]\n\n    slurm_job_ids = []\n\n    for edge in network.edges:\n        edge_dir = output_dir / f\"{edge.ligand_1.name}~{edge.ligand_2.name}\"\n\n        complex_output_dir = edge_dir / \"complex\"\n        solution_output_dir = edge_dir / \"solution\"\n\n        ligand_args = [\n            *_create_run_flags(edge.ligand_1, \"ligand-1\"),\n            *_create_run_flags(edge.ligand_2, \"ligand-2\"),\n        ]\n\n        run_solution_id = femto.fe.utils.queue.submit_slurm_job(\n            [\n                *mpi_command,\n                *femto_command,\n                \"run-solution\",\n                *ligand_args,\n                f\"--output-dir={solution_output_dir}\",\n                f\"--report-dir={solution_output_dir}\",\n            ],\n            queue_options,\n            edge_dir / f\"run-solution-{date_str}.out\",\n        )\n        run_complex_id = femto.fe.utils.queue.submit_slurm_job(\n            [\n                *mpi_command,\n                *femto_command,\n                \"run-complex\",\n                *_create_run_flags(network.receptor, \"receptor\"),\n                *ligand_args,\n                f\"--output-dir={complex_output_dir}\",\n                f\"--report-dir={complex_output_dir}\",\n            ],\n            queue_options,\n            edge_dir / f\"run-complex-{date_str}.out\",\n        )\n\n        analyze_id = femto.fe.utils.queue.submit_slurm_job(\n            [\n                *femto_command,\n                \"analyze\",\n                \"--complex-samples\",\n                complex_output_dir / \"_sample/samples.arrow\",\n                \"--complex-system\",\n                complex_output_dir / \"_setup/system.xml\",\n                \"--solution-samples\",\n                solution_output_dir / \"_sample/samples.arrow\",\n                \"--solution-system\",\n                solution_output_dir / \"_setup/system.xml\",\n                \"--output\",\n                edge_dir / \"ddg.csv\",\n            ],\n            queue_options,\n            edge_dir / f\"analyze-{date_str}.out\",\n            [run_solution_id, run_complex_id],\n        )\n\n        slurm_job_ids.append((run_solution_id, run_complex_id, analyze_id))\n\n    return slurm_job_ids\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.run_hremd","title":"run_hremd","text":"<pre><code>run_hremd(\n    system: System,\n    topology: Topology,\n    coords: list[State],\n    states: SepTopStates,\n    config: SepTopSamplingStage,\n    platform: OpenMMPlatform,\n    output_dir: Path,\n    reporter: Reporter | None = None,\n)\n</code></pre> <p>Perform replica exchange sampling for a system prepared for SepTop calculations.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology associated with the system.</p> </li> <li> <code>coords</code>               (<code>list[State]</code>)           \u2013            <p>The starting coordinates for each state.</p> </li> <li> <code>states</code>               (<code>SepTopStates</code>)           \u2013            <p>The lambda states to sample.</p> </li> <li> <code>config</code>               (<code>SepTopSamplingStage</code>)           \u2013            <p>Configuration settings.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The platform to run on.</p> </li> <li> <code>output_dir</code>               (<code>Path</code>)           \u2013            <p>The directory to store the sampled energies and statistics to, and any trajectory files if requested.</p> </li> <li> <code>reporter</code>               (<code>Reporter | None</code>, default:                   <code>None</code> )           \u2013            <p>The reporter to log statistics such as online estimates of the free energy to.</p> </li> </ul> Source code in <code>femto/fe/septop/_sample.py</code> <pre><code>def run_hremd(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    coords: list[openmm.State],\n    states: \"femto.fe.septop.SepTopStates\",\n    config: \"femto.fe.septop.SepTopSamplingStage\",\n    platform: femto.md.constants.OpenMMPlatform,\n    output_dir: pathlib.Path,\n    reporter: femto.md.reporting.Reporter | None = None,\n):\n    \"\"\"Perform replica exchange sampling for a system prepared for SepTop calculations.\n\n    Args:\n        system: The system.\n        topology: The topology associated with the system.\n        coords: The starting coordinates for each state.\n        states: The lambda states to sample.\n        config: Configuration settings.\n        platform: The platform to run on.\n        output_dir: The directory to store the sampled energies and statistics to, and\n            any trajectory files if requested.\n        reporter: The reporter to log statistics such as online estimates of the\n            free energy to.\n    \"\"\"\n    import femto.fe.septop\n\n    system = copy.deepcopy(system)\n\n    n_barostats = sum(\n        1\n        for force in system.getForces()\n        if isinstance(force, openmm.MonteCarloBarostat)\n    )\n    if n_barostats &gt; 0:\n        raise RuntimeError(\"the system should not contain a barostat already\")\n\n    if config.pressure is not None:\n        barostat = openmm.MonteCarloBarostat(\n            config.pressure, config.temperature, config.barostat_frequency\n        )\n        system.addForce(barostat)\n\n    femto.md.utils.openmm.assign_force_groups(system)\n\n    state_dicts = femto.fe.septop.create_state_dicts(states, system)\n\n    integrator = femto.md.utils.openmm.create_integrator(\n        config.integrator, config.temperature\n    )\n    simulation = femto.md.utils.openmm.create_simulation(\n        system, topology, coords[0], integrator, state_dicts[0], platform\n    )\n\n    analysis_fn = None\n\n    if reporter is not None and config.analysis_interval is not None:\n        analysis_fn = functools.partial(_analyze, config=config, reporter=reporter)\n\n    return femto.md.hremd.run_hremd(\n        simulation,\n        state_dicts,\n        config,\n        output_dir,\n        initial_coords=coords,\n        analysis_fn=analysis_fn,\n        analysis_interval=config.analysis_interval,\n    )\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.setup_complex","title":"setup_complex","text":"<pre><code>setup_complex(\n    config: SepTopSetupStage,\n    receptor: Topology,\n    ligand_1: Topology,\n    ligand_2: Topology | None,\n    cofactors: list[Topology] | None,\n    receptor_ref_query: tuple[str, str, str] | None = None,\n    ligand_1_ref_query: tuple[str, str, str] | None = None,\n    ligand_2_ref_query: tuple[str, str, str] | None = None,\n    extra_params: list[Path] | None = None,\n) -&gt; tuple[Topology, System]\n</code></pre> <p>Prepares a system ready for running the SepTop method.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopSetupStage</code>)           \u2013            <p>The configuration for setting up the system.</p> </li> <li> <code>receptor</code>               (<code>Topology</code>)           \u2013            <p>The receptor.</p> </li> <li> <code>ligand_1</code>               (<code>Topology</code>)           \u2013            <p>The first ligand.</p> </li> <li> <code>ligand_2</code>               (<code>Topology | None</code>)           \u2013            <p>The second ligand if one is present.</p> </li> <li> <code>cofactors</code>               (<code>list[Topology] | None</code>)           \u2013            <p>Any cofactors.</p> </li> <li> <code>receptor_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the reference atoms of the receptor.</p> </li> <li> <code>ligand_1_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the reference atoms of the first ligand.</p> </li> <li> <code>ligand_2_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the reference atoms of the second ligand</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Topology, System]</code>           \u2013            <p>The prepared topology and OpenMM system object.</p> </li> </ul> Source code in <code>femto/fe/septop/_setup.py</code> <pre><code>def setup_complex(\n    config: \"femto.fe.septop.SepTopSetupStage\",\n    receptor: mdtop.Topology,\n    ligand_1: mdtop.Topology,\n    ligand_2: mdtop.Topology | None,\n    cofactors: list[mdtop.Topology] | None,\n    receptor_ref_query: tuple[str, str, str] | None = None,\n    ligand_1_ref_query: tuple[str, str, str] | None = None,\n    ligand_2_ref_query: tuple[str, str, str] | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n) -&gt; tuple[mdtop.Topology, openmm.System]:\n    \"\"\"Prepares a system ready for running the SepTop method.\n\n    Args:\n        config: The configuration for setting up the system.\n        receptor: The receptor.\n        ligand_1: The first ligand.\n        ligand_2: The second ligand if one is present.\n        cofactors: Any cofactors.\n        receptor_ref_query: The query to select the reference atoms of the receptor.\n        ligand_1_ref_query: The query to select the reference atoms of the first ligand.\n        ligand_2_ref_query: The query to select the reference atoms of the second ligand\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n\n    Returns:\n        The prepared topology and OpenMM system object.\n    \"\"\"\n    import femto.fe.septop\n\n    if not isinstance(config.restraints, femto.fe.septop.SepTopComplexRestraints):\n        raise ValueError(\"invalid restraint config\")\n\n    system, topology, ligand_1_ref_idxs, ligand_2_ref_idxs = _setup_system(\n        config,\n        ligand_1,\n        ligand_2,\n        receptor,\n        cofactors,\n        ligand_1_ref_query,\n        ligand_2_ref_query,\n        None,\n        extra_params,\n    )\n\n    _LOGGER.info(\"applying restraints.\")\n\n    if receptor_ref_query is None:\n        _LOGGER.info(\"selecting receptor reference atoms\")\n\n        receptor_ref_idxs_1 = femto.fe.reference.select_receptor_idxs(\n            topology, ligand_1_ref_idxs\n        )\n    else:\n        receptor_ref_idxs_1 = femto.fe.reference.queries_to_idxs(\n            receptor, receptor_ref_query\n        )\n\n        ligand_idxs = topology.select(\n            f\"resn {femto.md.constants.LIGAND_1_RESIDUE_NAME} | \"\n            f\"resn {femto.md.constants.LIGAND_2_RESIDUE_NAME}\"\n        )\n        receptor_start_idx = 0 if len(ligand_idxs) == 0 else (max(ligand_idxs) + 1)\n        receptor_ref_idxs_1 = tuple(v + receptor_start_idx for v in receptor_ref_idxs_1)\n\n    _LOGGER.info(f\"receptor ref idxs for ligand 1={receptor_ref_idxs_1}\")\n\n    _apply_complex_restraints(\n        topology,\n        receptor_ref_idxs_1,\n        ligand_1_ref_idxs,\n        config.restraints,\n        system,\n        LAMBDA_BORESCH_LIGAND_1,\n    )\n\n    if ligand_2 is None:\n        return topology, system\n\n    receptor_ref_idxs_2 = receptor_ref_idxs_1\n\n    if receptor_ref_query is None and femto.fe.reference.check_receptor_idxs(\n        topology, receptor_ref_idxs_2, ligand_2_ref_idxs\n    ):\n        _LOGGER.info(\"selecting alternate receptor reference atoms for ligand 2\")\n\n        receptor_ref_idxs_2 = femto.fe.reference.select_receptor_idxs(\n            topology, ligand_2_ref_idxs\n        )\n\n    _LOGGER.info(f\"receptor ref idxs for ligand 2={receptor_ref_idxs_2}\")\n\n    _apply_complex_restraints(\n        topology,\n        receptor_ref_idxs_2,\n        ligand_2_ref_idxs,\n        config.restraints,\n        system,\n        LAMBDA_BORESCH_LIGAND_2,\n    )\n    return topology, system\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.setup_solution","title":"setup_solution","text":"<pre><code>setup_solution(\n    config: SepTopSetupStage,\n    ligand_1: Topology,\n    ligand_2: Topology | None,\n    ligand_1_ref_query: tuple[str, str, str] | None = None,\n    ligand_2_ref_query: tuple[str, str, str] | None = None,\n    extra_params: list[Path] | None = None,\n) -&gt; tuple[Topology, System]\n</code></pre> <p>Prepares a system ready for running the SepTop method.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopSetupStage</code>)           \u2013            <p>The configuration for setting up the system.</p> </li> <li> <code>ligand_1</code>               (<code>Topology</code>)           \u2013            <p>The first ligand.</p> </li> <li> <code>ligand_2</code>               (<code>Topology | None</code>)           \u2013            <p>The second ligand if one is present.</p> </li> <li> <code>ligand_1_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the reference atoms of the first ligand.</p> </li> <li> <code>ligand_2_ref_query</code>               (<code>tuple[str, str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The query to select the reference atoms of the second ligand</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Topology, System]</code>           \u2013            <p>The prepared topology and OpenMM system object.</p> </li> </ul> Source code in <code>femto/fe/septop/_setup.py</code> <pre><code>def setup_solution(\n    config: \"femto.fe.septop.SepTopSetupStage\",\n    ligand_1: mdtop.Topology,\n    ligand_2: mdtop.Topology | None,\n    ligand_1_ref_query: tuple[str, str, str] | None = None,\n    ligand_2_ref_query: tuple[str, str, str] | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n) -&gt; tuple[mdtop.Topology, openmm.System]:\n    \"\"\"Prepares a system ready for running the SepTop method.\n\n    Args:\n        config: The configuration for setting up the system.\n        ligand_1: The first ligand.\n        ligand_2: The second ligand if one is present.\n        ligand_1_ref_query: The query to select the reference atoms of the first ligand.\n        ligand_2_ref_query: The query to select the reference atoms of the second ligand\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n\n    Returns:\n        The prepared topology and OpenMM system object.\n    \"\"\"\n    import femto.fe.septop\n\n    config = copy.deepcopy(config)\n\n    if config.box_padding is None:\n        raise NotImplementedError(\"box padding must be set for solution phase\")\n\n    restraint_config = config.restraints\n\n    if not isinstance(restraint_config, femto.fe.septop.SepTopSolutionRestraints):\n        raise ValueError(\"invalid restraint config\")\n\n    if ligand_2 is not None:\n        ligand_2.xyz += _compute_ligand_offset(ligand_1, ligand_2)\n\n    system, topology, ligand_1_ref_idxs, ligand_2_ref_idxs = _setup_system(\n        config,\n        ligand_1,\n        ligand_2,\n        None,\n        None,\n        ligand_1_ref_query,\n        ligand_2_ref_query,\n        None,\n        extra_params,\n    )\n\n    if ligand_2 is not None:\n        _apply_solution_restraints(\n            topology,\n            ligand_1_ref_idxs[1],\n            ligand_2_ref_idxs[1],\n            config.restraints,\n            system,\n        )\n    femto.md.utils.openmm.assign_force_groups(system)\n\n    return topology, system\n</code></pre>"},{"location":"reference/fe/septop/#femto.fe.septop.create_state_dicts","title":"create_state_dicts","text":"<pre><code>create_state_dicts(\n    config: SepTopStates, system: System\n) -&gt; list[dict[str, float]]\n</code></pre> <p>Map the lambda states specified in the configuration to a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>SepTopStates</code>)           \u2013            <p>The configuration.</p> </li> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system being simulated.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, float]]</code>           \u2013            <p>The dictionary of lambda states.</p> </li> </ul> Source code in <code>femto/fe/septop/_utils.py</code> <pre><code>def create_state_dicts(\n    config: \"femto.fe.septop.SepTopStates\", system: openmm.System\n) -&gt; list[dict[str, float]]:\n    \"\"\"Map the lambda states specified in the configuration to a dictionary.\n\n    Args:\n        config: The configuration.\n        system: The system being simulated.\n\n    Returns:\n        The dictionary of lambda states.\n    \"\"\"\n    from femto.fe.septop import LAMBDA_BORESCH_LIGAND_1, LAMBDA_BORESCH_LIGAND_2\n\n    states = [\n        {\n            LAMBDA_VDW_LIGAND_1: config.lambda_vdw_ligand_1[i],\n            LAMBDA_CHARGES_LIGAND_1: config.lambda_charges_ligand_1[i],\n            **(\n                {LAMBDA_VDW_LIGAND_2: config.lambda_vdw_ligand_2[i]}\n                if config.lambda_vdw_ligand_2 is not None\n                else {}\n            ),\n            **(\n                {LAMBDA_CHARGES_LIGAND_2: config.lambda_charges_ligand_2[i]}\n                if config.lambda_charges_ligand_2 is not None\n                else {}\n            ),\n            **(\n                {LAMBDA_BORESCH_LIGAND_1: config.lambda_boresch_ligand_1[i]}\n                if config.lambda_boresch_ligand_1 is not None\n                else {}\n            ),\n            **(\n                {LAMBDA_BORESCH_LIGAND_2: config.lambda_boresch_ligand_2[i]}\n                if config.lambda_boresch_ligand_2 is not None\n                else {}\n            ),\n            **(\n                {femto.md.rest.REST_CTX_PARAM: config.bm_b0[i]}\n                if config.bm_b0 is not None\n                else {}\n            ),\n        }\n        for i in range(len(config.lambda_vdw_ligand_1))\n    ]\n\n    return [\n        femto.md.utils.openmm.evaluate_ctx_parameters(state, system) for state in states\n    ]\n</code></pre>"},{"location":"reference/fe/utils/","title":"Index","text":""},{"location":"reference/fe/utils/#femto.fe.utils","title":"utils","text":"<p>Common utilities.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Utilities for defining CLIs</p> </li> <li> <code>queue</code>           \u2013            <p>Utilities for interacting with HPC queues</p> </li> </ul>"},{"location":"reference/fe/utils/cli/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cli","text":""},{"location":"reference/fe/utils/cli/#femto.fe.utils.cli","title":"cli","text":"<p>Utilities for defining CLIs</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>generate_slurm_cli_options</code>             \u2013              <p>A helper function to generate the default set of options to add to a CLI</p> </li> <li> <code>add_options</code>             \u2013              <p>Apply a list of options / arguments to a function</p> </li> <li> <code>validate_mutually_exclusive_groups</code>             \u2013              <p>Checks whether the user tried to specify options from two mutually exclusive</p> </li> <li> <code>configure_logging</code>             \u2013              <p>Set up basic logging for the CLI, silencing any overly verbose modules.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_MAIN_OPTIONS</code>           \u2013            <p>The default set of click options to expose on the main command groups.</p> </li> </ul>"},{"location":"reference/fe/utils/cli/#femto.fe.utils.cli.DEFAULT_MAIN_OPTIONS","title":"DEFAULT_MAIN_OPTIONS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_MAIN_OPTIONS = [\n    option(\n        \"-v\",\n        \"--verbose\",\n        \"log_level\",\n        help=\"Log debug messages\",\n        flag_value=DEBUG,\n    ),\n    option(\n        \"-s\",\n        \"--silent\",\n        \"log_level\",\n        help=\"Log only warning messages\",\n        flag_value=WARNING,\n    ),\n]\n</code></pre> <p>The default set of click options to expose on the main command groups.</p>"},{"location":"reference/fe/utils/cli/#femto.fe.utils.cli.generate_slurm_cli_options","title":"generate_slurm_cli_options","text":"<pre><code>generate_slurm_cli_options(\n    job_name: str | None, required: bool = False\n) -&gt; list\n</code></pre> <p>A helper function to generate the default set of options to add to a CLI function that will submit SLURM jobs.</p> <p>Parameters:</p> <ul> <li> <code>job_name</code>               (<code>str | None</code>)           \u2013            <p>The default job name to use.</p> </li> <li> <code>required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether options without defaults should be required or not.</p> </li> </ul> <p>Returns     A list of click options.</p> Source code in <code>femto/fe/utils/cli.py</code> <pre><code>def generate_slurm_cli_options(job_name: str | None, required: bool = False) -&gt; list:\n    \"\"\"A helper function to generate the default set of options to add to a CLI\n    function that will submit SLURM jobs.\n\n    Args:\n        job_name: The default job name to use.\n        required: Whether options without defaults should be required or not.\n\n    Returns\n        A list of click options.\n    \"\"\"\n    options = []\n\n    for (\n        field_name,\n        field,\n    ) in femto.fe.utils.queue.SLURMOptions.model_fields.items():\n        description = field.description\n\n        default_value = field.default\n        has_default = (\n            default_value is not Ellipsis\n            and default_value != pydantic_core.PydanticUndefined\n        )\n\n        if job_name is not None and field_name == \"job_name\":\n            has_default = True\n            default_value = job_name\n\n        flag = f\"--slurm-{field_name}\".replace(\"_\", \"-\").replace(\"-n-\", \"-\")\n        field_type = field.annotation\n\n        if isinstance(field_type, types.UnionType):\n            type_args = typing.get_args(field_type)\n            assert len(type_args) == 2 and types.NoneType in type_args\n\n            required = False\n            field_type = (\n                type_args[0]  # noqa: E721\n                if type_args[1] is types.NoneType  # noqa: E721\n                else type_args[1]  # noqa: E721\n            )\n\n        options.append(\n            click.option(\n                flag,\n                f\"slurm_{field_name}\",\n                help=description,\n                type=field_type,\n                required=required and not has_default,\n                default=None if not has_default else default_value,\n                show_default=has_default,\n            )\n        )\n\n    return options\n</code></pre>"},{"location":"reference/fe/utils/cli/#femto.fe.utils.cli.add_options","title":"add_options","text":"<pre><code>add_options(options)\n</code></pre> <p>Apply a list of options / arguments to a function</p> Source code in <code>femto/fe/utils/cli.py</code> <pre><code>def add_options(options):\n    \"\"\"Apply a list of options / arguments to a function\"\"\"\n\n    options = options if isinstance(options, typing.Iterable) else [options]\n\n    def _apply_options(func):\n        for option in reversed(options):\n            func = option(func)\n        return func\n\n    return _apply_options\n</code></pre>"},{"location":"reference/fe/utils/cli/#femto.fe.utils.cli.validate_mutually_exclusive_groups","title":"validate_mutually_exclusive_groups","text":"<pre><code>validate_mutually_exclusive_groups(\n    context: Context,\n    group_1_titles: list[str] | str,\n    group_2_titles: list[str] | str,\n    optional_fields: set[str] | None = None,\n) -&gt; tuple[bool, bool]\n</code></pre> <p>Checks whether the user tried to specify options from two mutually exclusive sets of option groups.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The click context.</p> </li> <li> <code>group_1_titles</code>               (<code>list[str] | str</code>)           \u2013            <p>The titles of the first groups.</p> </li> <li> <code>group_2_titles</code>               (<code>list[str] | str</code>)           \u2013            <p>The titles of the second groups.</p> </li> <li> <code>optional_fields</code>               (<code>set[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A set of fields that are optional and do not have default values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[bool, bool]</code>           \u2013            <p>Whether the user specified options from group 1 and group 2, respectively.</p> </li> </ul> Source code in <code>femto/fe/utils/cli.py</code> <pre><code>def validate_mutually_exclusive_groups(\n    context: cloup.Context,\n    group_1_titles: list[str] | str,\n    group_2_titles: list[str] | str,\n    optional_fields: set[str] | None = None,\n) -&gt; tuple[bool, bool]:\n    \"\"\"Checks whether the user tried to specify options from two mutually exclusive\n    sets of option groups.\n\n    Args:\n        context: The click context.\n        group_1_titles: The titles of the first groups.\n        group_2_titles: The titles of the second groups.\n        optional_fields: A set of fields that are optional and do not have default\n            values.\n\n    Returns:\n        Whether the user specified options from group 1 and group 2, respectively.\n    \"\"\"\n    optional_fields = set() if optional_fields is None else optional_fields\n\n    group_1_titles = (\n        [group_1_titles] if isinstance(group_1_titles, str) else group_1_titles\n    )\n    group_2_titles = (\n        [group_2_titles] if isinstance(group_2_titles, str) else group_2_titles\n    )\n\n    command = typing.cast(cloup.Command, context.command)\n\n    group_1_matches = [\n        group for group in command.option_groups if group.title in group_1_titles\n    ]\n    assert len(group_1_matches) == len(\n        group_1_titles\n    ), f\"found {len(group_1_matches)} group 1 matches.\"\n\n    group_2_matches = [\n        group for group in command.option_groups if group.title in group_2_titles\n    ]\n    assert len(group_2_matches) == len(\n        group_2_titles\n    ), f\"found {len(group_2_matches)} group 2 matches.\"\n\n    group_1 = group_1_matches[0]\n    group_1_options = [option.name for option in group_1.options]\n    group_2 = group_2_matches[0]\n    group_2_options = [option.name for option in group_2.options]\n\n    found_group_1_options = any(\n        context.get_parameter_source(option) != click.core.ParameterSource.DEFAULT\n        for option in group_1_options\n    )\n    found_group_2_options = any(\n        context.get_parameter_source(option) != click.core.ParameterSource.DEFAULT\n        for option in group_2_options\n    )\n\n    if found_group_1_options and found_group_2_options:\n        raise click.UsageError(\n            f\"Options from the {group_1_titles} and {group_2_titles} option groups are \"\n            f\"mutually exclusive.\"\n        )\n    if not found_group_1_options and not found_group_2_options:\n        raise click.UsageError(\n            f\"Options from either the {group_1_titles} or {group_2_titles} option \"\n            f\"groups must be specified.\"\n        )\n\n    required_options = group_1.options if found_group_1_options else group_2.options\n\n    for option in required_options:\n        value = context.params[option.name]\n\n        if option.name in optional_fields or value is not None:\n            continue\n\n        raise click.MissingParameter(ctx=context, param=option)\n\n    return found_group_1_options, found_group_2_options\n</code></pre>"},{"location":"reference/fe/utils/cli/#femto.fe.utils.cli.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(log_level: int | None)\n</code></pre> <p>Set up basic logging for the CLI, silencing any overly verbose modules.</p> <p>Parameters:</p> <ul> <li> <code>log_level</code>               (<code>int | None</code>)           \u2013            <p>The log level to use.</p> </li> </ul> Source code in <code>femto/fe/utils/cli.py</code> <pre><code>def configure_logging(log_level: int | None):\n    \"\"\"Set up basic logging for the CLI, silencing any overly verbose modules.\n\n    Args:\n        log_level: The log level to use.\n    \"\"\"\n\n    logging.basicConfig(\n        level=log_level if log_level is not None else logging.INFO,\n        format=\"%(asctime)s [%(levelname)s] %(name)s - %(message)s\",\n        datefmt=\"%c\",\n    )\n    logging.getLogger(\"parmed\").setLevel(logging.WARNING)\n    logging.getLogger(\"numexpr\").setLevel(logging.WARNING)\n    logging.getLogger(\"pymbar\").setLevel(logging.WARNING)\n    logging.getLogger(\"jax\").setLevel(logging.ERROR)\n</code></pre>"},{"location":"reference/fe/utils/queue/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> queue","text":""},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue","title":"queue","text":"<p>Utilities for interacting with HPC queues</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>SLURMOptions</code>           \u2013            <p>Options for a Slurm job submission.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>submit_slurm_job</code>             \u2013              <p>Submit a set of SLURM jobs to the queue</p> </li> <li> <code>cancel_slurm_jobs</code>             \u2013              <p>Cancel a set of SLURM jobs</p> </li> <li> <code>wait_for_slurm_jobs</code>             \u2013              <p>Wait for a set of SLURM jobs to finish, or attempt to cancel them if the</p> </li> </ul>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions","title":"SLURMOptions  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for a Slurm job submission.</p> <p>Fields:</p> <ul> <li> <code>n_nodes</code>                 (<code>int</code>)             </li> <li> <code>n_tasks</code>                 (<code>int</code>)             </li> <li> <code>n_cpus_per_task</code>                 (<code>int</code>)             </li> <li> <code>n_gpus_per_task</code>                 (<code>int</code>)             </li> <li> <code>walltime</code>                 (<code>str</code>)             </li> <li> <code>partition</code>                 (<code>str</code>)             </li> <li> <code>account</code>                 (<code>str | None</code>)             </li> <li> <code>job_name</code>                 (<code>str</code>)             </li> <li> <code>reservation</code>                 (<code>str | None</code>)             </li> </ul>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.n_nodes","title":"n_nodes  <code>pydantic-field</code>","text":"<pre><code>n_nodes: int\n</code></pre> <p>The number of nodes to request.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.n_tasks","title":"n_tasks  <code>pydantic-field</code>","text":"<pre><code>n_tasks: int\n</code></pre> <p>The number of tasks to request.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.n_cpus_per_task","title":"n_cpus_per_task  <code>pydantic-field</code>","text":"<pre><code>n_cpus_per_task: int = 1\n</code></pre> <p>The cpus per task.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.n_gpus_per_task","title":"n_gpus_per_task  <code>pydantic-field</code>","text":"<pre><code>n_gpus_per_task: int = 1\n</code></pre> <p>The number of gpus to request per task.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.walltime","title":"walltime  <code>pydantic-field</code>","text":"<pre><code>walltime: str = '5-0'\n</code></pre> <p>The maximum walltime.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.partition","title":"partition  <code>pydantic-field</code>","text":"<pre><code>partition: str\n</code></pre> <p>The partition to run on.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.account","title":"account  <code>pydantic-field</code>","text":"<pre><code>account: str | None = None\n</code></pre> <p>The account to use.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.job_name","title":"job_name  <code>pydantic-field</code>","text":"<pre><code>job_name: str = 'femto'\n</code></pre> <p>The job name to use.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.reservation","title":"reservation  <code>pydantic-field</code>","text":"<pre><code>reservation: str | None = None\n</code></pre> <p>The reservation to use.</p>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.SLURMOptions.to_flags","title":"to_flags","text":"<pre><code>to_flags() -&gt; list[str]\n</code></pre> <p>Convert this options to a list of sbatch / srun flags.</p> Source code in <code>femto/fe/utils/queue.py</code> <pre><code>def to_flags(self) -&gt; list[str]:\n    \"\"\"Convert this options to a list of sbatch / srun flags.\"\"\"\n\n    return [\n        f\"--nodes={self.n_nodes}\",\n        f\"--ntasks={self.n_tasks}\",\n        f\"--gpus-per-task={self.n_gpus_per_task}\",\n        f\"--cpus-per-task={self.n_cpus_per_task}\",\n        f\"--partition={self.partition}\",\n        f\"--time={self.walltime}\",\n        f\"--job-name={self.job_name}\",\n        *([f\"--account={self.account}\"] if self.account is not None else []),\n        *(\n            [f\"--reservation={self.reservation}\"]\n            if self.reservation is not None\n            else []\n        ),\n    ]\n</code></pre>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.submit_slurm_job","title":"submit_slurm_job","text":"<pre><code>submit_slurm_job(\n    command: list[str],\n    options: SLURMOptions,\n    log_file: Path,\n    dependencies: list[str] | None = None,\n) -&gt; str\n</code></pre> <p>Submit a set of SLURM jobs to the queue</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>list[str]</code>)           \u2013            <p>The command to run.</p> </li> <li> <code>options</code>               (<code>SLURMOptions</code>)           \u2013            <p>The SLURM options to use.</p> </li> <li> <code>log_file</code>               (<code>Path</code>)           \u2013            <p>The file to write the SLURM output to.</p> </li> <li> <code>dependencies</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of SLURM job IDs to wait for before running this job.</p> </li> </ul> Source code in <code>femto/fe/utils/queue.py</code> <pre><code>def submit_slurm_job(\n    command: list[str],\n    options: SLURMOptions,\n    log_file: pathlib.Path,\n    dependencies: list[str] | None = None,\n) -&gt; str:\n    \"\"\"Submit a set of SLURM jobs to the queue\n\n    Args:\n        command: The command to run.\n        options: The SLURM options to use.\n        log_file: The file to write the SLURM output to.\n        dependencies: A list of SLURM job IDs to wait for before running this job.\n    \"\"\"\n\n    log_file.parent.mkdir(parents=True, exist_ok=True)\n\n    slurm_args = [f\"--output={log_file}\", *options.to_flags(), \"--parsable\"]\n\n    if dependencies is not None and len(dependencies) &gt; 0:\n        slurm_args.append(\"--dependency=afterok:\" + \",\".join(dependencies))\n        slurm_args.append(\"--kill-on-invalid-dep=yes\")\n\n    command_str = shlex.join(\n        str(arg) if isinstance(arg, pathlib.Path) else arg for arg in command\n    )\n    run_args = [\"sbatch\", *slurm_args, \"--wrap\", command_str]\n\n    result = subprocess.run(run_args, capture_output=True, text=True, check=True)\n    result.check_returncode()\n\n    job_id = result.stdout.strip().strip(\"\\n\")\n\n    return job_id\n</code></pre>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.cancel_slurm_jobs","title":"cancel_slurm_jobs","text":"<pre><code>cancel_slurm_jobs(job_ids: Iterable[str])\n</code></pre> <p>Cancel a set of SLURM jobs</p> <p>Parameters:</p> <ul> <li> <code>job_ids</code>               (<code>Iterable[str]</code>)           \u2013            <p>The IDs of the jobs to cancel.</p> </li> </ul> Source code in <code>femto/fe/utils/queue.py</code> <pre><code>def cancel_slurm_jobs(job_ids: typing.Iterable[str]):\n    \"\"\"Cancel a set of SLURM jobs\n\n    Args:\n        job_ids: The IDs of the jobs to cancel.\n    \"\"\"\n\n    subprocess.run([\"scancel\", *job_ids])\n</code></pre>"},{"location":"reference/fe/utils/queue/#femto.fe.utils.queue.wait_for_slurm_jobs","title":"wait_for_slurm_jobs","text":"<pre><code>wait_for_slurm_jobs(job_ids: Iterable[str])\n</code></pre> <p>Wait for a set of SLURM jobs to finish, or attempt to cancel them if the program fails before they do.</p> Source code in <code>femto/fe/utils/queue.py</code> <pre><code>def wait_for_slurm_jobs(job_ids: typing.Iterable[str]):\n    \"\"\"Wait for a set of SLURM jobs to finish, or attempt to cancel them if the\n    program fails before they do.\"\"\"\n\n    original_signal_handlers = {\n        signal.SIGINT: signal.getsignal(signal.SIGINT),\n        signal.SIGTERM: signal.getsignal(signal.SIGTERM),\n    }\n\n    cleanup_func = functools.partial(_cancel_slurm_job_and_exit, job_ids=job_ids)\n\n    for signal_code in original_signal_handlers:\n        signal.signal(signal_code, cleanup_func)\n\n    try:\n        remaining_job_ids = {*job_ids}\n\n        while True:\n            result = subprocess.run(\n                [\"squeue\", \"--job\", \",\".join(remaining_job_ids)],\n                capture_output=True,\n                text=True,\n            )\n\n            if result.returncode != 0:\n                _LOGGER.warning(result.stdout)\n                _LOGGER.warning(result.stderr)\n                signal.raise_signal(signal.SIGTERM)\n\n            finished_jobs = {\n                job_id for job_id in remaining_job_ids if job_id not in result.stdout\n            }\n            remaining_job_ids -= finished_jobs\n\n            if len(remaining_job_ids) == 0:\n                break\n\n            time.sleep(5.0)\n\n    finally:\n        for signal_code in original_signal_handlers:\n            signal.signal(signal_code, original_signal_handlers[signal_code])\n</code></pre>"},{"location":"reference/md/","title":"Index","text":""},{"location":"reference/md/#femto.md","title":"md","text":"<p>Run MD simulations using OpenMM.</p> <p>Modules:</p> <ul> <li> <code>anneal</code>           \u2013            <p>Perform annealing of the temperature and/or global context parameters.</p> </li> <li> <code>config</code>           \u2013            <p>Common configuration models.</p> </li> <li> <code>constants</code>           \u2013            <p>Constant values such as common force groups and names.</p> </li> <li> <code>hremd</code>           \u2013            <p>Perform Hamiltonian replica exchange sampling.</p> </li> <li> <code>prepare</code>           \u2013            <p>Preparing systems ready for simulation.</p> </li> <li> <code>reporting</code>           \u2013            <p>Reporters for state and statistics</p> </li> <li> <code>rest</code>           \u2013            <p>Prepare a system for REST sampling.</p> </li> <li> <code>restraints</code>           \u2013            <p>Create OpenMM restraint forces.</p> </li> <li> <code>simulate</code>           \u2013            <p>Run OpenMM simulations.</p> </li> <li> <code>tests</code>           \u2013            </li> <li> <code>utils</code>           \u2013            <p>Common utilities.</p> </li> </ul>"},{"location":"reference/md/anneal/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> anneal","text":""},{"location":"reference/md/anneal/#femto.md.anneal","title":"anneal","text":"<p>Perform annealing of the temperature and/or global context parameters.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>anneal_temperature</code>             \u2013              <p>Gradually ramp the system temperature from a starting value to the final value.</p> </li> <li> <code>anneal_state</code>             \u2013              <p>Gradually anneal from an initial state (i.e. set of global context parameters)</p> </li> </ul>"},{"location":"reference/md/anneal/#femto.md.anneal.anneal_temperature","title":"anneal_temperature","text":"<pre><code>anneal_temperature(\n    simulation: Simulation,\n    temperature_initial: Quantity,\n    temperature_final: Quantity,\n    n_steps: int,\n    frequency: int,\n)\n</code></pre> <p>Gradually ramp the system temperature from a starting value to the final value.</p> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>Simulation</code>)           \u2013            <p>The current simulation.</p> </li> <li> <code>temperature_initial</code>               (<code>Quantity</code>)           \u2013            <p>The initial temperature.</p> </li> <li> <code>temperature_final</code>               (<code>Quantity</code>)           \u2013            <p>The final temperature.</p> </li> <li> <code>n_steps</code>               (<code>int</code>)           \u2013            <p>The number of steps to anneal over.</p> </li> <li> <code>frequency</code>               (<code>int</code>)           \u2013            <p>The frequency at which to increment the temperature.</p> </li> </ul> Source code in <code>femto/md/anneal.py</code> <pre><code>def anneal_temperature(\n    simulation: openmm.app.Simulation,\n    temperature_initial: openmm.unit.Quantity,\n    temperature_final: openmm.unit.Quantity,\n    n_steps: int,\n    frequency: int,\n):\n    \"\"\"Gradually ramp the system temperature from a starting value to the final value.\n\n    Args:\n        simulation: The current simulation.\n        temperature_initial: The initial temperature.\n        temperature_final: The final temperature.\n        n_steps: The number of steps to anneal over.\n        frequency: The frequency at which to increment the temperature.\n    \"\"\"\n\n    n_increments = n_steps // frequency\n    increment = (temperature_final - temperature_initial) / n_increments\n\n    temperature = temperature_initial\n    _set_temperature(simulation.integrator, temperature)\n\n    for _ in range(n_increments):\n        simulation.step(frequency)\n\n        temperature += increment\n        _set_temperature(simulation.integrator, temperature)\n\n    _set_temperature(simulation.integrator, temperature_final)\n</code></pre>"},{"location":"reference/md/anneal/#femto.md.anneal.anneal_state","title":"anneal_state","text":"<pre><code>anneal_state(\n    simulation: Simulation,\n    state_initial: dict[str, float],\n    state_final: dict[str, float],\n    n_steps: int,\n    frequency: int,\n)\n</code></pre> <p>Gradually anneal from an initial state (i.e. set of global context parameters) to a final one.</p> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>Simulation</code>)           \u2013            <p>The current simulation.</p> </li> <li> <code>state_initial</code>               (<code>dict[str, float]</code>)           \u2013            <p>The initial state.</p> </li> <li> <code>state_final</code>               (<code>dict[str, float]</code>)           \u2013            <p>The final state.</p> </li> <li> <code>n_steps</code>               (<code>int</code>)           \u2013            <p>The number of steps to anneal over.</p> </li> <li> <code>frequency</code>               (<code>int</code>)           \u2013            <p>The frequency at which to update the state.</p> </li> </ul> Source code in <code>femto/md/anneal.py</code> <pre><code>def anneal_state(\n    simulation: openmm.app.Simulation,\n    state_initial: dict[str, float],\n    state_final: dict[str, float],\n    n_steps: int,\n    frequency: int,\n):\n    \"\"\"Gradually anneal from an initial state (i.e. set of global context parameters)\n    to a final one.\n\n    Args:\n        simulation: The current simulation.\n        state_initial: The initial state.\n        state_final: The final state.\n        n_steps: The number of steps to anneal over.\n        frequency: The frequency at which to update the state.\n    \"\"\"\n\n    n_increments = n_steps // frequency\n\n    state_initial = femto.md.utils.openmm.evaluate_ctx_parameters(\n        state_initial, simulation.system\n    )\n    state_final = femto.md.utils.openmm.evaluate_ctx_parameters(\n        state_final, simulation.system\n    )\n\n    state = {**state_initial}\n\n    increments = {\n        key: (state_final[key] - state_initial[key]) / n_increments\n        for key in state_initial\n    }\n\n    for key in state:\n        simulation.context.setParameter(key, state[key])\n\n    for _ in range(n_increments):\n        simulation.step(frequency)\n\n        for key in state:\n            state[key] += increments[key]\n            simulation.context.setParameter(key, state[key])\n\n    for key in state:\n        simulation.context.setParameter(key, state_final[key])\n</code></pre>"},{"location":"reference/md/config/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> config","text":""},{"location":"reference/md/config/#femto.md.config","title":"config","text":"<p>Common configuration models.</p> <p>Classes:</p> <ul> <li> <code>FlatBottomRestraint</code>           \u2013            <p>Configuration for a flat bottom restraint.</p> </li> <li> <code>BoreschRestraint</code>           \u2013            <p>Configuration for a Boresch style restraint between three receptor atoms</p> </li> <li> <code>Prepare</code>           \u2013            <p>Configuration for preparing a system for simulation.</p> </li> <li> <code>LangevinIntegrator</code>           \u2013            <p>Configuration for a Langevin integrator.</p> </li> <li> <code>REST</code>           \u2013            <p>Configure REST2 setup.</p> </li> <li> <code>Minimization</code>           \u2013            <p>Configuration for a minimization.</p> </li> <li> <code>Simulation</code>           \u2013            <p>Configuration for an MD simulation.</p> </li> <li> <code>Anneal</code>           \u2013            <p>Configuration for a temperature annealing NVT MD simulation.</p> </li> <li> <code>HREMDSwapMode</code>           \u2013            <p>The mode in which to propose state swaps between replicas.</p> </li> <li> <code>HREMD</code>           \u2013            <p>Configuration for Hamiltonian replica exchange sampling</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>merge_configs</code>             \u2013              <p>Merge multiple configurations together.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>DEFAULT_TEMPERATURE</code>           \u2013            <p>The default temperature to simulate at</p> </li> <li> <code>DEFAULT_PRESSURE</code>           \u2013            <p>The default pressure to simulate at</p> </li> <li> <code>DEFAULT_OPENMM_FF_SOURCES</code>           \u2013            <p>The default parameter files to load when parameterizing the solvent / receptor</p> </li> </ul>"},{"location":"reference/md/config/#femto.md.config.DEFAULT_TEMPERATURE","title":"DEFAULT_TEMPERATURE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_TEMPERATURE = 298.15 * kelvin\n</code></pre> <p>The default temperature to simulate at</p>"},{"location":"reference/md/config/#femto.md.config.DEFAULT_PRESSURE","title":"DEFAULT_PRESSURE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_PRESSURE = 1.0 * bar\n</code></pre> <p>The default pressure to simulate at</p>"},{"location":"reference/md/config/#femto.md.config.DEFAULT_OPENMM_FF_SOURCES","title":"DEFAULT_OPENMM_FF_SOURCES  <code>module-attribute</code>","text":"<pre><code>DEFAULT_OPENMM_FF_SOURCES = [\n    \"amber/protein.ff14SB.xml\",\n    \"amber/tip3p_standard.xml\",\n    \"amber/tip3p_HFE_multivalent.xml\",\n]\n</code></pre> <p>The default parameter files to load when parameterizing the solvent / receptor</p>"},{"location":"reference/md/config/#femto.md.config.FlatBottomRestraint","title":"FlatBottomRestraint  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a flat bottom restraint.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['flat-bottom']</code>)             </li> <li> <code>k</code>                 (<code>OpenMMQuantity[_KCAL_PER_ANG_SQR]</code>)             </li> <li> <code>radius</code>                 (<code>OpenMMQuantity[_ANGSTROM]</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.FlatBottomRestraint.k","title":"k  <code>pydantic-field</code>","text":"<pre><code>k: OpenMMQuantity[_KCAL_PER_ANG_SQR]\n</code></pre> <p>Force constant [kcal/mol/\u00c5^2] of the restraint.</p>"},{"location":"reference/md/config/#femto.md.config.FlatBottomRestraint.radius","title":"radius  <code>pydantic-field</code>","text":"<pre><code>radius: OpenMMQuantity[_ANGSTROM]\n</code></pre> <p>The radius [\u00c5] of the restraint.</p>"},{"location":"reference/md/config/#femto.md.config.FlatBottomRestraint.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint","title":"BoreschRestraint  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a Boresch style restraint between three receptor atoms (r1, r2, r3) and three ligand atoms (l1, l2, l3).</p> See Also <p><code>femto.md.restraints.create_boresch_restraint</code></p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['boresch']</code>)             </li> <li> <code>k_distance</code>                 (<code>OpenMMQuantity[_KCAL_PER_ANG_SQR]</code>)             </li> <li> <code>k_angle_a</code>                 (<code>OpenMMQuantity[_KCAL_PER_RAD_SQR]</code>)             </li> <li> <code>k_angle_b</code>                 (<code>OpenMMQuantity[_KCAL_PER_RAD_SQR]</code>)             </li> <li> <code>k_dihedral_a</code>                 (<code>OpenMMQuantity[_KCAL_PER_RAD_SQR]</code>)             </li> <li> <code>k_dihedral_b</code>                 (<code>OpenMMQuantity[_KCAL_PER_RAD_SQR]</code>)             </li> <li> <code>k_dihedral_c</code>                 (<code>OpenMMQuantity[_KCAL_PER_RAD_SQR]</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.k_distance","title":"k_distance  <code>pydantic-field</code>","text":"<pre><code>k_distance: OpenMMQuantity[_KCAL_PER_ANG_SQR]\n</code></pre> <p>Force constant [kcal/mol/\u00c5^2] of the harmonic distance restraint between r3 and l1.</p>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.k_angle_a","title":"k_angle_a  <code>pydantic-field</code>","text":"<pre><code>k_angle_a: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic angle restraint on the angle formed by r2, r3, and l1.</p>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.k_angle_b","title":"k_angle_b  <code>pydantic-field</code>","text":"<pre><code>k_angle_b: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic angle restraint on the angle formed by r3, l1, and l2.</p>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.k_dihedral_a","title":"k_dihedral_a  <code>pydantic-field</code>","text":"<pre><code>k_dihedral_a: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic dihedral restraint on the dihedral angle formed by r1, r2, r3, and l1.</p>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.k_dihedral_b","title":"k_dihedral_b  <code>pydantic-field</code>","text":"<pre><code>k_dihedral_b: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic dihedral restraint on the dihedral angle formed by r2, r3, l1, and l2.</p>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.k_dihedral_c","title":"k_dihedral_c  <code>pydantic-field</code>","text":"<pre><code>k_dihedral_c: OpenMMQuantity[_KCAL_PER_RAD_SQR]\n</code></pre> <p>Force constant [kcal/mol/rad^2] of the harmonic dihedral restraint on the dihedral angle formed by r3, l1, l2, and l3.</p>"},{"location":"reference/md/config/#femto.md.config.BoreschRestraint.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.Prepare","title":"Prepare  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for preparing a system for simulation.</p> <p>Fields:</p> <ul> <li> <code>ionic_strength</code>                 (<code>OpenMMQuantity[molar]</code>)             </li> <li> <code>neutralize</code>                 (<code>bool</code>)             </li> <li> <code>cation</code>                 (<code>Literal['Na+', 'K+']</code>)             </li> <li> <code>anion</code>                 (<code>Literal['Cl-']</code>)             </li> <li> <code>water_model</code>                 (<code>Literal['tip3p']</code>)             </li> <li> <code>default_protein_ff</code>                 (<code>list[str]</code>)             </li> <li> <code>default_ligand_ff</code>                 (<code>str | None</code>)             </li> <li> <code>box_padding</code>                 (<code>OpenMMQuantity[_ANGSTROM] | None</code>)             </li> <li> <code>box_shape</code>                 (<code>Literal['cube', 'cubeoid']</code>)             </li> <li> <code>n_waters</code>                 (<code>int | None</code>)             </li> </ul> <p>Validators:</p> <ul> <li> <code>_validate_n_waters</code> </li> </ul>"},{"location":"reference/md/config/#femto.md.config.Prepare.ionic_strength","title":"ionic_strength  <code>pydantic-field</code>","text":"<pre><code>ionic_strength: OpenMMQuantity[molar] = 0.0 * molar\n</code></pre> <p>The total concentration of ions pairs (<code>anion</code> and <code>cation</code>) to add to approximate an ionic strength. This does not include ions that are added to neutralize the system.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.neutralize","title":"neutralize  <code>pydantic-field</code>","text":"<pre><code>neutralize: bool = True\n</code></pre> <p>Whether to add counter ions to neutralize the system.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.cation","title":"cation  <code>pydantic-field</code>","text":"<pre><code>cation: Literal['Na+', 'K+'] = 'K+'\n</code></pre> <p>The cation to use when neutralizing the system.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.anion","title":"anion  <code>pydantic-field</code>","text":"<pre><code>anion: Literal['Cl-'] = 'Cl-'\n</code></pre> <p>The anion to use when neutralizing the system.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.water_model","title":"water_model  <code>pydantic-field</code>","text":"<pre><code>water_model: Literal['tip3p'] = 'tip3p'\n</code></pre> <p>The water model to use when generating solvent coordinates. The actual force field parameters used for the solvent are determined by the <code>default_protein_ff</code> or any extra parameters provided while preparing the system.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.default_protein_ff","title":"default_protein_ff  <code>pydantic-field</code>","text":"<pre><code>default_protein_ff: list[str] = [*DEFAULT_OPENMM_FF_SOURCES]\n</code></pre> <p>The default parameters to use when parameterizing the protein, solvent, and ions.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.default_ligand_ff","title":"default_ligand_ff  <code>pydantic-field</code>","text":"<pre><code>default_ligand_ff: str | None = 'openff-2.0.0.offxml'\n</code></pre> <p>The default parameters to apply when parameterizing ligands, or <code>None</code> otherwise. Currently, only the path to an OpenFF <code>offxml</code> file can be specified.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.box_padding","title":"box_padding  <code>pydantic-field</code>","text":"<pre><code>box_padding: OpenMMQuantity[_ANGSTROM] | None = (\n    10.0 * _ANGSTROM\n)\n</code></pre> <p>The minimum distance between any complex atom (including any offset ligands) and the box wall. This option is mutually exclusive with <code>n_waters</code>.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.box_shape","title":"box_shape  <code>pydantic-field</code>","text":"<pre><code>box_shape: Literal['cube', 'cubeoid'] = 'cubeoid'\n</code></pre> <p>The shape of the box to use when solvating the complex, when <code>box_padding</code> is specified.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.n_waters","title":"n_waters  <code>pydantic-field</code>","text":"<pre><code>n_waters: int | None = None\n</code></pre> <p>The number of extra waters to solvate the complex using. This option is mutually exclusive with <code>box_padding</code>.</p>"},{"location":"reference/md/config/#femto.md.config.Prepare.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.LangevinIntegrator","title":"LangevinIntegrator  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a Langevin integrator.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['langevin']</code>)             </li> <li> <code>timestep</code>                 (<code>OpenMMQuantity[picosecond]</code>)             </li> <li> <code>friction</code>                 (<code>OpenMMQuantity[picosecond ** -1]</code>)             </li> <li> <code>constraint_tolerance</code>                 (<code>float</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.LangevinIntegrator.timestep","title":"timestep  <code>pydantic-field</code>","text":"<pre><code>timestep: OpenMMQuantity[picosecond] = 0.002 * picosecond\n</code></pre> <p>The timestep to use.</p>"},{"location":"reference/md/config/#femto.md.config.LangevinIntegrator.friction","title":"friction  <code>pydantic-field</code>","text":"<pre><code>friction: OpenMMQuantity[picosecond**-1] = 0.5 / picosecond\n</code></pre> <p>The friction coefficient.</p>"},{"location":"reference/md/config/#femto.md.config.LangevinIntegrator.constraint_tolerance","title":"constraint_tolerance  <code>pydantic-field</code>","text":"<pre><code>constraint_tolerance: float = 1e-06\n</code></pre> <p>The tolerance with which constraints are maintained.</p>"},{"location":"reference/md/config/#femto.md.config.LangevinIntegrator.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.REST","title":"REST  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configure REST2 setup.</p> <p>Fields:</p> <ul> <li> <code>scale_bonds</code>                 (<code>bool</code>)             </li> <li> <code>scale_angles</code>                 (<code>bool</code>)             </li> <li> <code>scale_torsions</code>                 (<code>bool</code>)             </li> <li> <code>scale_nonbonded</code>                 (<code>bool</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.REST.scale_bonds","title":"scale_bonds  <code>pydantic-field</code>","text":"<pre><code>scale_bonds: bool = False\n</code></pre> <p>Whether to scale bond force constants by <code>beta_m / beta_0</code>.</p>"},{"location":"reference/md/config/#femto.md.config.REST.scale_angles","title":"scale_angles  <code>pydantic-field</code>","text":"<pre><code>scale_angles: bool = False\n</code></pre> <p>Whether to scale angle force constants by <code>beta_m / beta_0</code>.</p>"},{"location":"reference/md/config/#femto.md.config.REST.scale_torsions","title":"scale_torsions  <code>pydantic-field</code>","text":"<pre><code>scale_torsions: bool = True\n</code></pre> <p>Whether to scale torsion barrier heights  by <code>beta_m / beta_0</code>.</p>"},{"location":"reference/md/config/#femto.md.config.REST.scale_nonbonded","title":"scale_nonbonded  <code>pydantic-field</code>","text":"<pre><code>scale_nonbonded: bool = True\n</code></pre> <p>Whether to scale non-bonded epsilons by <code>beta_m / beta_0</code> and charges by <code>sqrt(beta_m / beta_0)</code>.</p>"},{"location":"reference/md/config/#femto.md.config.REST.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.Minimization","title":"Minimization  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a minimization.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['minimization']</code>)             </li> <li> <code>restraints</code>                 (<code>dict[str, FlatBottomRestraint]</code>)             </li> <li> <code>tolerance</code>                 (<code>OpenMMQuantity[_KCAL_PER_MOL / _ANGSTROM]</code>)             </li> <li> <code>max_iterations</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.Minimization.restraints","title":"restraints  <code>pydantic-field</code>","text":"<pre><code>restraints: dict[str, FlatBottomRestraint] = {}\n</code></pre> <p>The position restraints to apply during the minimization. The keys should be AMBER style selection masks.</p>"},{"location":"reference/md/config/#femto.md.config.Minimization.tolerance","title":"tolerance  <code>pydantic-field</code>","text":"<pre><code>tolerance: OpenMMQuantity[_KCAL_PER_MOL / _ANGSTROM] = (\n    10.0 * _KCAL_PER_MOL / _ANGSTROM\n)\n</code></pre> <p>Minimization will be halted once the root-mean-square value of all force components reaches this tolerance.</p>"},{"location":"reference/md/config/#femto.md.config.Minimization.max_iterations","title":"max_iterations  <code>pydantic-field</code>","text":"<pre><code>max_iterations: int = 0\n</code></pre> <p>The maximum number of iterations to perform. If 0, minimization will continue until the tolerance is met.</p>"},{"location":"reference/md/config/#femto.md.config.Minimization.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.Simulation","title":"Simulation  <code>pydantic-model</code>","text":"<p>               Bases: <code>_SimulationStep</code></p> <p>Configuration for an MD simulation.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['simulation']</code>)             </li> <li> <code>temperature</code>                 (<code>OpenMMQuantity[kelvin]</code>)             </li> <li> <code>pressure</code>                 (<code>OpenMMQuantity[atmospheres] | None</code>)             </li> <li> <code>barostat_frequency</code>                 (<code>int</code>)             </li> <li> <code>n_steps</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.Simulation.integrator","title":"integrator  <code>pydantic-field</code>","text":"<pre><code>integrator: LangevinIntegrator\n</code></pre> <p>The integrator to use during the simulation.</p>"},{"location":"reference/md/config/#femto.md.config.Simulation.restraints","title":"restraints  <code>pydantic-field</code>","text":"<pre><code>restraints: dict[str, FlatBottomRestraint] = {}\n</code></pre> <p>The position restraints to apply during the minimization. The keys should be AMBER style selection masks.</p>"},{"location":"reference/md/config/#femto.md.config.Simulation.temperature","title":"temperature  <code>pydantic-field</code>","text":"<pre><code>temperature: OpenMMQuantity[kelvin]\n</code></pre> <p>The temperature to simulate at.</p>"},{"location":"reference/md/config/#femto.md.config.Simulation.pressure","title":"pressure  <code>pydantic-field</code>","text":"<pre><code>pressure: OpenMMQuantity[atmospheres] | None\n</code></pre> <p>The pressure to simulate at, or none to run in NVT.</p>"},{"location":"reference/md/config/#femto.md.config.Simulation.barostat_frequency","title":"barostat_frequency  <code>pydantic-field</code>","text":"<pre><code>barostat_frequency: int = 25\n</code></pre> <p>The frequency at which to apply the barostat. This is ignored if <code>pressure</code> is <code>None</code>.</p>"},{"location":"reference/md/config/#femto.md.config.Simulation.n_steps","title":"n_steps  <code>pydantic-field</code>","text":"<pre><code>n_steps: int\n</code></pre> <p>The number of steps to simulate for.</p>"},{"location":"reference/md/config/#femto.md.config.Simulation.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.Anneal","title":"Anneal  <code>pydantic-model</code>","text":"<p>               Bases: <code>_SimulationStep</code></p> <p>Configuration for a temperature annealing NVT MD simulation.</p> <p>Fields:</p> <ul> <li> <code>type</code>                 (<code>Literal['anneal']</code>)             </li> <li> <code>temperature_initial</code>                 (<code>OpenMMQuantity[kelvin]</code>)             </li> <li> <code>temperature_final</code>                 (<code>OpenMMQuantity[kelvin]</code>)             </li> <li> <code>n_steps</code>                 (<code>int</code>)             </li> <li> <code>frequency</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.Anneal.integrator","title":"integrator  <code>pydantic-field</code>","text":"<pre><code>integrator: LangevinIntegrator\n</code></pre> <p>The integrator to use during the simulation.</p>"},{"location":"reference/md/config/#femto.md.config.Anneal.restraints","title":"restraints  <code>pydantic-field</code>","text":"<pre><code>restraints: dict[str, FlatBottomRestraint] = {}\n</code></pre> <p>The position restraints to apply during the minimization. The keys should be AMBER style selection masks.</p>"},{"location":"reference/md/config/#femto.md.config.Anneal.temperature_initial","title":"temperature_initial  <code>pydantic-field</code>","text":"<pre><code>temperature_initial: OpenMMQuantity[kelvin]\n</code></pre> <p>The starting temperature to simulate at.</p>"},{"location":"reference/md/config/#femto.md.config.Anneal.temperature_final","title":"temperature_final  <code>pydantic-field</code>","text":"<pre><code>temperature_final: OpenMMQuantity[kelvin]\n</code></pre> <p>The final temperature to simulate at.</p>"},{"location":"reference/md/config/#femto.md.config.Anneal.n_steps","title":"n_steps  <code>pydantic-field</code>","text":"<pre><code>n_steps: int\n</code></pre> <p>The number of steps to simulate for.</p>"},{"location":"reference/md/config/#femto.md.config.Anneal.frequency","title":"frequency  <code>pydantic-field</code>","text":"<pre><code>frequency: int\n</code></pre> <p>The frequency at which to increment the temperature.</p>"},{"location":"reference/md/config/#femto.md.config.Anneal.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.HREMDSwapMode","title":"HREMDSwapMode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The mode in which to propose state swaps between replicas.</p> <ul> <li><code>NEIGHBOURS</code>: Only allow swapping the current state with neighbouring states.</li> <li><code>ALL</code>: Allow swapping the current state with any other state.</li> </ul>"},{"location":"reference/md/config/#femto.md.config.HREMD","title":"HREMD  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for Hamiltonian replica exchange sampling</p> <p>Fields:</p> <ul> <li> <code>temperature</code>                 (<code>OpenMMQuantity[kelvin]</code>)             </li> <li> <code>n_warmup_steps</code>                 (<code>int</code>)             </li> <li> <code>n_steps_per_cycle</code>                 (<code>int</code>)             </li> <li> <code>n_cycles</code>                 (<code>int</code>)             </li> <li> <code>max_step_retries</code>                 (<code>int</code>)             </li> <li> <code>swap_mode</code>                 (<code>HREMDSwapModeLiteral | None</code>)             </li> <li> <code>max_swaps</code>                 (<code>int | None</code>)             </li> <li> <code>trajectory_interval</code>                 (<code>int | None</code>)             </li> <li> <code>trajectory_enforce_pbc</code>                 (<code>bool</code>)             </li> <li> <code>checkpoint_interval</code>                 (<code>int | None</code>)             </li> </ul>"},{"location":"reference/md/config/#femto.md.config.HREMD.temperature","title":"temperature  <code>pydantic-field</code>","text":"<pre><code>temperature: OpenMMQuantity[kelvin] = DEFAULT_TEMPERATURE\n</code></pre> <p>The temperature to sample at.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.n_warmup_steps","title":"n_warmup_steps  <code>pydantic-field</code>","text":"<pre><code>n_warmup_steps: int = 150000\n</code></pre> <p>The number of steps to run each replica for before starting hremd trials. All energies gathered during this period will be discarded.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.n_steps_per_cycle","title":"n_steps_per_cycle  <code>pydantic-field</code>","text":"<pre><code>n_steps_per_cycle: int = 1000\n</code></pre> <p>The number of steps to propagate the system by before attempting an exchange.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.n_cycles","title":"n_cycles  <code>pydantic-field</code>","text":"<pre><code>n_cycles: int = 2500\n</code></pre> <p>The number of cycles of 'propagate the system' -&gt; 'exchange replicas' to run.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.max_step_retries","title":"max_step_retries  <code>pydantic-field</code>","text":"<pre><code>max_step_retries: int = 5\n</code></pre> <p>The maximum number of times to attempt to step if a NaN is encountered before raising an exception</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.swap_mode","title":"swap_mode  <code>pydantic-field</code>","text":"<pre><code>swap_mode: HREMDSwapModeLiteral | None = ALL.value\n</code></pre> <p>The mode in which to propose state swaps between replicas. This can either be: 'neighbours', only try and swap adjacent states or ii. 'all', try and swap all states stochastically. If <code>None</code>, no replica exchanges will be attempted.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.max_swaps","title":"max_swaps  <code>pydantic-field</code>","text":"<pre><code>max_swaps: int | None = None\n</code></pre> <p>The maximum number of swap proposals to make if running in 'all' mode. This variable does nothing when running in 'neighbours' mode.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.trajectory_interval","title":"trajectory_interval  <code>pydantic-field</code>","text":"<pre><code>trajectory_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to DCD trajectory files. If <code>None</code>, no trajectories will be saved.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.trajectory_enforce_pbc","title":"trajectory_enforce_pbc  <code>pydantic-field</code>","text":"<pre><code>trajectory_enforce_pbc: bool = False\n</code></pre> <p>Whether to apply periodic boundary conditions when retrieving coordinates for writing to trajectory files.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.checkpoint_interval","title":"checkpoint_interval  <code>pydantic-field</code>","text":"<pre><code>checkpoint_interval: int | None = None\n</code></pre> <p>The number of cycles to run before saving the current replica states to checkpoint files. If <code>None</code>, no checkpoints will be saved.</p>"},{"location":"reference/md/config/#femto.md.config.HREMD.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/config/#femto.md.config.merge_configs","title":"merge_configs","text":"<pre><code>merge_configs(*configs: _T) -&gt; dict[str, Any]\n</code></pre> <p>Merge multiple configurations together.</p> <p>Parameters:</p> <ul> <li> <code>configs</code>               (<code>_T</code>, default:                   <code>()</code> )           \u2013            <p>The configurations to merge. These should either be dataclasses or plain dictionaries. Values in subsequent configs will overwrite values in previous ones.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The merged configuration.</p> </li> </ul> Source code in <code>femto/md/config.py</code> <pre><code>def merge_configs(*configs: _T) -&gt; dict[str, typing.Any]:\n    \"\"\"Merge multiple configurations together.\n\n    Args:\n        configs: The configurations to merge. These should either be dataclasses or\n            plain dictionaries. Values in subsequent configs will overwrite values in\n            previous ones.\n\n    Returns:\n        The merged configuration.\n    \"\"\"\n\n    if len(configs) == 0:\n        raise ValueError(\"At least one config must be provided\")\n\n    configs = [\n        config.model_dump() if isinstance(config, pydantic.BaseModel) else config\n        for config in configs\n    ]\n\n    return omegaconf.OmegaConf.to_object(omegaconf.OmegaConf.merge(*configs))\n</code></pre>"},{"location":"reference/md/constants/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> constants","text":""},{"location":"reference/md/constants/#femto.md.constants","title":"constants","text":"<p>Constant values such as common force groups and names.</p> <p>Classes:</p> <ul> <li> <code>OpenMMForceGroup</code>           \u2013            <p>Standard force groups to assign to common OpenMM forces to make them easier to</p> </li> <li> <code>OpenMMForceName</code>           \u2013            <p>Standard names use for common OpenMM forces to make them easier to identify.</p> </li> <li> <code>OpenMMPlatform</code>           \u2013            <p>The available OpenMM platforms to run using.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>LIGAND_1_RESIDUE_NAME</code>           \u2013            <p>The standard residue name to assign to ligand 1 of a FE calculation.</p> </li> <li> <code>LIGAND_2_RESIDUE_NAME</code>           \u2013            <p>The standard residue name to assign to ligand 2 of a FE calculation.</p> </li> </ul>"},{"location":"reference/md/constants/#femto.md.constants.LIGAND_1_RESIDUE_NAME","title":"LIGAND_1_RESIDUE_NAME  <code>module-attribute</code>","text":"<pre><code>LIGAND_1_RESIDUE_NAME = 'L1'\n</code></pre> <p>The standard residue name to assign to ligand 1 of a FE calculation.</p>"},{"location":"reference/md/constants/#femto.md.constants.LIGAND_2_RESIDUE_NAME","title":"LIGAND_2_RESIDUE_NAME  <code>module-attribute</code>","text":"<pre><code>LIGAND_2_RESIDUE_NAME = 'R1'\n</code></pre> <p>The standard residue name to assign to ligand 2 of a FE calculation.</p>"},{"location":"reference/md/constants/#femto.md.constants.OpenMMForceGroup","title":"OpenMMForceGroup","text":"<p>               Bases: <code>IntEnum</code></p> <p>Standard force groups to assign to common OpenMM forces to make them easier to identify.</p>"},{"location":"reference/md/constants/#femto.md.constants.OpenMMForceName","title":"OpenMMForceName","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Standard names use for common OpenMM forces to make them easier to identify.</p>"},{"location":"reference/md/constants/#femto.md.constants.OpenMMPlatform","title":"OpenMMPlatform","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>The available OpenMM platforms to run using.</p>"},{"location":"reference/md/hremd/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hremd","text":""},{"location":"reference/md/hremd/#femto.md.hremd","title":"hremd","text":"<p>Perform Hamiltonian replica exchange sampling.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>run_hremd</code>             \u2013              <p>Run a Hamiltonian replica exchange simulation.</p> </li> </ul>"},{"location":"reference/md/hremd/#femto.md.hremd.run_hremd","title":"run_hremd","text":"<pre><code>run_hremd(\n    simulation: Simulation,\n    states: list[dict[str, float]],\n    config: HREMD,\n    output_dir: Path | None = None,\n    swap_mask: set[tuple[int, int]] | None = None,\n    force_groups: set[int] | int = -1,\n    initial_coords: list[State] | None = None,\n    analysis_fn: (\n        Callable[[int, ndarray, ndarray], None] | None\n    ) = None,\n    analysis_interval: int | None = None,\n) -&gt; tuple[ndarray, ndarray, list[State]]\n</code></pre> <p>Run a Hamiltonian replica exchange simulation.</p> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>Simulation</code>)           \u2013            <p>The main simulation object to sample using.</p> </li> <li> <code>states</code>               (<code>list[dict[str, float]]</code>)           \u2013            <p>The states to sample at. This should be a dictionary with keys corresponding to global context parameters.</p> </li> <li> <code>config</code>               (<code>HREMD</code>)           \u2013            <p>The sampling configuration.</p> </li> <li> <code>output_dir</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The directory to store the sampled energies and statistics to, and any trajectory / checkpoint files if requested in the config. If <code>None</code>, no output of any kind will be written.</p> </li> <li> <code>swap_mask</code>               (<code>set[tuple[int, int]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Pairs of states that should not be swapped.</p> </li> <li> <code>force_groups</code>               (<code>set[int] | int</code>, default:                   <code>-1</code> )           \u2013            <p>The force groups to consider when computing the reduced potentials</p> </li> <li> <code>initial_coords</code>               (<code>list[State] | None</code>, default:                   <code>None</code> )           \u2013            <p>The initial coordinates of each state. If not provided, the coordinates will be taken from the simulation object.</p> </li> <li> <code>analysis_fn</code>               (<code>Callable[[int, ndarray, ndarray], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>A function to call after every <code>analysis_interval</code> cycles. It should take as arguments the current cycle number, the reduced potentials with <code>shape=(n_states, n_samples)</code> and the number of samples of each state with <code>shape=(n_states,)</code>.</p> </li> <li> <code>analysis_interval</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The interval with which to call the analysis function. If <code>None</code>, no analysis will be performed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray, list[State]]</code>           \u2013            <p>The reduced potentials, the number of samples of each state, and the final coordinates of each state.</p> </li> </ul> Source code in <code>femto/md/hremd.py</code> <pre><code>def run_hremd(\n    simulation: openmm.app.Simulation,\n    states: list[dict[str, float]],\n    config: femto.md.config.HREMD,\n    output_dir: pathlib.Path | None = None,\n    swap_mask: set[tuple[int, int]] | None = None,\n    force_groups: set[int] | int = -1,\n    initial_coords: list[openmm.State] | None = None,\n    analysis_fn: typing.Callable[[int, numpy.ndarray, numpy.ndarray], None]\n    | None = None,\n    analysis_interval: int | None = None,\n) -&gt; tuple[numpy.ndarray, numpy.ndarray, list[openmm.State]]:\n    \"\"\"Run a Hamiltonian replica exchange simulation.\n\n    Args:\n        simulation: The main simulation object to sample using.\n        states: The states to sample at. This should be a dictionary with keys\n            corresponding to global context parameters.\n        config: The sampling configuration.\n        output_dir: The directory to store the sampled energies and statistics to, and\n            any trajectory / checkpoint files if requested in the config. If ``None``,\n            no output of any kind will be written.\n        swap_mask: Pairs of states that should not be swapped.\n        force_groups: The force groups to consider when computing the reduced potentials\n        initial_coords: The initial coordinates of each state. If not provided, the\n            coordinates will be taken from the simulation object.\n        analysis_fn: A function to call after every ``analysis_interval`` cycles. It\n            should take as arguments the current cycle number, the reduced potentials\n            with ``shape=(n_states, n_samples)`` and the number of samples of each\n            state with ``shape=(n_states,)``.\n        analysis_interval: The interval with which to call the analysis function.\n            If ``None``, no analysis will be performed.\n\n    Returns:\n        The reduced potentials, the number of samples of each state, and the final\n        coordinates of each state.\n    \"\"\"\n    from mpi4py import MPI\n\n    n_states = len(states)\n\n    states = [\n        femto.md.utils.openmm.evaluate_ctx_parameters(state, simulation.system)\n        for state in states\n    ]\n\n    swap_mask = set() if swap_mask is None else swap_mask\n\n    n_proposed_swaps = numpy.zeros((n_states, n_states))\n    n_accepted_swaps = numpy.zeros((n_states, n_states))\n\n    replica_to_state_idx = numpy.arange(n_states)\n\n    u_kn, n_k = (\n        numpy.empty((n_states, n_states * config.n_cycles)),\n        numpy.zeros(n_states, dtype=int),\n    )\n    has_sampled = numpy.zeros(n_states * config.n_cycles, bool)\n\n    pressure = femto.md.utils.openmm.get_pressure(simulation.system)\n\n    samples_path = None if output_dir is None else output_dir / \"samples.arrow\"\n    checkpoint_path = (\n        None\n        if output_dir is None\n        or config.checkpoint_interval is None\n        or config.checkpoint_interval &lt;= 0\n        else output_dir / \"checkpoint.pkl\"\n    )\n\n    start_cycle = 0\n\n    if checkpoint_path is not None and checkpoint_path.exists():\n        (\n            start_cycle,\n            initial_coords,\n            u_kn,\n            n_k,\n            has_sampled,\n            n_proposed_swaps,\n            n_accepted_swaps,\n            replica_to_state_idx,\n        ) = _load_checkpoint(config, n_states, checkpoint_path)\n        _LOGGER.info(f\"resuming from cycle {start_cycle} samples\")\n\n    with (\n        femto.md.utils.mpi.get_mpi_comm() as mpi_comm,\n        _create_storage(mpi_comm, samples_path, n_states, start_cycle) as storage,\n        contextlib.ExitStack() as exit_stack,\n    ):\n        # each MPI process may be responsible for propagating multiple states,\n        # e.g. if we have 20 states to simulate windows but only 4 GPUs to run on.\n        n_replicas, replica_idx_offset = femto.md.utils.mpi.divide_tasks(\n            mpi_comm, n_states\n        )\n\n        if initial_coords is None:\n            coords_0 = simulation.context.getState(\n                getPositions=True, enforcePeriodicBox=config.trajectory_enforce_pbc\n            )\n            coords = [coords_0] * n_replicas\n        else:\n            coords = [initial_coords[i + replica_idx_offset] for i in range(n_replicas)]\n\n        if start_cycle == 0:\n            if mpi_comm.rank == 0:\n                _LOGGER.info(f\"running {config.n_warmup_steps} warm-up steps\")\n\n            _propagate_replicas(\n                simulation,\n                config.temperature,\n                pressure,\n                states,\n                coords,\n                config.n_warmup_steps,\n                replica_to_state_idx,\n                replica_idx_offset,\n                force_groups,\n                config.max_step_retries,\n                config.trajectory_enforce_pbc,\n            )\n\n            if mpi_comm.rank == 0:\n                _LOGGER.info(f\"running {config.n_cycles} replica exchange cycles\")\n\n        trajectory_storage = _create_trajectory_storage(\n            simulation,\n            n_replicas,\n            replica_idx_offset,\n            config.n_steps_per_cycle,\n            config.trajectory_interval,\n            output_dir,\n            exit_stack,\n        )\n\n        for cycle in tqdm.tqdm(\n            range(start_cycle, config.n_cycles),\n            total=config.n_cycles - start_cycle,\n            disable=mpi_comm.rank != 0,\n        ):\n            reduced_potentials = _propagate_replicas(\n                simulation,\n                config.temperature,\n                pressure,\n                states,\n                coords,\n                config.n_steps_per_cycle,\n                replica_to_state_idx,\n                replica_idx_offset,\n                force_groups,\n                config.max_step_retries,\n                config.trajectory_enforce_pbc,\n            )\n            reduced_potentials = mpi_comm.reduce(reduced_potentials, MPI.SUM, 0)\n\n            has_sampled[replica_to_state_idx * config.n_cycles + cycle] = True\n            u_kn[:, replica_to_state_idx * config.n_cycles + cycle] = reduced_potentials\n\n            n_k += 1\n\n            should_save_trajectory = (\n                config.trajectory_interval is not None\n                and cycle % config.trajectory_interval == 0\n            )\n\n            if should_save_trajectory:\n                _store_trajectory(coords, trajectory_storage)\n\n            should_analyze = (\n                analysis_fn is not None\n                and mpi_comm.rank == 0\n                and analysis_interval is not None\n                and cycle % analysis_interval == 0\n            )\n\n            if should_analyze:\n                analysis_fn(cycle, u_kn[:, has_sampled], n_k)\n\n            _store_potentials(\n                replica_to_state_idx,\n                reduced_potentials,\n                n_proposed_swaps,\n                n_accepted_swaps,\n                storage,\n                cycle * config.n_steps_per_cycle,\n            )\n            _propose_swaps(\n                replica_to_state_idx,\n                reduced_potentials,\n                n_proposed_swaps,\n                n_accepted_swaps,\n                swap_mask,\n                config.swap_mode,\n                config.max_swaps,\n            )\n\n            replica_to_state_idx = mpi_comm.bcast(replica_to_state_idx, 0)\n\n            should_checkpoint = (\n                checkpoint_path is not None\n                and config.checkpoint_interval is not None\n                and (\n                    cycle % config.checkpoint_interval == 0\n                    or cycle == config.n_cycles - 1\n                )\n            )\n\n            if should_checkpoint:\n                _store_checkpoint(\n                    cycle + 1,\n                    coords,\n                    u_kn,\n                    n_k,\n                    has_sampled,\n                    n_proposed_swaps,\n                    n_accepted_swaps,\n                    replica_to_state_idx,\n                    replica_idx_offset,\n                    checkpoint_path,\n                    mpi_comm,\n                )\n\n        mpi_comm.barrier()\n\n        coords_dict = {i + replica_idx_offset: coord for i, coord in enumerate(coords)}\n        coords_dict = femto.md.utils.mpi.reduce_dict(coords_dict, mpi_comm, root=None)\n\n        final_coords = [coords_dict[replica_to_state_idx[i]] for i in range(n_states)]\n\n    return u_kn, n_k, final_coords\n</code></pre>"},{"location":"reference/md/prepare/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> prepare","text":""},{"location":"reference/md/prepare/#femto.md.prepare","title":"prepare","text":"<p>Preparing systems ready for simulation.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>load_ligand</code>             \u2013              <p>Load a ligand from disk.</p> </li> <li> <code>load_ligands</code>             \u2013              <p>Load the first, and optionally second, ligand from disk.</p> </li> <li> <code>load_receptor</code>             \u2013              <p>Loads a receptor from disk.</p> </li> <li> <code>apply_hmr</code>             \u2013              <p>Apply hydrogen mass repartitioning to a system.</p> </li> <li> <code>prepare_system</code>             \u2013              <p>Solvates and parameterizes a system.</p> </li> </ul>"},{"location":"reference/md/prepare/#femto.md.prepare.load_ligand","title":"load_ligand","text":"<pre><code>load_ligand(\n    path: Path, residue_name: str = \"LIG\"\n) -&gt; Topology\n</code></pre> <p>Load a ligand from disk.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the ligand file (.sdf, .mol2)</p> </li> <li> <code>residue_name</code>               (<code>str</code>, default:                   <code>'LIG'</code> )           \u2013            <p>The residue name to assign to the ligand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The loaded ligand</p> </li> </ul> Source code in <code>femto/md/prepare.py</code> <pre><code>def load_ligand(path: pathlib.Path, residue_name: str = \"LIG\") -&gt; mdtop.Topology:\n    \"\"\"Load a ligand from disk.\n\n    Args:\n        path: The path to the ligand file (.sdf, .mol2)\n        residue_name: The residue name to assign to the ligand.\n\n    Returns:\n        The loaded ligand\n    \"\"\"\n    residue_name = \"LIG\" if residue_name is None else residue_name\n\n    if path.suffix.lower() == \".sdf\":\n        mol = Chem.AddHs(Chem.MolFromMolFile(str(path), removeHs=False))\n    elif path.suffix.lower() == \".mol2\":\n        mol = Chem.AddHs(Chem.MolFromMol2File(str(path), removeHs=False))\n    else:\n        raise NotImplementedError(f\"unsupported file format: {path.suffix}\")\n\n    top = mdtop.Topology.from_rdkit(mol, residue_name)\n\n    return top\n</code></pre>"},{"location":"reference/md/prepare/#femto.md.prepare.load_ligands","title":"load_ligands","text":"<pre><code>load_ligands(\n    ligand_1_path: Path, ligand_2_path: Path | None\n) -&gt; tuple[Topology, Topology | None]\n</code></pre> <p>Load the first, and optionally second, ligand from disk.</p> <p>Parameters:</p> <ul> <li> <code>ligand_1_path</code>               (<code>Path</code>)           \u2013            <p>The path to the first ligand.</p> </li> <li> <code>ligand_2_path</code>               (<code>Path | None</code>)           \u2013            <p>The (optional) path of the second ligand.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Topology, Topology | None]</code>           \u2013            <p>The loaded ligands.</p> </li> </ul> Source code in <code>femto/md/prepare.py</code> <pre><code>def load_ligands(\n    ligand_1_path: pathlib.Path,\n    ligand_2_path: pathlib.Path | None,\n) -&gt; tuple[mdtop.Topology, mdtop.Topology | None]:\n    \"\"\"Load the first, and optionally second, ligand from disk.\n\n    Args:\n        ligand_1_path: The path to the first ligand.\n        ligand_2_path: The (optional) path of the second ligand.\n\n    Returns:\n        The loaded ligands.\n    \"\"\"\n\n    ligand_1 = load_ligand(ligand_1_path, femto.md.constants.LIGAND_1_RESIDUE_NAME)\n\n    if ligand_2_path is None:\n        return ligand_1, None\n\n    ligand_2 = load_ligand(ligand_2_path, femto.md.constants.LIGAND_2_RESIDUE_NAME)\n\n    return ligand_1, ligand_2\n</code></pre>"},{"location":"reference/md/prepare/#femto.md.prepare.load_receptor","title":"load_receptor","text":"<pre><code>load_receptor(path: Path) -&gt; Topology\n</code></pre> <p>Loads a receptor from disk.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the receptor (.pdb, .mol2, .sdf).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Topology</code>           \u2013            <p>The loaded receptor.</p> </li> </ul> Source code in <code>femto/md/prepare.py</code> <pre><code>def load_receptor(path: pathlib.Path) -&gt; mdtop.Topology:\n    \"\"\"Loads a receptor from disk.\n\n    Args:\n        path: The path to the receptor (.pdb, .mol2, .sdf).\n\n    Returns:\n        The loaded receptor.\n    \"\"\"\n    if path.suffix.lower() == \".pdb\":\n        return mdtop.Topology.from_file(path)\n    elif path.suffix.lower() in {\".mol2\", \".sdf\"}:\n        return femto.md.prepare.load_ligand(path, \"REC\")\n\n    raise NotImplementedError(f\"unsupported file format: {path.suffix}\")\n</code></pre>"},{"location":"reference/md/prepare/#femto.md.prepare.apply_hmr","title":"apply_hmr","text":"<pre><code>apply_hmr(\n    system: System,\n    topology: Topology,\n    hydrogen_mass: Quantity = 1.5 * amu,\n)\n</code></pre> <p>Apply hydrogen mass repartitioning to a system.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to modify in-place.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology of the system.</p> </li> <li> <code>hydrogen_mass</code>               (<code>Quantity</code>, default:                   <code>1.5 * amu</code> )           \u2013            <p>The mass to use ofr hydrogen atoms.</p> </li> </ul> Source code in <code>femto/md/prepare.py</code> <pre><code>def apply_hmr(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    hydrogen_mass: openmm.unit.Quantity = 1.5 * openmm.unit.amu,\n):\n    \"\"\"Apply hydrogen mass repartitioning to a system.\n\n    Args:\n        system: The system to modify in-place.\n        topology: The topology of the system.\n        hydrogen_mass: The mass to use ofr hydrogen atoms.\n    \"\"\"\n\n    atoms = topology.atoms\n\n    for bond in topology.bonds:\n        atom_1: mdtop.Atom = atoms[bond.idx_1]\n        atom_2: mdtop.Atom = atoms[bond.idx_2]\n\n        if atom_1.atomic_num == 1:\n            (atom_1, atom_2) = (atom_2, atom_1)\n\n        if atom_2.atomic_num != 1:\n            continue\n        if atom_1.atomic_num == 1:\n            continue\n\n        elements = sorted(a.atomic_num for a in atom_2.residue.atoms)\n\n        if elements == [1, 1, 8]:\n            continue\n\n        mass_delta = hydrogen_mass - system.getParticleMass(atom_2.index)\n\n        system.setParticleMass(atom_2.index, hydrogen_mass)\n        system.setParticleMass(\n            atom_1.index, system.getParticleMass(atom_1.index) - mass_delta\n        )\n</code></pre>"},{"location":"reference/md/prepare/#femto.md.prepare.prepare_system","title":"prepare_system","text":"<pre><code>prepare_system(\n    receptor: Topology | None,\n    ligand_1: Topology | None,\n    ligand_2: Topology | None,\n    cofactors: list[Topology] | None = None,\n    config: Prepare | None = None,\n    ligand_1_offset: Quantity | None = None,\n    ligand_2_offset: Quantity | None = None,\n    cavity_formers: list[Topology] | None = None,\n    extra_params: list[Path] | None = None,\n) -&gt; tuple[Topology, System]\n</code></pre> <p>Solvates and parameterizes a system.</p> <p>Parameters:</p> <ul> <li> <code>receptor</code>               (<code>Topology | None</code>)           \u2013            <p>A receptor to include in the system.</p> </li> <li> <code>ligand_1</code>               (<code>Topology | None</code>)           \u2013            <p>A primary ligand to include in the system.</p> </li> <li> <code>ligand_2</code>               (<code>Topology | None</code>)           \u2013            <p>A secondary ligand to include in the system if doing RBFE.</p> </li> <li> <code>cofactors</code>               (<code>list[Topology] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any cofactors to include in the system.</p> </li> <li> <code>config</code>               (<code>Prepare | None</code>, default:                   <code>None</code> )           \u2013            <p>Configuration options for the preparation.</p> </li> <li> <code>ligand_1_offset</code>               (<code>Quantity | None</code>, default:                   <code>None</code> )           \u2013            <p>The amount to offset the first ligand by before computing the box size if using a padded box.</p> </li> <li> <code>ligand_2_offset</code>               (<code>Quantity | None</code>, default:                   <code>None</code> )           \u2013            <p>The amount to offset the second ligand by before computing the box size if using a padded box.</p> </li> <li> <code>cavity_formers</code>               (<code>list[Topology] | None</code>, default:                   <code>None</code> )           \u2013            <p>A (optional) list of topologies that should be considered 'present' when placing the solvent molecules such that they leave cavities, but are not added to the final topology themselves.</p> <p>Note that cavity formers will be considered when determining the box size.</p> </li> <li> <code>extra_params</code>               (<code>list[Path] | None</code>, default:                   <code>None</code> )           \u2013            <p>The paths to any extra parameter files (.xml, .parm) to use when parameterizing the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Topology, System]</code>           \u2013            <p>The solvated and parameterized topology and system, containing the ligands, the receptor, cofactors, ions and solvent.</p> </li> </ul> Source code in <code>femto/md/prepare.py</code> <pre><code>def prepare_system(\n    receptor: mdtop.Topology | None,\n    ligand_1: mdtop.Topology | None,\n    ligand_2: mdtop.Topology | None,\n    cofactors: list[mdtop.Topology] | None = None,\n    config: femto.md.config.Prepare | None = None,\n    ligand_1_offset: openmm.unit.Quantity | None = None,\n    ligand_2_offset: openmm.unit.Quantity | None = None,\n    cavity_formers: list[mdtop.Topology] | None = None,\n    extra_params: list[pathlib.Path] | None = None,\n) -&gt; tuple[mdtop.Topology, openmm.System]:\n    \"\"\"Solvates and parameterizes a system.\n\n    Args:\n        receptor: A receptor to include in the system.\n        ligand_1: A primary ligand to include in the system.\n        ligand_2: A secondary ligand to include in the system if doing RBFE.\n        cofactors: Any cofactors to include in the system.\n        config: Configuration options for the preparation.\n        ligand_1_offset: The amount to offset the first ligand by before computing the\n            box size if using a padded box.\n        ligand_2_offset: The amount to offset the second ligand by before computing the\n            box size if using a padded box.\n        cavity_formers: A (optional) list of topologies that should be considered\n            'present' when placing the solvent molecules such that they leave cavities,\n            but are not added to the final topology themselves.\n\n            Note that cavity formers will be considered when determining the box size.\n        extra_params: The paths to any extra parameter files (.xml, .parm) to use\n            when parameterizing the system.\n\n    Returns:\n        The solvated and parameterized topology and system, containing the ligands, the\n        receptor, cofactors, ions and solvent.\n    \"\"\"\n    cofactors = [] if cofactors is None else cofactors\n    cavity_formers = [] if cavity_formers is None else copy.deepcopy(cavity_formers)\n\n    config = config if config is not None else femto.md.config.Prepare()\n\n    force_field = _load_force_field(\n        *config.default_protein_ff, *([] if extra_params is None else extra_params)\n    )\n\n    if config.default_ligand_ff is not None:\n        _register_openff_generator(ligand_1, ligand_2, cofactors, force_field, config)\n\n    topology = mdtop.Topology.merge(\n        *([] if ligand_1 is None else [ligand_1]),\n        *([] if ligand_2 is None else [ligand_2]),\n        *([] if receptor is None else [receptor]),\n        *cofactors,\n    )\n\n    box_size = None\n\n    if config.box_padding is not None:\n        box_size = _compute_box_size(\n            receptor,\n            ligand_1,\n            ligand_2,\n            cofactors,\n            config.box_padding,\n            ligand_1_offset,\n            ligand_2_offset,\n            cavity_formers,\n        )\n\n        if config.box_shape.lower() == \"cube\":\n            box_size = (\n                numpy.array([max(box_size.value_in_unit(openmm.unit.angstrom))] * 3)\n                * openmm.unit.angstrom\n            )\n\n        _LOGGER.info(f\"using a box size of {box_size}\")\n\n    for former in cavity_formers:\n        for residue in former.residues:\n            residue.name = \"CAV\"\n\n    cavity = mdtop.Topology.merge(topology, *cavity_formers)\n\n    _LOGGER.info(\"adding solvent and ions\")\n    modeller = openmm.app.Modeller(cavity.to_openmm(), cavity.xyz)\n    modeller.addExtraParticles(force_field)\n    modeller.addSolvent(\n        force_field,\n        model=config.water_model.lower(),\n        boxSize=box_size,\n        numAdded=None if box_size is not None else config.n_waters,\n        boxShape=\"cube\",\n        positiveIon=config.cation,\n        negativeIon=config.anion,\n        neutralize=config.neutralize,\n        ionicStrength=config.ionic_strength,\n    )\n\n    topology = mdtop.Topology.from_openmm(modeller.topology)\n    topology.xyz = (\n        numpy.array(modeller.positions.value_in_unit(openmm.unit.angstrom))\n        * openmm.unit.angstrom\n    )\n    topology = topology[\"not r. CAV\"]  # strip cavity formers\n\n    _LOGGER.info(\"parameterizing the system\")\n\n    system = force_field.createSystem(\n        topology.to_openmm(),\n        nonbondedMethod=openmm.app.PME,\n        nonbondedCutoff=0.9 * openmm.unit.nanometer,\n        constraints=openmm.app.HBonds,\n        rigidWater=True,\n    )\n\n    # TODO: is this still needed??\n    bound = mdtop.Topology.merge(\n        *([] if ligand_1 is None else [ligand_1]),\n        *([] if ligand_2 is None else [ligand_2]),\n        *([] if receptor is None else [receptor]),\n        *cofactors,\n    )\n\n    center_offset = (\n        bound.xyz.value_in_unit(openmm.unit.angstrom).mean(axis=0)\n        * openmm.unit.angstrom\n    )\n    box_center = (\n        numpy.diag(topology.box.value_in_unit(openmm.unit.angstrom)) * 0.5\n    ) * openmm.unit.angstrom\n\n    topology.xyz = topology.xyz - center_offset + box_center\n\n    return topology, system\n</code></pre>"},{"location":"reference/md/rest/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> rest","text":""},{"location":"reference/md/rest/#femto.md.rest","title":"rest","text":"<p>Prepare a system for REST sampling.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>apply_rest</code>             \u2013              <p>Modifies an OpenMM system in-place such that the valence, vdW and electrostatic</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>REST_CTX_PARAM</code>           \u2013            <p>The global parameter used to scale interactions by beta_m / beta_0 according to</p> </li> <li> <code>REST_CTX_PARAM_SQRT</code>           \u2013            <p>The global parameter used to scale interactions by sqrt(beta_m / beta_0) according</p> </li> </ul>"},{"location":"reference/md/rest/#femto.md.rest.REST_CTX_PARAM","title":"REST_CTX_PARAM  <code>module-attribute</code>","text":"<pre><code>REST_CTX_PARAM = 'bm_b0'\n</code></pre> <p>The global parameter used to scale interactions by beta_m / beta_0 according to REST2.</p>"},{"location":"reference/md/rest/#femto.md.rest.REST_CTX_PARAM_SQRT","title":"REST_CTX_PARAM_SQRT  <code>module-attribute</code>","text":"<pre><code>REST_CTX_PARAM_SQRT = 'sqrt&lt;bm_b0&gt;'\n</code></pre> <p>The global parameter used to scale interactions by sqrt(beta_m / beta_0) according to REST2.</p>"},{"location":"reference/md/rest/#femto.md.rest.apply_rest","title":"apply_rest","text":"<pre><code>apply_rest(\n    system: System, solute_idxs: set[int], config: REST\n)\n</code></pre> <p>Modifies an OpenMM system in-place such that the valence, vdW and electrostatic interactions are scaled according to the REST2 scheme.</p> <p>Namely, torsion barrier heights are scaled by <code>beta_m / beta_0</code>, electrostatic charges are scaled by <code>sqrt(beta_m / beta_0)</code>, and LJ epsilons are scaled by <code>beta_m / beta_0</code>.</p> Notes <ul> <li>REST should be applied after any alchemical modifications.</li> </ul> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to modify in-place.</p> </li> <li> <code>solute_idxs</code>               (<code>set[int]</code>)           \u2013            <p>The indices of the 'solute'. Usually this will be the indices of the ligand atoms, but may also include protein atoms or only a subet of ligand atoms.</p> </li> <li> <code>config</code>               (<code>REST</code>)           \u2013            <p>Configuration for REST2.</p> </li> </ul> Source code in <code>femto/md/rest.py</code> <pre><code>def apply_rest(\n    system: openmm.System, solute_idxs: set[int], config: femto.md.config.REST\n):\n    \"\"\"Modifies an OpenMM system *in-place* such that the valence, vdW and electrostatic\n    interactions are scaled according to the REST2 scheme.\n\n    Namely, torsion barrier heights are scaled by ``beta_m / beta_0``, electrostatic\n    charges are scaled by ``sqrt(beta_m / beta_0)``, and LJ epsilons are scaled by\n    ``beta_m / beta_0``.\n\n    Notes:\n        * REST should be applied after any alchemical modifications.\n\n    Args:\n        system: The system to modify in-place.\n        solute_idxs: The indices of the 'solute'. Usually this will be the indices of\n            the ligand atoms, but may also include protein atoms or only a subet of\n            ligand atoms.\n        config: Configuration for REST2.\n    \"\"\"\n\n    forces_by_type = collections.defaultdict(dict)\n\n    for i, force in enumerate(system.getForces()):\n        if type(force) not in _SUPPORTED_FORCES:\n            raise ValueError(f\"Force type {type(force)} is not supported for REST.\")\n\n        forces_by_type[type(force)][i] = force\n\n    rest_forces = {}\n\n    for force_type, forces in forces_by_type.items():\n        for i, force in forces.items():\n            if force_type == openmm.HarmonicBondForce and config.scale_bonds:\n                raise NotImplementedError(\"Scaling of bonds is not yet supported.\")\n            elif force_type == openmm.HarmonicAngleForce and config.scale_angles:\n                raise NotImplementedError(\"Scaling of angles is not yet supported.\")\n            elif force_type == openmm.PeriodicTorsionForce and config.scale_torsions:\n                force = _create_torsion_force(force, solute_idxs)\n            elif (\n                force_type in (openmm.NonbondedForce, openmm.CustomNonbondedForce)\n                and config.scale_nonbonded\n            ):\n                force = _create_nonbonded_force(force, solute_idxs)\n            else:\n                force = copy.deepcopy(force)\n\n            rest_forces[i] = force\n\n    for i in reversed(range(system.getNumForces())):\n        system.removeForce(i)\n    for i in range(len(rest_forces)):\n        system.addForce(rest_forces[i])\n</code></pre>"},{"location":"reference/md/restraints/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> restraints","text":""},{"location":"reference/md/restraints/#femto.md.restraints","title":"restraints","text":"<p>Create OpenMM restraint forces.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>create_flat_bottom_restraint</code>             \u2013              <p>Creates a flat bottom position restraint.</p> </li> <li> <code>create_position_restraints</code>             \u2013              <p>Creates position restraints for all ligand atoms.</p> </li> <li> <code>create_boresch_restraint</code>             \u2013              <p>Creates a 'Boresch' style restraint force, useful for aligning a receptor and</p> </li> </ul>"},{"location":"reference/md/restraints/#femto.md.restraints.create_flat_bottom_restraint","title":"create_flat_bottom_restraint","text":"<pre><code>create_flat_bottom_restraint(\n    config: FlatBottomRestraint, coords: dict[int, Quantity]\n) -&gt; CustomExternalForce\n</code></pre> <p>Creates a flat bottom position restraint.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>FlatBottomRestraint</code>)           \u2013            <p>The restraint configuration.</p> </li> <li> <code>coords</code>               (<code>dict[int, Quantity]</code>)           \u2013            <p>A dictionary of indices of atoms to restrain and the corresponding coordinates to restrain them to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CustomExternalForce</code>           \u2013            <p>The restraint force.</p> </li> </ul> Source code in <code>femto/md/restraints.py</code> <pre><code>def create_flat_bottom_restraint(\n    config: femto.md.config.FlatBottomRestraint,\n    coords: dict[int, openmm.unit.Quantity],\n) -&gt; openmm.CustomExternalForce:\n    \"\"\"Creates a flat bottom position restraint.\n\n    Args:\n        config: The restraint configuration.\n        coords: A dictionary of indices of atoms to restrain and the corresponding\n            coordinates to restrain them to.\n\n    Returns:\n        The restraint force.\n    \"\"\"\n\n    force = openmm.CustomExternalForce(_FLAT_BOTTOM_ENERGY_FN)\n\n    force.addPerParticleParameter(\"x0\")\n    force.addPerParticleParameter(\"y0\")\n    force.addPerParticleParameter(\"z0\")\n    force.addPerParticleParameter(\"k\")\n    force.addPerParticleParameter(\"radius\")\n\n    k = config.k.value_in_unit_system(openmm.unit.md_unit_system)\n    radius = config.radius.value_in_unit_system(openmm.unit.md_unit_system)\n\n    for idx, coord in coords.items():\n        force.addParticle(\n            idx,\n            [\n                coord[0].value_in_unit_system(openmm.unit.md_unit_system),\n                coord[1].value_in_unit_system(openmm.unit.md_unit_system),\n                coord[2].value_in_unit_system(openmm.unit.md_unit_system),\n                k,\n                radius,\n            ],\n        )\n\n    force.setForceGroup(femto.md.constants.OpenMMForceGroup.POSITION_RESTRAINT)\n    force.setName(femto.md.constants.OpenMMForceName.POSITION_RESTRAINT)\n\n    return force\n</code></pre>"},{"location":"reference/md/restraints/#femto.md.restraints.create_position_restraints","title":"create_position_restraints","text":"<pre><code>create_position_restraints(\n    topology: Topology,\n    mask: str,\n    config: FlatBottomRestraint,\n) -&gt; CustomExternalForce\n</code></pre> <p>Creates position restraints for all ligand atoms.</p> <p>Parameters:</p> <ul> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology of the system being simulation.</p> </li> <li> <code>mask</code>               (<code>str</code>)           \u2013            <p>The mask that defines which atoms to restrain.</p> </li> <li> <code>config</code>               (<code>FlatBottomRestraint</code>)           \u2013            <p>The restraint configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CustomExternalForce</code>           \u2013            <p>The created restraint force.</p> </li> </ul> Source code in <code>femto/md/restraints.py</code> <pre><code>def create_position_restraints(\n    topology: mdtop.Topology,\n    mask: str,\n    config: femto.md.config.FlatBottomRestraint,\n) -&gt; openmm.CustomExternalForce:\n    \"\"\"Creates position restraints for all ligand atoms.\n\n    Args:\n        topology: The topology of the system being simulation.\n        mask: The mask that defines which atoms to restrain.\n        config: The restraint configuration.\n\n    Returns:\n        The created restraint force.\n    \"\"\"\n\n    selection_idxs = topology.select(mask)\n    assert len(selection_idxs) &gt; 0, \"no atoms were found to restrain\"\n\n    assert topology.xyz is not None, \"topology must have coordinates to restrain\"\n    xyz = topology.xyz.value_in_unit(openmm.unit.angstrom)\n\n    coords = {i: openmm.Vec3(*xyz[i]) * openmm.unit.angstrom for i in selection_idxs}\n\n    if not isinstance(config, femto.md.config.FlatBottomRestraint):\n        raise NotImplementedError(\"only flat bottom restraints are currently supported\")\n\n    return femto.md.restraints.create_flat_bottom_restraint(config, coords)\n</code></pre>"},{"location":"reference/md/restraints/#femto.md.restraints.create_boresch_restraint","title":"create_boresch_restraint","text":"<pre><code>create_boresch_restraint(\n    config: BoreschRestraint,\n    receptor_atoms: tuple[int, int, int],\n    ligand_atoms: tuple[int, int, int],\n    coords: Quantity,\n    ctx_parameter: str | None = None,\n) -&gt; CustomCompoundBondForce\n</code></pre> <p>Creates a 'Boresch' style restraint force, useful for aligning a receptor and ligand.</p> <p>It applies to three receptor atoms (r1, r2, r3), and three ligand atoms (l1, l2, l3).</p> <p>Namely, the following will be restrained:     * <code>r3</code> -- <code>l1</code> distance.     * (\u03b8_a) <code>r2</code> -- <code>r3</code> -- <code>l1</code> angle.     * (\u03b8_b) <code>r3</code> -- <code>l1</code> -- <code>l2</code> angle.     * (\u03c6_a) <code>r1</code> -- <code>r2</code> -- <code>r3</code> -- <code>l1</code> dih.     * (\u03c6_b) <code>r2</code> -- <code>r3</code> -- <code>l1</code> -- <code>l2</code> dih.     * (\u03c6_c) <code>r3</code> -- <code>l1</code> -- <code>l2</code> -- <code>l3</code> dih.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>BoreschRestraint</code>)           \u2013            <p>The restraint configuration.</p> </li> <li> <code>receptor_atoms</code>               (<code>tuple[int, int, int]</code>)           \u2013            <p>The indices of the three receptor atoms to restrain.</p> </li> <li> <code>ligand_atoms</code>               (<code>tuple[int, int, int]</code>)           \u2013            <p>The indices of the three ligand atoms to restrain.</p> </li> <li> <code>coords</code>               (<code>Quantity</code>)           \u2013            <p>The coordinates of the full system.</p> </li> <li> <code>ctx_parameter</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional context parameter to use to scale the strength of the restraint.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CustomCompoundBondForce</code>           \u2013            <p>The restraint force.</p> </li> </ul> Source code in <code>femto/md/restraints.py</code> <pre><code>def create_boresch_restraint(\n    config: femto.md.config.BoreschRestraint,\n    receptor_atoms: tuple[int, int, int],\n    ligand_atoms: tuple[int, int, int],\n    coords: openmm.unit.Quantity,\n    ctx_parameter: str | None = None,\n) -&gt; openmm.CustomCompoundBondForce:\n    \"\"\"Creates a 'Boresch' style restraint force, useful for aligning a receptor and\n    ligand.\n\n    It applies to three receptor atoms (r1, r2, r3), and three ligand atoms\n    (l1, l2, l3).\n\n    Namely, the following will be restrained:\n        * ``r3`` -- ``l1`` distance.\n        * (\u03b8_a) ``r2`` -- ``r3`` -- ``l1`` angle.\n        * (\u03b8_b) ``r3`` -- ``l1`` -- ``l2`` angle.\n        * (\u03c6_a) ``r1`` -- ``r2`` -- ``r3`` -- ``l1`` dih.\n        * (\u03c6_b) ``r2`` -- ``r3`` -- ``l1`` -- ``l2`` dih.\n        * (\u03c6_c) ``r3`` -- ``l1`` -- ``l2`` -- ``l3`` dih.\n\n    Args:\n        config: The restraint configuration.\n        receptor_atoms: The indices of the three receptor atoms to restrain.\n        ligand_atoms: The indices of the three ligand atoms to restrain.\n        coords: The coordinates of the *full* system.\n        ctx_parameter: An optional context parameter to use to scale the strength of\n            the restraint.\n\n    Returns:\n        The restraint force.\n    \"\"\"\n\n    n_particles = 6  # 3 receptor + 3 ligand\n\n    energy_fn = _BORESCH_ENERGY_FN\n\n    if ctx_parameter is not None:\n        energy_fn = f\"{ctx_parameter} * {energy_fn}\"\n\n    force = openmm.CustomCompoundBondForce(n_particles, energy_fn)\n\n    if ctx_parameter is not None:\n        force.addGlobalParameter(ctx_parameter, 1.0)\n\n    geometry = _compute_boresch_geometry(receptor_atoms, ligand_atoms, coords)\n\n    parameters = []\n\n    for key, value in [\n        (\"k_dist_a\", config.k_distance),\n        (\"k_theta_a\", config.k_angle_a),\n        (\"k_theta_b\", config.k_angle_b),\n        (\"k_phi_a\", config.k_dihedral_a),\n        (\"k_phi_b\", config.k_dihedral_b),\n        (\"k_phi_c\", config.k_dihedral_c),\n        (\"dist_0\", geometry.dist_0),\n        (\"theta_a_0\", geometry.theta_a_0),\n        (\"theta_b_0\", geometry.theta_b_0),\n        (\"phi_a_0\", geometry.phi_a_0),\n        (\"phi_b_0\", geometry.phi_b_0),\n        (\"phi_c_0\", geometry.phi_c_0),\n    ]:\n        force.addPerBondParameter(key)\n        parameters.append(value.value_in_unit_system(openmm.unit.md_unit_system))\n\n    force.addBond(receptor_atoms + ligand_atoms, parameters)\n    force.setUsesPeriodicBoundaryConditions(False)\n    force.setName(femto.md.constants.OpenMMForceName.ALIGNMENT_RESTRAINT)\n    force.setForceGroup(femto.md.constants.OpenMMForceGroup.ALIGNMENT_RESTRAINT)\n\n    return force\n</code></pre>"},{"location":"reference/md/simulate/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> simulate","text":""},{"location":"reference/md/simulate/#femto.md.simulate","title":"simulate","text":"<p>Run OpenMM simulations.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>simulate_state</code>             \u2013              <p>Simulate a system following the specified <code>stages</code>, at a given 'state' (i.e.</p> </li> <li> <code>simulate_states</code>             \u2013              <p>Simulate the system at each 'state' using <code>simulate_state</code>.</p> </li> </ul>"},{"location":"reference/md/simulate/#femto.md.simulate.simulate_state","title":"simulate_state","text":"<pre><code>simulate_state(\n    system: System,\n    topology: Topology,\n    state: dict[str, float],\n    stages: list[SimulationStage],\n    platform: OpenMMPlatform,\n    reporter: OpenMMStateReporter | None = None,\n    enforce_pbc: bool = False,\n) -&gt; State\n</code></pre> <p>Simulate a system following the specified <code>stages</code>, at a given 'state' (i.e. a set of context parameters, such as free energy lambda values)</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology to simulate.</p> </li> <li> <code>state</code>               (<code>dict[str, float]</code>)           \u2013            <p>The state to simulate at.</p> </li> <li> <code>stages</code>               (<code>list[SimulationStage]</code>)           \u2013            <p>The stages to run.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The accelerator to use.</p> </li> <li> <code>reporter</code>               (<code>OpenMMStateReporter | None</code>, default:                   <code>None</code> )           \u2013            <p>The reporter to use to record system statistics such as volume and energy.</p> </li> <li> <code>enforce_pbc</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to enforce periodic boundary conditions when retrieving the final coordinates.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>State</code>           \u2013            <p>The final coordinates and box vectors.</p> </li> </ul> Source code in <code>femto/md/simulate.py</code> <pre><code>def simulate_state(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    state: dict[str, float],\n    stages: list[femto.md.config.SimulationStage],\n    platform: femto.md.constants.OpenMMPlatform,\n    reporter: femto.md.reporting.openmm.OpenMMStateReporter | None = None,\n    enforce_pbc: bool = False,\n) -&gt; openmm.State:\n    \"\"\"Simulate a system following the specified ``stages``, at a given 'state' (i.e.\n    a set of context parameters, such as free energy lambda values)\n\n    Args:\n        system: The system to simulate.\n        topology: The topology to simulate.\n        state: The state to simulate at.\n        stages: The stages to run.\n        platform: The accelerator to use.\n        reporter: The reporter to use to record system statistics such as volume and\n            energy.\n        enforce_pbc: Whether to enforce periodic boundary conditions when retrieving\n            the final coordinates.\n\n    Returns:\n        The final coordinates and box vectors.\n    \"\"\"\n\n    reporter = (\n        reporter\n        if reporter is not None\n        else femto.md.reporting.openmm.OpenMMStateReporter(\n            femto.md.reporting.NullReporter(), \"\", 999999999\n        )\n    )\n\n    stage_counter = collections.defaultdict(int)\n\n    coords = None\n\n    for stage in stages:\n        stage_name = f\"{stage.type}-{stage_counter[stage.type]}\"\n        stage_counter[stage.type] += 1\n\n        reporter.tag = f\"equilibration/{stage_name}\"\n\n        simulation = _prepare_simulation(\n            system, topology, state, coords, stage, platform\n        )\n        simulation.reporters.append(reporter)\n\n        if isinstance(stage, femto.md.config.Minimization):\n            reporter.report(simulation, simulation.context.getState(getEnergy=True))\n            simulation.minimizeEnergy(\n                stage.tolerance.value_in_unit(_KJ_PER_NM), stage.max_iterations\n            )\n            reporter.report(simulation, simulation.context.getState(getEnergy=True))\n        elif isinstance(stage, femto.md.config.Anneal):\n            femto.md.anneal.anneal_temperature(\n                simulation,\n                stage.temperature_initial,\n                stage.temperature_final,\n                stage.n_steps,\n                stage.frequency,\n            )\n        elif isinstance(stage, femto.md.config.Simulation):\n            simulation.step(stage.n_steps)\n        else:\n            raise NotImplementedError(f\"unknown stage type {type(stage)}\")\n\n        _LOGGER.info(\n            f\"after {stage_name} \"\n            f\"{femto.md.utils.openmm.get_simulation_summary(simulation)}\"\n        )\n        coords = simulation.context.getState(\n            getPositions=True,\n            getVelocities=True,\n            getForces=True,\n            getEnergy=True,\n            enforcePeriodicBox=enforce_pbc,\n        )\n\n    return coords\n</code></pre>"},{"location":"reference/md/simulate/#femto.md.simulate.simulate_states","title":"simulate_states","text":"<pre><code>simulate_states(\n    system: System,\n    topology: Topology,\n    states: list[dict[str, float]],\n    stages: list[SimulationStage],\n    platform: OpenMMPlatform,\n    reporter: OpenMMStateReporter | None = None,\n    enforce_pbc: bool = False,\n) -&gt; list[State]\n</code></pre> <p>Simulate the system at each 'state' using <code>simulate_state</code>.</p> <p>If running using MPI, each process will be responsible for simulating at a subset of the states.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate.</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology of the system to simulate.</p> </li> <li> <code>states</code>               (<code>list[dict[str, float]]</code>)           \u2013            <p>The states of the system to simulate.</p> </li> <li> <code>stages</code>               (<code>list[SimulationStage]</code>)           \u2013            <p>The stages to run.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The accelerator to use.</p> </li> <li> <code>reporter</code>               (<code>OpenMMStateReporter | None</code>, default:                   <code>None</code> )           \u2013            <p>The reporter to use to record system statistics such as volume and energy.</p> </li> <li> <code>enforce_pbc</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to enforce periodic boundary conditions when retrieving the final coordinates.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[State]</code>           \u2013            <p>The final coordinates at each state.</p> </li> </ul> Source code in <code>femto/md/simulate.py</code> <pre><code>def simulate_states(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    states: list[dict[str, float]],\n    stages: list[femto.md.config.SimulationStage],\n    platform: femto.md.constants.OpenMMPlatform,\n    reporter: femto.md.reporting.openmm.OpenMMStateReporter | None = None,\n    enforce_pbc: bool = False,\n) -&gt; list[openmm.State]:\n    \"\"\"Simulate the system at each 'state' using ``simulate_state``.\n\n    If running using MPI, each process will be responsible for simulating at a subset\n    of the states.\n\n    Args:\n        system: The system to simulate.\n        topology: The topology of the system to simulate.\n        states: The states of the system to simulate.\n        stages: The stages to run.\n        platform: The accelerator to use.\n        reporter: The reporter to use to record system statistics such as volume and\n            energy.\n        enforce_pbc: Whether to enforce periodic boundary conditions when retrieving\n            the final coordinates.\n\n    Returns:\n        The final coordinates at each state.\n    \"\"\"\n\n    with femto.md.utils.mpi.get_mpi_comm() as mpi_comm:\n        # figure out how many states will be run in this MPI process\n        n_local_states, state_offset = femto.md.utils.mpi.divide_tasks(\n            mpi_comm, len(states)\n        )\n\n        final_coords: dict[int, openmm.State] = {}\n\n        for i in range(n_local_states):\n            state_idx = i + state_offset\n\n            final_coords[state_idx] = simulate_state(\n                system,\n                topology,\n                states[i + state_offset],\n                stages,\n                platform,\n                reporter if state_idx == 0 else None,\n                enforce_pbc=enforce_pbc,\n            )\n\n        final_coords = femto.md.utils.mpi.reduce_dict(final_coords, mpi_comm)\n\n    return [final_coords[i] for i in range(len(states))]\n</code></pre>"},{"location":"reference/md/reporting/","title":"Index","text":""},{"location":"reference/md/reporting/#femto.md.reporting","title":"reporting","text":"<p>Reporters for state and statistics</p> <p>Modules:</p> <ul> <li> <code>openmm</code>           \u2013            <p>Reporters compatible with OpenMM simulation objects</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NullReporter</code>           \u2013            <p>A dummy reporter that does nothing with reported values.</p> </li> <li> <code>Reporter</code>           \u2013            <p>Base class for reporter classes.</p> </li> <li> <code>TensorboardReporter</code>           \u2013            <p>Report statistics to <code>tensorboard</code> compatible event files.</p> </li> </ul>"},{"location":"reference/md/reporting/#femto.md.reporting.NullReporter","title":"NullReporter","text":"<p>               Bases: <code>Reporter</code></p> <p>A dummy reporter that does nothing with reported values.</p>"},{"location":"reference/md/reporting/#femto.md.reporting.Reporter","title":"Reporter","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for reporter classes.</p> <p>Methods:</p> <ul> <li> <code>report_figure</code>             \u2013              <p>Report a custom plot.</p> </li> <li> <code>report_scalar</code>             \u2013              <p>Report a scalar value.</p> </li> <li> <code>report_matrix</code>             \u2013              <p>Report a matrix of values.</p> </li> <li> <code>flush</code>             \u2013              <p>Flush the reporter.</p> </li> <li> <code>close</code>             \u2013              <p>Close the reporter.</p> </li> </ul>"},{"location":"reference/md/reporting/#femto.md.reporting.Reporter.report_figure","title":"report_figure  <code>abstractmethod</code>","text":"<pre><code>report_figure(\n    tag: str, iteration: int | None, figure: Figure\n)\n</code></pre> <p>Report a custom plot.</p> Source code in <code>femto/md/reporting/_reporting.py</code> <pre><code>@abc.abstractmethod\ndef report_figure(self, tag: str, iteration: int | None, figure: \"pyplot.Figure\"):\n    \"\"\"Report a custom plot.\"\"\"\n</code></pre>"},{"location":"reference/md/reporting/#femto.md.reporting.Reporter.report_scalar","title":"report_scalar  <code>abstractmethod</code>","text":"<pre><code>report_scalar(tag: str, iteration: int, value: float)\n</code></pre> <p>Report a scalar value.</p> Source code in <code>femto/md/reporting/_reporting.py</code> <pre><code>@abc.abstractmethod\ndef report_scalar(self, tag: str, iteration: int, value: float):\n    \"\"\"Report a scalar value.\"\"\"\n</code></pre>"},{"location":"reference/md/reporting/#femto.md.reporting.Reporter.report_matrix","title":"report_matrix  <code>abstractmethod</code>","text":"<pre><code>report_matrix(tag: str, iteration: int, value: ndarray)\n</code></pre> <p>Report a matrix of values.</p> Source code in <code>femto/md/reporting/_reporting.py</code> <pre><code>@abc.abstractmethod\ndef report_matrix(self, tag: str, iteration: int, value: numpy.ndarray):\n    \"\"\"Report a matrix of values.\"\"\"\n</code></pre>"},{"location":"reference/md/reporting/#femto.md.reporting.Reporter.flush","title":"flush  <code>abstractmethod</code>","text":"<pre><code>flush()\n</code></pre> <p>Flush the reporter.</p> Source code in <code>femto/md/reporting/_reporting.py</code> <pre><code>@abc.abstractmethod\ndef flush(self):\n    \"\"\"Flush the reporter.\"\"\"\n</code></pre>"},{"location":"reference/md/reporting/#femto.md.reporting.Reporter.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Close the reporter.</p> Source code in <code>femto/md/reporting/_reporting.py</code> <pre><code>@abc.abstractmethod\ndef close(self):\n    \"\"\"Close the reporter.\"\"\"\n</code></pre>"},{"location":"reference/md/reporting/#femto.md.reporting.TensorboardReporter","title":"TensorboardReporter","text":"<pre><code>TensorboardReporter(log_dir: Path)\n</code></pre> <p>               Bases: <code>Reporter</code></p> <p>Report statistics to <code>tensorboard</code> compatible event files.</p> Source code in <code>femto/md/reporting/_reporting.py</code> <pre><code>def __init__(self, log_dir: pathlib.Path):\n    log_dir.mkdir(parents=True, exist_ok=True)\n    self._writer = tensorboardX.SummaryWriter(log_dir=str(log_dir))\n</code></pre>"},{"location":"reference/md/reporting/openmm/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> openmm","text":""},{"location":"reference/md/reporting/openmm/#femto.md.reporting.openmm","title":"openmm","text":"<p>Reporters compatible with OpenMM simulation objects</p> <p>Classes:</p> <ul> <li> <code>OpenMMStateReporter</code>           \u2013            <p>Report OpenMM simulation state using a Reporter object.</p> </li> </ul>"},{"location":"reference/md/reporting/openmm/#femto.md.reporting.openmm.OpenMMStateReporter","title":"OpenMMStateReporter","text":"<pre><code>OpenMMStateReporter(\n    reporter: Reporter,\n    tag: str,\n    interval: int,\n    total_energy: bool = True,\n    potential_energy: bool = True,\n    kinetic_energy: bool = False,\n    volume: bool = True,\n    temperature: bool = True,\n)\n</code></pre> <p>Report OpenMM simulation state using a Reporter object.</p> <pre><code>tag: The tag to report using.\ninterval: The interval at which to report.\ntotal_energy: Report the total energy.\npotential_energy: Report the potential energy.\nkinetic_energy: Report the kinetic energy.\nvolume: Report the volume.\ntemperature: Report the temperature.\n</code></pre> Source code in <code>femto/md/reporting/openmm.py</code> <pre><code>def __init__(\n    self,\n    reporter: Reporter,\n    tag: str,\n    interval: int,\n    total_energy: bool = True,\n    potential_energy: bool = True,\n    kinetic_energy: bool = False,\n    volume: bool = True,\n    temperature: bool = True,\n):\n    \"\"\"\n\n    Args:\n        reporter: The reporter to use.\n        tag: The tag to report using.\n        interval: The interval at which to report.\n        total_energy: Report the total energy.\n        potential_energy: Report the potential energy.\n        kinetic_energy: Report the kinetic energy.\n        volume: Report the volume.\n        temperature: Report the temperature.\n    \"\"\"\n    self._has_initialized = False\n    self._dof = None\n\n    self._reporter = reporter\n\n    self.tag = tag\n    self.interval = interval\n\n    self._include_total_energy = total_energy\n    self._include_potential_energy = potential_energy\n    self._include_kinetic_energy = kinetic_energy\n    self._include_volume = volume\n    self._include_temperature = temperature\n</code></pre>"},{"location":"reference/md/utils/","title":"Index","text":""},{"location":"reference/md/utils/#femto.md.utils","title":"utils","text":"<p>Common utilities.</p> <p>Modules:</p> <ul> <li> <code>amber</code>           \u2013            <p>Utilities for working with Amber files and objects.</p> </li> <li> <code>geometry</code>           \u2013            <p>Common functions for computing the internal coordinates (e.g. bond lengths).</p> </li> <li> <code>logging</code>           \u2013            <p>Utilities to setup logging</p> </li> <li> <code>models</code>           \u2013            <p>Common pydantic helpers.</p> </li> <li> <code>mpi</code>           \u2013            <p>Utilities for interacting with MPI.</p> </li> <li> <code>openmm</code>           \u2013            <p>Utilities for manipulating OpenMM objects.</p> </li> </ul>"},{"location":"reference/md/utils/amber/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> amber","text":""},{"location":"reference/md/utils/amber/#femto.md.utils.amber","title":"amber","text":"<p>Utilities for working with Amber files and objects.</p> <p>Functions:</p> <ul> <li> <code>convert_parm_to_xml</code>             \u2013              <p>Convert an Amber parameter file to OpenMM XML format.</p> </li> </ul>"},{"location":"reference/md/utils/amber/#femto.md.utils.amber.convert_parm_to_xml","title":"convert_parm_to_xml","text":"<pre><code>convert_parm_to_xml(path: Path) -&gt; str\n</code></pre> <p>Convert an Amber parameter file to OpenMM XML format.</p> Notes <ul> <li>This function requires that ParmEd is installed.</li> <li>Doing any kind of interconversion of force fields is inherently dangerous.   This should only be used as a last resort when you have no other option.</li> </ul> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>The path to the Amber parameter file (.parm7, .prmtop, .parm).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The OpenMM XML representation of the Amber parameter file.</p> </li> </ul> Source code in <code>femto/md/utils/amber.py</code> <pre><code>def convert_parm_to_xml(path: pathlib.Path) -&gt; str:\n    \"\"\"Convert an Amber parameter file to OpenMM XML format.\n\n    Notes:\n        * This function requires that ParmEd is installed.\n        * Doing any kind of interconversion of force fields is inherently dangerous.\n          This should only be used as a last resort when you have no other option.\n\n    Args:\n        path: The path to the Amber parameter file (.parm7, .prmtop, .parm).\n\n    Returns:\n        The OpenMM XML representation of the Amber parameter file.\n    \"\"\"\n    import parmed\n\n    if path.suffix.lower() not in {\".prmtop\", \".parm7\", \".parm\"}:\n        raise ValueError(f\"Unsupported Amber file format: {path}\")\n\n    warnings.warn(\n        f\"Converting {path.name} from {path.suffix} to OpenMM FFXML. It is assumed \"\n        f\"that the parameter was generated by an Amber based FF, e.g. GAFF, and treats \"\n        f\"any improper torsions as such. Such conversion is inherently dangerous, and \"\n        f\"support to do so will be removed in the future.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    structure = parmed.amber.AmberParm(str(path))\n\n    mock_atoms = [\n        _MockAtom(\n            index=atom.idx,\n            name=atom.name,\n            symbol=openmm.app.Element.getByAtomicNumber(atom.element).symbol,\n            typename=atom.type,\n            mass=atom.mass,\n            neighbours=[neigh.idx for neigh in atom.bond_partners],\n        )\n        for atom in structure.atoms\n    ]\n    mock_bonds = [\n        _MockBond(\n            atom1=mock_atoms[bond.atom1.idx],\n            atom2=mock_atoms[bond.atom2.idx],\n        )\n        for bond in structure.bonds\n    ]\n    mock_mol = _MockMolecule(atoms=mock_atoms, bonds=mock_bonds)\n\n    system = structure.createSystem(removeCMMotion=False)\n    _reorder_torsions(system, mock_mol)\n\n    mixin = openmmforcefields.generators.template_generators.OpenMMSystemMixin()\n\n    ffxml = mixin.convert_system_to_ffxml(mock_mol, system, \"amber\")\n    ffxml = ffxml.replace('ordering=\"smirnoff\"', 'ordering=\"amber\"')\n\n    return ffxml\n</code></pre>"},{"location":"reference/md/utils/geometry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> geometry","text":""},{"location":"reference/md/utils/geometry/#femto.md.utils.geometry","title":"geometry","text":"<p>Common functions for computing the internal coordinates (e.g. bond lengths).</p> <p>Functions:</p> <ul> <li> <code>compute_bond_vectors</code>             \u2013              <p>Computes the vectors between each atom pair specified by the <code>idxs</code> as</p> </li> <li> <code>compute_distances</code>             \u2013              <p>Computes the distances between each pair of coordinates.</p> </li> <li> <code>compute_angles</code>             \u2013              <p>Computes the angles [rad] between each specified triplet of indices.</p> </li> <li> <code>compute_dihedrals</code>             \u2013              <p>Computes the angles [rad] between each specified quartet of indices.</p> </li> </ul>"},{"location":"reference/md/utils/geometry/#femto.md.utils.geometry.compute_bond_vectors","title":"compute_bond_vectors","text":"<pre><code>compute_bond_vectors(\n    coords: ndarray, idxs: ndarray\n) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Computes the vectors between each atom pair specified by the <code>idxs</code> as well as their norms.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>ndarray</code>)           \u2013            <p>The coordinates with <code>shape=(n_coords, 3)</code>.</p> </li> <li> <code>idxs</code>               (<code>ndarray</code>)           \u2013            <p>The indices of the coordinates to compute the distances between with <code>shape=(n_pairs, 2)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>A tuple of the vectors with shape=<code>shape=(n_pairs, 3)</code> and norms with <code>shape=(n_pairs,)</code>.</p> </li> </ul> Source code in <code>femto/md/utils/geometry.py</code> <pre><code>def compute_bond_vectors(\n    coords: numpy.ndarray, idxs: numpy.ndarray\n) -&gt; tuple[numpy.ndarray, numpy.ndarray]:\n    \"\"\"Computes the vectors between each atom pair specified by the ``idxs`` as\n    well as their norms.\n\n    Args:\n        coords: The coordinates with ``shape=(n_coords, 3)``.\n        idxs: The indices of the coordinates to compute the distances between with\n            ``shape=(n_pairs, 2)``.\n\n    Returns:\n        A tuple of the vectors with shape=``shape=(n_pairs, 3)`` and norms with\n        ``shape=(n_pairs,)``.\n    \"\"\"\n\n    if len(idxs) == 0:\n        return numpy.ndarray([]), numpy.ndarray([])\n\n    directions = coords[idxs[:, 1]] - coords[idxs[:, 0]]\n    distances = numpy.linalg.norm(directions, axis=1)\n\n    return directions, distances\n</code></pre>"},{"location":"reference/md/utils/geometry/#femto.md.utils.geometry.compute_distances","title":"compute_distances","text":"<pre><code>compute_distances(\n    coords: ndarray, idxs: ndarray\n) -&gt; ndarray\n</code></pre> <p>Computes the distances between each pair of coordinates.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>ndarray</code>)           \u2013            <p>The coordinates with <code>shape=(n_coords, 3)</code>.</p> </li> <li> <code>idxs</code>               (<code>ndarray</code>)           \u2013            <p>The indices of the coordinates to compute the distances between with <code>shape=(n_pairs, 2)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The distances with <code>shape=(n_pairs,)</code>.</p> </li> </ul> Source code in <code>femto/md/utils/geometry.py</code> <pre><code>def compute_distances(coords: numpy.ndarray, idxs: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Computes the distances between each pair of coordinates.\n\n    Args:\n        coords: The coordinates with ``shape=(n_coords, 3)``.\n        idxs: The indices of the coordinates to compute the distances between with\n            ``shape=(n_pairs, 2)``.\n\n    Returns:\n        The distances with ``shape=(n_pairs,)``.\n    \"\"\"\n\n    return compute_bond_vectors(coords, idxs)[1]\n</code></pre>"},{"location":"reference/md/utils/geometry/#femto.md.utils.geometry.compute_angles","title":"compute_angles","text":"<pre><code>compute_angles(coords: ndarray, idxs: ndarray) -&gt; ndarray\n</code></pre> <p>Computes the angles [rad] between each specified triplet of indices.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>ndarray</code>)           \u2013            <p>The coordinates with <code>shape=(n_coords, 3)</code> or <code>shape=(n_frames, n_coords, 3)</code>.</p> </li> <li> <code>idxs</code>               (<code>ndarray</code>)           \u2013            <p>The indices of the coordinates to compute the angles between with <code>shape=(n_pairs, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The angles with <code>shape=(n_pairs,)</code> or <code>shape=(n_frames, n_pairs)</code>.</p> </li> </ul> Source code in <code>femto/md/utils/geometry.py</code> <pre><code>def compute_angles(coords: numpy.ndarray, idxs: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Computes the angles [rad] between each specified triplet of indices.\n\n    Args:\n        coords: The coordinates with ``shape=(n_coords, 3)`` or\n            ``shape=(n_frames, n_coords, 3)``.\n        idxs: The indices of the coordinates to compute the angles between with\n            ``shape=(n_pairs, 3)``.\n\n    Returns:\n        The angles with ``shape=(n_pairs,)`` or ``shape=(n_frames, n_pairs)``.\n    \"\"\"\n\n    if len(idxs) == 0:\n        return numpy.ndarray([])\n\n    is_batched = coords.ndim == 3\n\n    if not is_batched:\n        coords = coords[None, :, :]\n\n    vector_ab = coords[:, idxs[:, 1]] - coords[:, idxs[:, 0]]\n    vector_ac = coords[:, idxs[:, 1]] - coords[:, idxs[:, 2]]\n\n    # tan theta = sin theta / cos theta\n    #\n    # ||a x b|| = ||a|| ||b|| sin theta\n    #   a . b   = ||a|| ||b|| cos theta\n    #\n    # =&gt; tan theta = (a x b) / (a . b)\n    angles = numpy.arctan2(\n        numpy.linalg.norm(numpy.cross(vector_ab, vector_ac, axis=-1), axis=-1),\n        (vector_ab * vector_ac).sum(axis=-1),\n    )\n\n    if not is_batched:\n        angles = angles[0]\n\n    return angles\n</code></pre>"},{"location":"reference/md/utils/geometry/#femto.md.utils.geometry.compute_dihedrals","title":"compute_dihedrals","text":"<pre><code>compute_dihedrals(\n    coords: ndarray, idxs: ndarray\n) -&gt; ndarray\n</code></pre> <p>Computes the angles [rad] between each specified quartet of indices.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>ndarray</code>)           \u2013            <p>The coordinates with <code>shape=(n_coords, 3)</code> or <code>shape=(n_frames, n_coords, 3)</code>.</p> </li> <li> <code>idxs</code>               (<code>ndarray</code>)           \u2013            <p>The indices of the coordinates to compute the dihedrals between with <code>shape=(n_pairs, 4)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The dihedrals with <code>shape=(n_pairs,)</code> or <code>shape=(n_frames, n_pairs)</code>.</p> </li> </ul> Source code in <code>femto/md/utils/geometry.py</code> <pre><code>def compute_dihedrals(coords: numpy.ndarray, idxs: numpy.ndarray) -&gt; numpy.ndarray:\n    \"\"\"Computes the angles [rad] between each specified quartet of indices.\n\n    Args:\n        coords: The coordinates with ``shape=(n_coords, 3)`` or\n            ``shape=(n_frames, n_coords, 3)``.\n        idxs: The indices of the coordinates to compute the dihedrals between with\n            ``shape=(n_pairs, 4)``.\n\n    Returns:\n        The dihedrals with ``shape=(n_pairs,)`` or ``shape=(n_frames, n_pairs)``.\n    \"\"\"\n\n    if len(idxs) == 0:\n        return numpy.ndarray([])\n\n    is_batched = coords.ndim == 3\n\n    if not is_batched:\n        coords = coords[None, :, :]\n\n    vector_ab = coords[:, idxs[:, 0]] - coords[:, idxs[:, 1]]\n    vector_cb = coords[:, idxs[:, 2]] - coords[:, idxs[:, 1]]\n    vector_cd = coords[:, idxs[:, 2]] - coords[:, idxs[:, 3]]\n\n    vector_ab_cross_cb = numpy.cross(vector_ab, vector_cb, axis=-1)\n    vector_cb_cross_cd = numpy.cross(vector_cb, vector_cd, axis=-1)\n\n    vector_cb_norm = numpy.linalg.norm(vector_cb, axis=-1)[:, :, None]\n\n    y = (\n        numpy.cross(vector_ab_cross_cb, vector_cb_cross_cd, axis=-1)\n        * vector_cb\n        / vector_cb_norm\n    ).sum(axis=-1)\n\n    x = (vector_ab_cross_cb * vector_cb_cross_cd).sum(axis=-1)\n\n    phi = numpy.arctan2(y, x)\n\n    if not is_batched:\n        phi = phi[0]\n\n    return phi\n</code></pre>"},{"location":"reference/md/utils/logging/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> logging","text":""},{"location":"reference/md/utils/logging/#femto.md.utils.logging","title":"logging","text":"<p>Utilities to setup logging</p> <p>Functions:</p> <ul> <li> <code>get_public_parent_module</code>             \u2013              <p>Get the first public parent module of a module.</p> </li> <li> <code>get_parent_logger</code>             \u2013              <p>Returns the logger of the first public parent module of a module.</p> </li> </ul>"},{"location":"reference/md/utils/logging/#femto.md.utils.logging.get_public_parent_module","title":"get_public_parent_module","text":"<pre><code>get_public_parent_module(name: str) -&gt; str\n</code></pre> <p>Get the first public parent module of a module.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The full name (e.g. <code>'mod_a.mod_b._mod_c'</code>) of the module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The full name of the first public parent module (e.g. <code>'mod_a.mod_b'</code>).</p> </li> </ul> Source code in <code>femto/md/utils/logging.py</code> <pre><code>def get_public_parent_module(name: str) -&gt; str:\n    \"\"\"Get the first public parent module of a module.\n\n    Args:\n        name: The full name (e.g. ``'mod_a.mod_b._mod_c'``) of the module.\n\n    Returns:\n        The full name of the first public parent module (e.g. ``'mod_a.mod_b'``).\n    \"\"\"\n\n    parts = name.split(\".\")\n\n    while parts and parts[-1].startswith(\"_\"):\n        parts.pop()\n\n    return \".\".join(parts)\n</code></pre>"},{"location":"reference/md/utils/logging/#femto.md.utils.logging.get_parent_logger","title":"get_parent_logger","text":"<pre><code>get_parent_logger(name: str) -&gt; Logger\n</code></pre> <p>Returns the logger of the first public parent module of a module.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The full name (e.g. <code>'mod_a.mod_b._mod_c'</code>) of the module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Logger</code>           \u2013            <p>The logger.</p> </li> </ul> Source code in <code>femto/md/utils/logging.py</code> <pre><code>def get_parent_logger(name: str) -&gt; logging.Logger:\n    \"\"\"Returns the logger of the first public parent module of a module.\n\n    Args:\n        name: The full name (e.g. ``'mod_a.mod_b._mod_c'``) of the module.\n\n    Returns:\n        The logger.\n    \"\"\"\n\n    return logging.getLogger(get_public_parent_module(name))\n</code></pre>"},{"location":"reference/md/utils/models/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> models","text":""},{"location":"reference/md/utils/models/#femto.md.utils.models","title":"models","text":"<p>Common pydantic helpers.</p> <p>Classes:</p> <ul> <li> <code>BaseModel</code>           \u2013            <p>A base class for <code>pydantic</code> based models.</p> </li> </ul>"},{"location":"reference/md/utils/models/#femto.md.utils.models.BaseModel","title":"BaseModel  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A base class for <code>pydantic</code> based models.</p> <p>Config:</p> <ul> <li><code>extra</code>: <code>'forbid'</code></li> <li><code>validate_default</code>: <code>True</code></li> <li><code>validate_assignment</code>: <code>True</code></li> </ul>"},{"location":"reference/md/utils/models/#femto.md.utils.models.BaseModel.model_dump_yaml","title":"model_dump_yaml","text":"<pre><code>model_dump_yaml(\n    output_path: Path | None = None, **kwargs\n) -&gt; str\n</code></pre> <p>Dump the model to a YAML representation.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The (optional) path to save the YAML representation to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The YAML representation.</p> </li> </ul> Source code in <code>femto/md/utils/models.py</code> <pre><code>def model_dump_yaml(self, output_path: pathlib.Path | None = None, **kwargs) -&gt; str:\n    \"\"\"Dump the model to a YAML representation.\n\n    Args:\n        output_path: The (optional) path to save the YAML representation to.\n\n    Returns:\n        The YAML representation.\n    \"\"\"\n\n    model_yaml = yaml.safe_dump(self.model_dump(), **kwargs)\n\n    if output_path is not None:\n        output_path.parent.mkdir(exist_ok=True, parents=True)\n        output_path.write_text(model_yaml)\n\n    return model_yaml\n</code></pre>"},{"location":"reference/md/utils/mpi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mpi","text":""},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi","title":"mpi","text":"<p>Utilities for interacting with MPI.</p> <p>Functions:</p> <ul> <li> <code>is_rank_zero</code>             \u2013              <p>Returns true if the current MPI rank is zero, or if the application is not</p> </li> <li> <code>get_mpi_comm</code>             \u2013              <p>A context manager that returns the main MPI communicator and installs signal</p> </li> <li> <code>reduce_dict</code>             \u2013              <p>Reduce a dictionary of values across MPI ranks.</p> </li> <li> <code>divide_tasks</code>             \u2013              <p>Determine how many tasks the current MPI process should run given the total</p> </li> <li> <code>divide_gpus</code>             \u2013              <p>Attempts to divide the available GPUs across MPI ranks. If there are more ranks</p> </li> <li> <code>run_on_rank_zero</code>             \u2013              <p>A convenient decorator that ensures the function is only run on rank zero and</p> </li> </ul>"},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi.is_rank_zero","title":"is_rank_zero","text":"<pre><code>is_rank_zero() -&gt; bool\n</code></pre> <p>Returns true if the current MPI rank is zero, or if the application is not running using MPI.</p> Source code in <code>femto/md/utils/mpi.py</code> <pre><code>def is_rank_zero() -&gt; bool:\n    \"\"\"Returns true if the current MPI rank is zero, or if the application is not\n    running using MPI.\"\"\"\n\n    mpi_env_vars = {\"PMI_RANK\", \"PMIX_RANK\", \"OMPI_COMM_WORLD_SIZE\"}\n\n    if all(env_var not in os.environ for env_var in mpi_env_vars):\n        return True\n\n    from mpi4py import MPI\n\n    return MPI.COMM_WORLD.rank == 0\n</code></pre>"},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi.get_mpi_comm","title":"get_mpi_comm","text":"<pre><code>get_mpi_comm() -&gt; ContextManager[Intracomm]\n</code></pre> <p>A context manager that returns the main MPI communicator and installs signal handlers to abort MPI on exceptions.</p> <p>The signal handlers are restored to their defaults when the context manager exits.</p> <p>Returns:</p> <ul> <li> <code>ContextManager[Intracomm]</code>           \u2013            <p>The global MPI communicator.</p> </li> </ul> Source code in <code>femto/md/utils/mpi.py</code> <pre><code>@contextlib.contextmanager\ndef get_mpi_comm() -&gt; typing.ContextManager[\"MPI.Intracomm\"]:\n    \"\"\"A context manager that returns the main MPI communicator and installs signal\n    handlers to abort MPI on exceptions.\n\n    The signal handlers are restored to their defaults when the context manager exits.\n\n    Returns:\n        The global MPI communicator.\n    \"\"\"\n    from mpi4py import MPI\n\n    comm = MPI.COMM_WORLD\n\n    global _INSIDE_MPI_COMM\n\n    if _INSIDE_MPI_COMM:\n        yield comm\n        return\n\n    _INSIDE_MPI_COMM = True\n\n    original_signal_handlers = {\n        signal_code: signal.getsignal(signal_code)\n        for signal_code in [signal.SIGINT, signal.SIGTERM, signal.SIGABRT]\n    }\n\n    def abort_comm():\n        if comm.size &gt; 1:\n            _LOGGER.warning(\"Aborting MPI\")\n            comm.Abort(1)\n\n    def abort_comm_handler(signal_code, _):\n        abort_comm()\n\n        signal.signal(signal_code, original_signal_handlers[signal_code])\n        signal.raise_signal(signal_code)\n\n    try:\n        for signal_code in original_signal_handlers:\n            signal.signal(signal_code, abort_comm_handler)\n\n        yield comm\n    except BaseException as e:\n        _LOGGER.exception(e)\n        abort_comm()\n        raise e\n    finally:\n        for signal_code in original_signal_handlers:\n            signal.signal(signal_code, original_signal_handlers[signal_code])\n\n        _INSIDE_MPI_COMM = False\n</code></pre>"},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi.reduce_dict","title":"reduce_dict","text":"<pre><code>reduce_dict(\n    value: dict[_K, _K\" optional hover&gt;_K],\n    mpi_comm: Intracomm,\n    root: int | None = None,\n) -&gt; dict[_K, _T]\n</code></pre> <p>Reduce a dictionary of values across MPI ranks.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>dict[_K, _T]</code>)           \u2013            <p>The dictionary of values to reduce.</p> </li> <li> <code>mpi_comm</code>               (<code>Intracomm</code>)           \u2013            <p>The MPI communicator to use for the reduction.</p> </li> <li> <code>root</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The rank to which the reduced dictionary should be sent. If None, the reduced dictionary will be broadcast to all ranks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[_K, _T]</code>           \u2013            <p>The reduced dictionary of values.</p> </li> </ul> Source code in <code>femto/md/utils/mpi.py</code> <pre><code>def reduce_dict(\n    value: dict[_K, _T], mpi_comm: \"MPI.Intracomm\", root: int | None = None\n) -&gt; dict[_K, _T]:\n    \"\"\"Reduce a dictionary of values across MPI ranks.\n\n    Args:\n        value: The dictionary of values to reduce.\n        mpi_comm: The MPI communicator to use for the reduction.\n        root: The rank to which the reduced dictionary should be sent. If None, the\n            reduced dictionary will be broadcast to all ranks.\n\n    Returns:\n        The reduced dictionary of values.\n    \"\"\"\n    import mpi4py.MPI\n\n    global _REDUCE_DICT_OP\n\n    if _REDUCE_DICT_OP is None:\n        _REDUCE_DICT_OP = mpi4py.MPI.Op.Create(_reduce_dict_fn, commute=True)\n\n    if root is not None:\n        return mpi_comm.reduce({**value}, op=_REDUCE_DICT_OP, root=root)\n    else:\n        return mpi_comm.allreduce({**value}, op=_REDUCE_DICT_OP)\n</code></pre>"},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi.divide_tasks","title":"divide_tasks","text":"<pre><code>divide_tasks(\n    mpi_comm: Intracomm, n_tasks: int\n) -&gt; tuple[int, int]\n</code></pre> <p>Determine how many tasks the current MPI process should run given the total number that need to be distributed across all ranks.</p> <p>Parameters:</p> <ul> <li> <code>mpi_comm</code>               (<code>Intracomm</code>)           \u2013            <p>The main MPI communicator.</p> </li> <li> <code>n_tasks</code>               (<code>int</code>)           \u2013            <p>The total number of tasks to run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[int, int]</code>           \u2013            <p>The number of tasks to run on the current MPI process, and the index of the first task to be run by this worker.</p> </li> </ul> Source code in <code>femto/md/utils/mpi.py</code> <pre><code>def divide_tasks(mpi_comm: \"MPI.Intracomm\", n_tasks: int) -&gt; tuple[int, int]:\n    \"\"\"Determine how many tasks the current MPI process should run given the total\n    number that need to be distributed across all ranks.\n\n    Args:\n        mpi_comm: The main MPI communicator.\n        n_tasks: The total number of tasks to run.\n\n    Returns:\n        The number of tasks to run on the current MPI process, and the index of the\n        first task to be run by this worker.\n    \"\"\"\n    n_workers = mpi_comm.size\n    worker_idx = mpi_comm.rank\n\n    n_each, n_extra = divmod(n_tasks, n_workers)\n\n    replica_idx_offsets = numpy.array(\n        [0] + n_extra * [n_each + 1] + (n_workers - n_extra) * [n_each]\n    )\n    replica_idx_offset = replica_idx_offsets.cumsum()[worker_idx]\n\n    n_replicas = n_each + 1 if worker_idx &lt; n_extra else n_each\n\n    hostname = socket.gethostname()\n    _LOGGER.debug(\n        f\"hostname={hostname} rank={mpi_comm.rank} will run {n_replicas} replicas\"\n    )\n\n    return n_replicas, replica_idx_offset\n</code></pre>"},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi.divide_gpus","title":"divide_gpus","text":"<pre><code>divide_gpus()\n</code></pre> <p>Attempts to divide the available GPUs across MPI ranks. If there are more ranks than GPUs, then each GPU will be assigned to multiple ranks.</p> Source code in <code>femto/md/utils/mpi.py</code> <pre><code>def divide_gpus():\n    \"\"\"Attempts to divide the available GPUs across MPI ranks. If there are more ranks\n    than GPUs, then each GPU will be assigned to multiple ranks.\n    \"\"\"\n    import mpi4py.MPI\n\n    hostname = socket.gethostname()\n\n    with get_mpi_comm() as mpi_comm:\n        n_cuda_devices = len(GPUtil.getGPUs())\n\n        if \"CUDA_VISIBLE_DEVICES\" in os.environ:\n            n_cuda_devices = len(os.environ[\"CUDA_VISIBLE_DEVICES\"].split(\",\"))\n\n        if n_cuda_devices &gt; 0:\n            device_idx = mpi_comm.rank % n_cuda_devices\n            os.environ[\"CUDA_VISIBLE_DEVICES\"] = f\"{device_idx}\"\n\n            _LOGGER.debug(\n                f\"hostname={hostname} \"\n                f\"rank={mpi4py.MPI.COMM_WORLD.rank} will use GPU={device_idx}\"\n            )\n\n        else:\n            _LOGGER.debug(f\"hostname={hostname} has no GPUs\")\n</code></pre>"},{"location":"reference/md/utils/mpi/#femto.md.utils.mpi.run_on_rank_zero","title":"run_on_rank_zero","text":"<pre><code>run_on_rank_zero(func)\n</code></pre> <p>A convenient decorator that ensures the function is only run on rank zero and that the outputs are broadcast to the other ranks.</p> Source code in <code>femto/md/utils/mpi.py</code> <pre><code>def run_on_rank_zero(func):\n    \"\"\"A convenient decorator that ensures the function is only run on rank zero and\n    that the outputs are broadcast to the other ranks.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        outputs = None\n        rank = 0\n\n        with get_mpi_comm() as mpi_comm:\n            if mpi_comm.rank == rank:\n                outputs = func(*args, **kwargs)\n\n            outputs = mpi_comm.bcast(outputs, root=rank)\n\n        return outputs\n\n    return wrapper\n</code></pre>"},{"location":"reference/md/utils/openmm/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> openmm","text":""},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm","title":"openmm","text":"<p>Utilities for manipulating OpenMM objects.</p> <p>Modules:</p> <ul> <li> <code>femto</code>           \u2013            <p>A comprehensive toolkit for predicting free energies</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>is_close</code>             \u2013              <p>Compares if two unit wrapped values are close using <code>numpy.is_close</code></p> </li> <li> <code>all_close</code>             \u2013              <p>Compares if all values in two unit wrapped array are close using</p> </li> <li> <code>assign_force_groups</code>             \u2013              <p>Assign standard force groups to forces in a system.</p> </li> <li> <code>check_for_nans</code>             \u2013              <p>Checks whether a state has NaN coordinates.</p> </li> <li> <code>compute_energy</code>             \u2013              <p>Computes the potential energy of a system at a given set of positions.</p> </li> <li> <code>evaluate_ctx_parameters</code>             \u2013              <p>Inspects an OpenMM system for any context parameters that contain special</p> </li> <li> <code>get_simulation_summary</code>             \u2013              <p>Returns a string summarising the current energy and volume of a system being</p> </li> <li> <code>create_integrator</code>             \u2013              <p>Creates an OpenMM integrator.</p> </li> <li> <code>create_simulation</code>             \u2013              <p>Creates an OpenMM simulation object.</p> </li> <li> <code>get_pressure</code>             \u2013              <p>Extracts the pressure from a system if it has a barostat.</p> </li> </ul>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.is_close","title":"is_close","text":"<pre><code>is_close(\n    v1: Quantity,\n    v2: Quantity,\n    rtol=1e-05,\n    atol=1e-08,\n    equal_nan=False,\n) -&gt; bool | ndarray\n</code></pre> <p>Compares if two unit wrapped values are close using <code>numpy.is_close</code></p> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def is_close(\n    v1: openmm.unit.Quantity,\n    v2: openmm.unit.Quantity,\n    rtol=1.0e-5,\n    atol=1.0e-8,\n    equal_nan=False,\n) -&gt; bool | numpy.ndarray:\n    \"\"\"Compares if two unit wrapped values are close using ``numpy.is_close``\"\"\"\n\n    if not v1.unit.is_compatible(v2.unit):\n        return False\n\n    return numpy.isclose(\n        v1.value_in_unit(v1.unit),\n        v2.value_in_unit(v1.unit),\n        atol=atol,\n        rtol=rtol,\n        equal_nan=equal_nan,\n    )\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.all_close","title":"all_close","text":"<pre><code>all_close(\n    v1: Quantity,\n    v2: Quantity,\n    rtol=1e-05,\n    atol=1e-08,\n    equal_nan=False,\n) -&gt; bool\n</code></pre> <p>Compares if all values in two unit wrapped array are close using <code>numpy.allclose</code></p> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def all_close(\n    v1: openmm.unit.Quantity,\n    v2: openmm.unit.Quantity,\n    rtol=1.0e-5,\n    atol=1.0e-8,\n    equal_nan=False,\n) -&gt; bool:\n    \"\"\"Compares if all values in two unit wrapped array are close using\n    ``numpy.allclose``\n    \"\"\"\n\n    if not v1.unit.is_compatible(v2.unit):\n        return False\n\n    if v1.shape != v2.shape:\n        return False\n\n    return numpy.allclose(\n        v1.value_in_unit(v1.unit),\n        v2.value_in_unit(v1.unit),\n        atol=atol,\n        rtol=rtol,\n        equal_nan=equal_nan,\n    )\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.assign_force_groups","title":"assign_force_groups","text":"<pre><code>assign_force_groups(system: System)\n</code></pre> <p>Assign standard force groups to forces in a system.</p> Notes <ul> <li>COM, alignment, and position restraints are detected by their name. If their   name is not set to a <code>OpenMMForceName</code>, they will be assigned a force group   of <code>OTHER</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to modify in-place.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def assign_force_groups(system: openmm.System):\n    \"\"\"Assign standard force groups to forces in a system.\n\n    Notes:\n        * COM, alignment, and position restraints are detected by their name. If their\n          name is not set to a ``OpenMMForceName``, they will be assigned a force group\n          of ``OTHER``.\n\n    Args:\n        system: The system to modify in-place.\n    \"\"\"\n\n    force: openmm.Force\n\n    for force in system.getForces():\n        if force.getName() == OpenMMForceName.COM_RESTRAINT:\n            force.setForceGroup(OpenMMForceGroup.COM_RESTRAINT)\n        elif force.getName() == OpenMMForceName.ALIGNMENT_RESTRAINT:\n            force.setForceGroup(OpenMMForceGroup.ALIGNMENT_RESTRAINT)\n        elif force.getName().startswith(OpenMMForceName.POSITION_RESTRAINT):\n            force.setForceGroup(OpenMMForceGroup.POSITION_RESTRAINT)\n\n        elif isinstance(force, openmm.HarmonicBondForce):\n            force.setForceGroup(OpenMMForceGroup.BOND)\n        elif isinstance(force, openmm.HarmonicAngleForce):\n            force.setForceGroup(OpenMMForceGroup.ANGLE)\n        elif isinstance(\n            force, (openmm.PeriodicTorsionForce, openmm.CustomTorsionForce)\n        ):\n            force.setForceGroup(OpenMMForceGroup.DIHEDRAL)\n        elif isinstance(force, (openmm.NonbondedForce, openmm.CustomNonbondedForce)):\n            force.setForceGroup(OpenMMForceGroup.NONBONDED)\n        elif isinstance(force, openmm.ATMForce):\n            force.setForceGroup(OpenMMForceGroup.ATM)\n        elif isinstance(force, openmm.MonteCarloBarostat):\n            force.setForceGroup(OpenMMForceGroup.BAROSTAT)\n        else:\n            force.setForceGroup(OpenMMForceGroup.OTHER)\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.check_for_nans","title":"check_for_nans","text":"<pre><code>check_for_nans(coords: State)\n</code></pre> <p>Checks whether a state has NaN coordinates.</p> <p>Raises:</p> <ul> <li> <code>OpenMMException</code>             \u2013            <p>If any of the coordinates are NaN.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def check_for_nans(coords: openmm.State):\n    \"\"\"Checks whether a state has NaN coordinates.\n\n    Raises:\n        openmm.OpenMMException: If any of the coordinates are NaN.\n    \"\"\"\n\n    if numpy.isnan(\n        coords.getPositions(asNumpy=True).value_in_unit(openmm.unit.angstrom)\n    ).any():\n        raise openmm.OpenMMException(\"Positions were NaN\")\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.compute_energy","title":"compute_energy","text":"<pre><code>compute_energy(\n    system: System,\n    positions: Quantity,\n    box_vectors: Quantity | None,\n    context_params: dict[str, float] | None = None,\n    platform: OpenMMPlatform = REFERENCE,\n    groups: int | set[int] = -1,\n) -&gt; Quantity\n</code></pre> <p>Computes the potential energy of a system at a given set of positions.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to compute the energy of.</p> </li> <li> <code>positions</code>               (<code>Quantity</code>)           \u2013            <p>The positions to compute the energy at.</p> </li> <li> <code>box_vectors</code>               (<code>Quantity | None</code>)           \u2013            <p>The box vectors to use if any.</p> </li> <li> <code>context_params</code>               (<code>dict[str, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Any global context parameters to set.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>, default:                   <code>REFERENCE</code> )           \u2013            <p>The platform to use.</p> </li> <li> <code>groups</code>               (<code>int | set[int]</code>, default:                   <code>-1</code> )           \u2013            <p>The force groups to include in the energy calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Quantity</code>           \u2013            <p>The computed energy.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def compute_energy(\n    system: openmm.System,\n    positions: openmm.unit.Quantity,\n    box_vectors: openmm.unit.Quantity | None,\n    context_params: dict[str, float] | None = None,\n    platform: OpenMMPlatform = OpenMMPlatform.REFERENCE,\n    groups: int | set[int] = -1,\n) -&gt; openmm.unit.Quantity:\n    \"\"\"Computes the potential energy of a system at a given set of positions.\n\n    Args:\n        system: The system to compute the energy of.\n        positions: The positions to compute the energy at.\n        box_vectors: The box vectors to use if any.\n        context_params: Any global context parameters to set.\n        platform: The platform to use.\n        groups: The force groups to include in the energy calculation.\n\n    Returns:\n        The computed energy.\n    \"\"\"\n    context_params = context_params if context_params is not None else {}\n\n    context = openmm.Context(\n        system,\n        openmm.VerletIntegrator(0.0001 * openmm.unit.femtoseconds),\n        openmm.Platform.getPlatformByName(str(platform)),\n    )\n\n    for key, value in context_params.items():\n        context.setParameter(key, value)\n\n    if box_vectors is not None:\n        context.setPeriodicBoxVectors(*box_vectors)\n    context.setPositions(positions)\n\n    return context.getState(getEnergy=True, groups=groups).getPotentialEnergy()\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.evaluate_ctx_parameters","title":"evaluate_ctx_parameters","text":"<pre><code>evaluate_ctx_parameters(\n    state: dict[str, float], system: System\n) -&gt; dict[str, float]\n</code></pre> <p>Inspects an OpenMM system for any context parameters that contain special keywords that indicate a computed value (e.g. <code>sqrt&lt;bm_b0&gt;</code>) and injects their values into a state dictionary.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>dict[str, float]</code>)           \u2013            <p>The core set of context parameter values that may appear in any expressions.</p> </li> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to inspect for context parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, float]</code>           \u2013            <p>The updated state dictionary.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def evaluate_ctx_parameters(\n    state: dict[str, float], system: openmm.System\n) -&gt; dict[str, float]:\n    \"\"\"Inspects an OpenMM system for any context parameters that contain special\n    keywords that indicate a computed value (e.g. ``sqrt&lt;bm_b0&gt;``) and injects their\n    values into a state dictionary.\n\n    Args:\n        state: The core set of context parameter values that may appear in any\n            expressions.\n        system: The system to inspect for context parameters.\n\n    Returns:\n        The updated state dictionary.\n    \"\"\"\n    import sympy\n\n    # create a context to easily see which global parameters are available to be set\n    ctx = openmm.Context(\n        system,\n        openmm.VerletIntegrator(0.0001),\n        openmm.Platform.getPlatformByName(\"Reference\"),\n    )\n    found_ctx_parameters = {*ctx.getParameters()}\n\n    updated_state = {**state}\n\n    for ctx_parameter in found_ctx_parameters:\n        expression = sympy.sympify(ctx_parameter.replace(\"&lt;\", \"(\").replace(\"&gt;\", \")\"))\n\n        if expression.is_symbol:\n            continue\n\n        value = expression.subs(state)\n\n        try:\n            value = float(value)\n        except TypeError as e:\n            raise ValueError(\n                f\"could not evaluate context parameter {ctx_parameter}\"\n            ) from e\n\n        updated_state[ctx_parameter] = value\n\n    missing = {*state} - {*updated_state}\n    assert len(missing) == 0, f\"missing ctx parameters: {missing}\"\n\n    return updated_state\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.get_simulation_summary","title":"get_simulation_summary","text":"<pre><code>get_simulation_summary(\n    simulation: Simulation, groups: set[int] | int = -1\n) -&gt; str\n</code></pre> <p>Returns a string summarising the current energy and volume of a system being simulated.</p> <p>Parameters:</p> <ul> <li> <code>simulation</code>               (<code>Simulation</code>)           \u2013            <p>The current simulation.</p> </li> <li> <code>groups</code>               (<code>set[int] | int</code>, default:                   <code>-1</code> )           \u2013            <p>The force groups to include in the energy calculation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The formatted string.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def get_simulation_summary(\n    simulation: openmm.app.Simulation, groups: set[int] | int = -1\n) -&gt; str:\n    \"\"\"Returns a string summarising the current energy and volume of a system being\n    simulated.\n\n    Args:\n        simulation: The current simulation.\n        groups: The force groups to include in the energy calculation.\n\n    Returns:\n        The formatted string.\n    \"\"\"\n\n    state = simulation.context.getState(getEnergy=True, groups=groups)\n\n    box_vectors = state.getPeriodicBoxVectors()\n    volume = box_vectors[0][0] * box_vectors[1][1] * box_vectors[2][2]\n\n    return f\"energy={state.getPotentialEnergy()} volume={volume}\"\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.create_integrator","title":"create_integrator","text":"<pre><code>create_integrator(\n    config: LangevinIntegrator, temperature: Quantity\n) -&gt; Integrator\n</code></pre> <p>Creates an OpenMM integrator.</p> <p>Parameters:</p> <ul> <li> <code>config</code>               (<code>LangevinIntegrator</code>)           \u2013            <p>The configuration of the integrator.</p> </li> <li> <code>temperature</code>               (<code>Quantity</code>)           \u2013            <p>The temperature to simulate at.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Integrator</code>           \u2013            <p>The created integrator.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def create_integrator(\n    config: femto.md.config.LangevinIntegrator, temperature: openmm.unit.Quantity\n) -&gt; openmm.Integrator:\n    \"\"\"Creates an OpenMM integrator.\n\n    Args:\n        config: The configuration of the integrator.\n        temperature: The temperature to simulate at.\n\n    Returns:\n        The created integrator.\n    \"\"\"\n\n    if isinstance(config, femto.md.config.LangevinIntegrator):\n        integrator = openmm.LangevinMiddleIntegrator(\n            temperature, config.friction, config.timestep\n        )\n        integrator.setConstraintTolerance(config.constraint_tolerance)\n    else:\n        raise NotImplementedError(f\"integrator type {type(config)} is not supported\")\n\n    return integrator\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.create_simulation","title":"create_simulation","text":"<pre><code>create_simulation(\n    system: System,\n    topology: Topology,\n    coords: State | None,\n    integrator: Integrator,\n    state: dict[str, float] | None,\n    platform: OpenMMPlatform,\n) -&gt; Simulation\n</code></pre> <p>Creates an OpenMM simulation object.</p> <p>Parameters:</p> <ul> <li> <code>system</code>               (<code>System</code>)           \u2013            <p>The system to simulate</p> </li> <li> <code>topology</code>               (<code>Topology</code>)           \u2013            <p>The topology being simulated.</p> </li> <li> <code>coords</code>               (<code>State | None</code>)           \u2013            <p>The initial coordinates and box vectors. If <code>None</code>, the coordinates and box vectors from the topology will be used.</p> </li> <li> <code>integrator</code>               (<code>Integrator</code>)           \u2013            <p>The integrator to evolve the system with.</p> </li> <li> <code>state</code>               (<code>dict[str, float] | None</code>)           \u2013            <p>The state of the system to simulate.</p> </li> <li> <code>platform</code>               (<code>OpenMMPlatform</code>)           \u2013            <p>The accelerator to run using.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Simulation</code>           \u2013            <p>The created simulation.</p> </li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def create_simulation(\n    system: openmm.System,\n    topology: mdtop.Topology,\n    coords: openmm.State | None,\n    integrator: openmm.Integrator,\n    state: dict[str, float] | None,\n    platform: femto.md.constants.OpenMMPlatform,\n) -&gt; openmm.app.Simulation:\n    \"\"\"Creates an OpenMM simulation object.\n\n    Args:\n        system: The system to simulate\n        topology: The topology being simulated.\n        coords: The initial coordinates and box vectors. If ``None``, the coordinates\n            and box vectors from the topology will be used.\n        integrator: The integrator to evolve the system with.\n        state: The state of the system to simulate.\n        platform: The accelerator to run using.\n\n    Returns:\n        The created simulation.\n    \"\"\"\n\n    platform_properties = (\n        {\"Precision\": \"mixed\"} if platform.upper() in [\"CUDA\", \"OPENCL\"] else {}\n    )\n    platform = openmm.Platform.getPlatformByName(platform)\n\n    if coords is not None:\n        system.setDefaultPeriodicBoxVectors(*coords.getPeriodicBoxVectors())\n    else:\n        system.setDefaultPeriodicBoxVectors(*topology.box)\n\n    simulation = openmm.app.Simulation(\n        topology.to_openmm(), system, integrator, platform, platform_properties\n    )\n\n    if coords is None:\n        simulation.context.setPeriodicBoxVectors(*topology.box)\n        simulation.context.setPositions(topology.xyz)\n    else:\n        simulation.context.setState(coords)\n\n    state = femto.md.utils.openmm.evaluate_ctx_parameters(state, simulation.system)\n\n    for k, v in state.items():\n        simulation.context.setParameter(k, v)\n\n    return simulation\n</code></pre>"},{"location":"reference/md/utils/openmm/#femto.md.utils.openmm.get_pressure","title":"get_pressure","text":"<pre><code>get_pressure(system: System) -&gt; Quantity | None\n</code></pre> <p>Extracts the pressure from a system if it has a barostat.</p> Notes <ul> <li>If the system has no barostat, this function will return <code>None</code>.</li> <li>Only the first barostat found will be used.</li> </ul> Source code in <code>femto/md/utils/openmm.py</code> <pre><code>def get_pressure(system: openmm.System) -&gt; openmm.unit.Quantity | None:\n    \"\"\"Extracts the pressure from a system if it has a barostat.\n\n    Notes:\n        * If the system has no barostat, this function will return ``None``.\n        * Only the first barostat found will be used.\n    \"\"\"\n\n    barostats = [\n        force\n        for force in system.getForces()\n        if isinstance(\n            force,\n            (\n                openmm.MonteCarloBarostat,\n                openmm.MonteCarloAnisotropicBarostat,\n                openmm.MonteCarloFlexibleBarostat,\n                openmm.MonteCarloMembraneBarostat,\n            ),\n        )\n    ]\n    assert len(barostats) == 0 or len(barostats) == 1\n\n    return (\n        None\n        if len(barostats) == 0 or barostats[0].getFrequency() &lt;= 0\n        else barostats[0].getDefaultPressure()\n    )\n</code></pre>"}]}